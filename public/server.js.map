{"version":3,"file":"server.js","sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/mongoose/lib/utils.js","webpack:///./node_modules/mongoose/lib/error/index.js","webpack:///./node_modules/mongoose/lib/document.js","webpack:///./node_modules/mongoose/lib/schematype.js","webpack:///./node_modules/mongoose/lib/error/cast.js","webpack:///./node_modules/depd/index.js","webpack:///./node_modules/mongoose/lib/queryhelpers.js","webpack:///./node_modules/mongoose/lib/driver.js","webpack:///./node_modules/express/lib/utils.js","webpack:///./node_modules/mongoose/lib/types/objectid.js","webpack:///./node_modules/mongoose/lib/options.js","webpack:///./node_modules/mongoose/lib/schema/mixed.js","webpack:///./node_modules/mongoose/lib/types/documentarray.js","webpack:///./node_modules/bytes/index.js","webpack:///./node_modules/http-errors/index.js","webpack:///./node_modules/type-is/index.js","webpack:///./node_modules/parseurl/index.js","webpack:///./node_modules/mongoose/lib/helpers/immediate.js","webpack:///./node_modules/mongoose/lib/helpers/common.js","webpack:///./node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js","webpack:///./node_modules/mongoose/lib/types/embedded.js","webpack:///./node_modules/mongoose/lib/types/index.js","webpack:///./node_modules/content-type/index.js","webpack:///./node_modules/body-parser/lib/read.js","webpack:///./node_modules/on-finished/index.js","webpack:///./node_modules/encodeurl/index.js","webpack:///./node_modules/escape-html/index.js","webpack:///./node_modules/mongoose/lib/connectionstate.js","webpack:///./node_modules/mongoose/lib/promise_provider.js","webpack:///./node_modules/mongoose/lib/error/mongooseError.js","webpack:///./node_modules/mongoose/lib/schema.js","webpack:///./node_modules/mongoose/lib/schema/operators/helpers.js","webpack:///./node_modules/express/index.js","webpack:///./node_modules/methods/index.js","webpack:///./node_modules/send/index.js","webpack:///./node_modules/mquery/lib/mquery.js","webpack:///./node_modules/mongoose/lib/error/validation.js","webpack:///./node_modules/mongoose/lib/schema/operators/exists.js","webpack:///./node_modules/mongoose/lib/cast/boolean.js","webpack:///./node_modules/mongoose/lib/error/strict.js","webpack:///./node_modules/mongoose/lib/virtualtype.js","webpack:///./node_modules/mongoose/lib/helpers/document/compile.js","webpack:///./node_modules/mongoose/lib/helpers/model/applyHooks.js","webpack:///./node_modules/mongoose/lib/schema/index.js","webpack:///./node_modules/mongoose/lib/schema/number.js","webpack:///./node_modules/mongoose/lib/schema/array.js","webpack:///./node_modules/mongoose/lib/schema/objectid.js","webpack:///./node_modules/mongoose/lib/types/map.js","webpack:///./node_modules/mongoose/lib/cast.js","webpack:///./node_modules/mongoose/lib/types/array.js","webpack:///./node_modules/mongoose/lib/helpers/model/discriminator.js","webpack:///./node_modules/mongoose/lib/query.js","webpack:///./node_modules/depd/lib/compat/index.js","webpack:///./node_modules/unpipe/index.js","webpack:///./node_modules/mime-types/index.js","webpack:///./node_modules/express/lib/router/index.js","webpack:///./node_modules/express/lib/router/route.js","webpack:///./node_modules/express/lib/router/layer.js","webpack:///./node_modules/express/lib/middleware/query.js","webpack:///./node_modules/content-disposition/index.js","webpack:///./node_modules/etag/index.js","webpack:///./node_modules/fresh/index.js","webpack:///./node_modules/range-parser/index.js","webpack:///./node_modules/proxy-addr/index.js","webpack:///./node_modules/object-assign/index.js","webpack:///./node_modules/mongoose/lib/drivers/node-mongodb-native/collection.js","webpack:///./node_modules/mongoose/lib/collection.js","webpack:///./node_modules/mquery/lib/utils.js","webpack:///./node_modules/mongoose/lib/schema/operators/type.js","webpack:///./node_modules/mongoose/lib/error/objectExpected.js","webpack:///./node_modules/mongoose/lib/error/objectParameter.js","webpack:///./node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js","webpack:///./node_modules/mongoose/lib/document_provider.js","webpack:///./node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js","webpack:///./node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js","webpack:///./node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js","webpack:///./node_modules/mongoose/lib/helpers/query/applyQueryMiddleware.js","webpack:///./node_modules/mongoose/lib/schema/string.js","webpack:///./node_modules/mongoose/lib/cast/string.js","webpack:///./node_modules/mongoose/lib/cast/number.js","webpack:///./node_modules/mongoose/lib/schema/operators/bitwise.js","webpack:///./node_modules/mongoose/lib/schema/boolean.js","webpack:///./node_modules/mongoose/lib/schema/date.js","webpack:///./node_modules/mongoose/lib/schema/buffer.js","webpack:///./node_modules/mongoose/lib/types/buffer.js","webpack:///./node_modules/mongoose/lib/schema/map.js","webpack:///./node_modules/mongoose/lib/schema/operators/geospatial.js","webpack:///./node_modules/mongoose/lib/types/subdocument.js","webpack:///./node_modules/mongoose/lib/helpers/cursor/eachAsync.js","webpack:///./node_modules/mongoose/lib/helpers/query/castUpdate.js","webpack:///./node_modules/mongoose/lib/aggregate.js","webpack:///./node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js","webpack:///./node_modules/mongoose/lib/connection.js","webpack:///./node_modules/express/lib/express.js","webpack:///./node_modules/body-parser/index.js","webpack:///./node_modules/depd/lib/compat/callsite-tostring.js","webpack:///./node_modules/depd/lib/compat/event-listener-count.js","webpack:///./node_modules/body-parser/lib/types/json.js","webpack:///./node_modules/statuses/index.js","webpack:///./node_modules/raw-body/index.js","webpack:///./node_modules/ee-first/index.js","webpack:///./node_modules/media-typer/index.js","webpack:///./node_modules/mime-db/index.js","webpack:///./node_modules/body-parser/lib/types/raw.js","webpack:///./node_modules/body-parser/lib/types/text.js","webpack:///./node_modules/body-parser/lib/types/urlencoded.js","webpack:///./node_modules/merge-descriptors/index.js","webpack:///./node_modules/express/lib/application.js","webpack:///./node_modules/finalhandler/index.js","webpack:///./node_modules/finalhandler/node_modules/statuses/index.js","webpack:///./node_modules/express/lib/middleware/init.js","webpack:///./node_modules/express/lib/view.js","webpack:///./node_modules/destroy/index.js","webpack:///./node_modules/send/node_modules/statuses/index.js","webpack:///./node_modules/forwarded/index.js","webpack:///./node_modules/express/lib/request.js","webpack:///./node_modules/accepts/index.js","webpack:///./node_modules/negotiator/index.js","webpack:///./node_modules/express/lib/response.js","webpack:///./node_modules/express/node_modules/statuses/index.js","webpack:///./node_modules/cookie/index.js","webpack:///./node_modules/vary/index.js","webpack:///./node_modules/serve-static/index.js","webpack:///./node_modules/react/cjs/react.production.min.js","webpack:///./node_modules/react-dom/cjs/react-dom-server.node.production.min.js","webpack:///./node_modules/mongoose/lib/index.js","webpack:///./node_modules/mongoose/lib/drivers/node-mongodb-native/index.js","webpack:///./node_modules/mongoose/lib/drivers/node-mongodb-native/binary.js","webpack:///./node_modules/mpath/lib/index.js","webpack:///./node_modules/mongoose/lib/internal.js","webpack:///./node_modules/mongoose/lib/statemachine.js","webpack:///./node_modules/mongoose/lib/error/notFound.js","webpack:///./node_modules/mongoose/lib/error/validator.js","webpack:///./node_modules/mongoose/lib/error/version.js","webpack:///./node_modules/mongoose/lib/error/parallelSave.js","webpack:///./node_modules/mongoose/lib/error/overwriteModel.js","webpack:///./node_modules/mongoose/lib/error/missingSchema.js","webpack:///./node_modules/mongoose/lib/error/divergentArray.js","webpack:///./node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js","webpack:///./node_modules/mongoose/lib/plugins/idGetter.js","webpack:///./node_modules/mongoose/lib/helpers/projection/isExclusive.js","webpack:///./node_modules/mongoose/lib/browserDocument.js","webpack:///./node_modules/mongoose/lib/helpers/schema/getIndexes.js","webpack:///./node_modules/mongoose/lib/schema/documentarray.js","webpack:///./node_modules/mongoose/lib/schema/operators/text.js","webpack:///./node_modules/mongoose/lib/schema/embedded.js","webpack:///./node_modules/mongoose/lib/schema/decimal128.js","webpack:///./node_modules/mongoose/lib/drivers/node-mongodb-native/decimal128.js","webpack:///./node_modules/mongoose/lib/drivers/node-mongodb-native/objectid.js","webpack:///./node_modules/mongoose/lib/drivers/node-mongodb-native/ReadPreference.js","webpack:///./node_modules/mongoose/lib/cursor/QueryCursor.js","webpack:///./node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js","webpack:///./node_modules/mongoose/lib/helpers/query/completeMany.js","webpack:///./node_modules/mongoose/lib/helpers/query/hasDollarKeys.js","webpack:///./node_modules/mongoose/lib/helpers/projection/isInclusive.js","webpack:///./node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js","webpack:///./node_modules/mongoose/lib/helpers/updateValidators.js","webpack:///./node_modules/mongoose/lib/model.js","webpack:///./node_modules/mongoose/lib/cursor/AggregationCursor.js","webpack:///./node_modules/mongoose/lib/cursor/ChangeStream.js","webpack:///./node_modules/mongoose/lib/helpers/model/applyMethods.js","webpack:///./node_modules/mongoose/lib/helpers/model/applyStatics.js","webpack:///./node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js","webpack:///./node_modules/mongoose/lib/helpers/model/castBulkWrite.js","webpack:///./node_modules/mongoose/lib/helpers/projection/isPathExcluded.js","webpack:///./node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js","webpack:///./node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js","webpack:///./node_modules/mongoose/lib/helpers/populate/getVirtual.js","webpack:///./node_modules/mongoose/lib/helpers/schema/setParentPointers.js","webpack:///./node_modules/mongoose-legacy-pluralize/index.js","webpack:///./node_modules/mongoose/lib/plugins/removeSubdocs.js","webpack:///./node_modules/mongoose/lib/plugins/saveSubdocs.js","webpack:///./node_modules/mongoose/lib/plugins/validateBeforeSave.js","webpack:///./node_modules/mongoose/lib/plugins/sharding.js","webpack:///./node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 472);\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Decimal = require('./types/decimal128');\nconst ObjectId = require('./types/objectid');\nconst PromiseProvider = require('./promise_provider');\nconst cloneRegExp = require('regexp-clone');\nconst get = require('lodash.get');\nconst sliced = require('sliced');\nconst mpath = require('mpath');\nconst ms = require('ms');\nconst Buffer = require('safe-buffer').Buffer;\n\nlet MongooseBuffer;\nlet MongooseArray;\nlet Document;\n\n/*!\n * Produces a collection name from model `name`. By default, just returns\n * the model name\n *\n * @param {String} name a model name\n * @param {Function} pluralize function that pluralizes the collection name\n * @return {String} a collection name\n * @api private\n */\n\nexports.toCollectionName = function(name, pluralize) {\n  if (name === 'system.profile') {\n    return name;\n  }\n  if (name === 'system.indexes') {\n    return name;\n  }\n  if (typeof pluralize === 'function') {\n    return pluralize(name);\n  }\n  return name;\n};\n\n/*!\n * Determines if `a` and `b` are deep equal.\n *\n * Modified from node/lib/assert.js\n *\n * @param {any} a a value to compare to `b`\n * @param {any} b a value to compare to `a`\n * @return {Boolean}\n * @api private\n */\n\nexports.deepEqual = function deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n\n  if ((isBsonType(a, 'ObjectID') && isBsonType(b, 'ObjectID')) ||\n      (isBsonType(a, 'Decimal128') && isBsonType(b, 'Decimal128'))) {\n    return a.toString() === b.toString();\n  }\n\n  if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source &&\n        a.ignoreCase === b.ignoreCase &&\n        a.multiline === b.multiline &&\n        a.global === b.global;\n  }\n\n  if (typeof a !== 'object' && typeof b !== 'object') {\n    return a == b;\n  }\n\n  if (a === null || b === null || a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  // Handle MongooseNumbers\n  if (a instanceof Number && b instanceof Number) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (Buffer.isBuffer(a)) {\n    return exports.buffer.areEqual(a, b);\n  }\n\n  if (isMongooseObject(a)) {\n    a = a.toObject();\n  }\n  if (isMongooseObject(b)) {\n    b = b.toObject();\n  }\n\n  let ka;\n  let kb;\n  let key;\n  let i;\n  try {\n    ka = Object.keys(a);\n    kb = Object.keys(b);\n  } catch (e) {\n    // happens when one is a string literal and the other isn't\n    return false;\n  }\n\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length) {\n    return false;\n  }\n\n  // the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n\n  // ~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i]) {\n      return false;\n    }\n  }\n\n  // equivalent values for every corresponding key, and\n  // ~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/*!\n * Get the bson type, if it exists\n */\n\nfunction isBsonType(obj, typename) {\n  return get(obj, '_bsontype', void 0) === typename;\n}\n\n/*!\n * Get the last element of an array\n */\n\nexports.last = function(arr) {\n  if (arr.length > 0) {\n    return arr[arr.length - 1];\n  }\n  return void 0;\n};\n\n/*!\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\n\nexports.clone = function clone(obj, options) {\n  if (obj === undefined || obj === null) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      return obj.toJSON(options);\n    }\n    return obj.toObject(options);\n  }\n\n  if (obj.constructor) {\n    switch (exports.getFunctionName(obj.constructor)) {\n      case 'Object':\n        return cloneObject(obj, options);\n      case 'Date':\n        return new obj.constructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (obj instanceof ObjectId) {\n    return new ObjectId(obj.id);\n  }\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  if (!obj.constructor && exports.isObject(obj)) {\n    // object created with Object.create(null)\n    return cloneObject(obj, options);\n  }\n\n  if (obj.valueOf) {\n    return obj.valueOf();\n  }\n};\nconst clone = exports.clone;\n\n/*!\n * ignore\n */\n\nexports.promiseOrCallback = function promiseOrCallback(callback, fn) {\n  if (typeof callback === 'function') {\n    try {\n      return fn(callback);\n    } catch (error) {\n      return process.nextTick(() => {\n        throw error;\n      });\n    }\n  }\n\n  const Promise = PromiseProvider.get();\n\n  return new Promise((resolve, reject) => {\n    fn(function(error, res) {\n      if (error != null) {\n        return reject(error);\n      }\n      if (arguments.length > 2) {\n        return resolve(Array.prototype.slice.call(arguments, 1));\n      }\n      resolve(res);\n    });\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options) {\n  const minimize = options && options.minimize;\n  const ret = {};\n  let hasKeys;\n  let val;\n  let k;\n\n  for (k in obj) {\n    val = clone(obj[k], options);\n\n    if (!minimize || (typeof val !== 'undefined')) {\n      hasKeys || (hasKeys = true);\n      ret[k] = val;\n    }\n  }\n\n  return minimize ? hasKeys && ret : ret;\n}\n\nfunction cloneArray(arr, options) {\n  const ret = [];\n  for (let i = 0, l = arr.length; i < l; i++) {\n    ret.push(clone(arr[i], options));\n  }\n  return ret;\n}\n\n/*!\n * Shallow copies defaults into options.\n *\n * @param {Object} defaults\n * @param {Object} options\n * @return {Object} the merged object\n * @api private\n */\n\nexports.options = function(defaults, options) {\n  const keys = Object.keys(defaults);\n  let i = keys.length;\n  let k;\n\n  options = options || {};\n\n  while (i--) {\n    k = keys[i];\n    if (!(k in options)) {\n      options[k] = defaults[k];\n    }\n  }\n\n  return options;\n};\n\n/*!\n * Generates a random string\n *\n * @api private\n */\n\nexports.random = function() {\n  return Math.random().toString().substr(3);\n};\n\n/*!\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.merge = function merge(to, from, options, path) {\n  options = options || {};\n\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  path = path || '';\n  const omitNested = options.omitNested || {};\n\n  while (i < len) {\n    key = keys[i++];\n    if (options.omit && options.omit[key]) {\n      continue;\n    }\n    if (omitNested[path]) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (exports.isObject(from[key])) {\n      if (!exports.isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null && from[key].instanceOfSchema) {\n        to[key] = from[key].clone();\n        continue;\n      }\n      merge(to[key], from[key], options, path ? path + '.' + key : key);\n    } else if (options.overwrite) {\n      to[key] = from[key];\n    }\n  }\n};\n\n/*!\n * Applies toObject recursively.\n *\n * @param {Document|Array|Object} obj\n * @return {Object}\n * @api private\n */\n\nexports.toObject = function toObject(obj) {\n  Document || (Document = require('./document'));\n  let ret;\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (obj instanceof Document) {\n    return obj.toObject();\n  }\n\n  if (Array.isArray(obj)) {\n    ret = [];\n\n    for (let i = 0, len = obj.length; i < len; ++i) {\n      ret.push(toObject(obj[i]));\n    }\n\n    return ret;\n  }\n\n  if ((obj.constructor && exports.getFunctionName(obj.constructor) === 'Object') ||\n      (!obj.constructor && exports.isObject(obj))) {\n    ret = {};\n\n    for (const k in obj) {\n      ret[k] = toObject(obj[k]);\n    }\n\n    return ret;\n  }\n\n  return obj;\n};\n\n/*!\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nexports.isObject = function(arg) {\n  if (Buffer.isBuffer(arg)) {\n    return true;\n  }\n  return Object.prototype.toString.call(arg) === '[object Object]';\n};\n\n/*!\n * Determines if `arg` is a plain object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nexports.isPOJO = function(arg) {\n  return get(arg, 'constructor.name') === 'Object';\n};\n\n/*!\n * A faster Array.prototype.slice.call(arguments) alternative\n * @api private\n */\n\nexports.args = sliced;\n\n/*!\n * process.nextTick helper.\n *\n * Wraps `callback` in a try/catch + nextTick.\n *\n * node-mongodb-native has a habit of state corruption when an error is immediately thrown from within a collection callback.\n *\n * @param {Function} callback\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if (typeof callback !== 'function') {\n    return;\n  }\n  return function() {\n    try {\n      callback.apply(this, arguments);\n    } catch (err) {\n      // only nextTick on err to get out of\n      // the event loop and avoid state corruption.\n      process.nextTick(function() {\n        throw err;\n      });\n    }\n  };\n};\n\n/*!\n * Returns if `v` is a mongoose object that has a `toObject()` method we can use.\n *\n * This is for compatibility with libs like Date.js which do foolish things to Natives.\n *\n * @param {any} v\n * @api private\n */\n\nexports.isMongooseObject = function(v) {\n  Document || (Document = require('./document'));\n  MongooseArray || (MongooseArray = require('./types').Array);\n  MongooseBuffer || (MongooseBuffer = require('./types').Buffer);\n\n  if (v == null) {\n    return false;\n  }\n\n  return v.$__ != null || // Document\n    v.isMongooseArray || // Array or Document Array\n    v.isMongooseBuffer || // Buffer\n    v.$isMongooseMap; // Map\n};\n\nconst isMongooseObject = exports.isMongooseObject;\n\n/*!\n * Converts `expires` options of index objects to `expiresAfterSeconds` options for MongoDB.\n *\n * @param {Object} object\n * @api private\n */\n\nexports.expires = function expires(object) {\n  if (!(object && object.constructor.name === 'Object')) {\n    return;\n  }\n  if (!('expires' in object)) {\n    return;\n  }\n\n  let when;\n  if (typeof object.expires !== 'string') {\n    when = object.expires;\n  } else {\n    when = Math.round(ms(object.expires) / 1000);\n  }\n  object.expireAfterSeconds = when;\n  delete object.expires;\n};\n\n/*!\n * Populate options constructor\n */\n\nfunction PopulateOptions(path, select, match, options, model, subPopulate, justOne) {\n  this.path = path;\n  this.match = match;\n  this.select = select;\n  this.options = options;\n  this.model = model;\n  if (typeof subPopulate === 'object') {\n    this.populate = subPopulate;\n  }\n  if (justOne != null) {\n    this.justOne = justOne;\n  }\n  this._docs = {};\n}\n\n// make it compatible with utils.clone\nPopulateOptions.prototype.constructor = Object;\n\n// expose\nexports.PopulateOptions = PopulateOptions;\n\n/*!\n * populate helper\n */\n\nexports.populate = function populate(path, select, model, match, options, subPopulate, justOne) {\n  // The order of select/conditions args is opposite Model.find but\n  // necessary to keep backward compatibility (select could be\n  // an array, string, or object literal).\n  function makeSingles(arr) {\n    const ret = [];\n    arr.forEach(function(obj) {\n      if (/[\\s]/.test(obj.path)) {\n        const paths = obj.path.split(' ');\n        paths.forEach(function(p) {\n          const copy = Object.assign({}, obj);\n          copy.path = p;\n          ret.push(copy);\n        });\n      } else {\n        ret.push(obj);\n      }\n    });\n\n    return ret;\n  }\n\n  // might have passed an object specifying all arguments\n  if (arguments.length === 1) {\n    if (path instanceof PopulateOptions) {\n      return [path];\n    }\n\n    if (Array.isArray(path)) {\n      const singles = makeSingles(path);\n      return singles.map(function(o) {\n        if (o.populate && !(o.match || o.options)) {\n          return exports.populate(\n            o.path,\n            o.select,\n            o.model,\n            o.match,\n            o.options,\n            o.populate,\n            o.justOne)[0];\n        } else {\n          return exports.populate(o)[0];\n        }\n      });\n    }\n\n    if (exports.isObject(path)) {\n      match = path.match;\n      options = path.options;\n      select = path.select;\n      model = path.model;\n      subPopulate = path.populate;\n      justOne = path.justOne;\n      path = path.path;\n    }\n  } else if (typeof model === 'object') {\n    options = match;\n    match = model;\n    model = undefined;\n  }\n\n  if (typeof path !== 'string') {\n    throw new TypeError('utils.populate: invalid path. Expected string. Got typeof `' + typeof path + '`');\n  }\n\n  if (Array.isArray(subPopulate)) {\n    const ret = [];\n    subPopulate.forEach(function(obj) {\n      if (/[\\s]/.test(obj.path)) {\n        const copy = Object.assign({}, obj);\n        const paths = copy.path.split(' ');\n        paths.forEach(function(p) {\n          copy.path = p;\n          ret.push(exports.populate(copy)[0]);\n        });\n      } else {\n        ret.push(exports.populate(obj)[0]);\n      }\n    });\n    subPopulate = exports.populate(ret);\n  } else if (typeof subPopulate === 'object') {\n    subPopulate = exports.populate(subPopulate);\n  }\n\n  const ret = [];\n  const paths = path.split(' ');\n  options = exports.clone(options);\n  for (let i = 0; i < paths.length; ++i) {\n    ret.push(new PopulateOptions(paths[i], select, match, options, model, subPopulate, justOne));\n  }\n\n  return ret;\n};\n\n/*!\n * Return the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Object} obj\n */\n\nexports.getValue = function(path, obj, map) {\n  return mpath.get(path, obj, '_doc', map);\n};\n\n/*!\n * Sets the value of `obj` at the given `path`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} obj\n */\n\nexports.setValue = function(path, val, obj, map, _copying) {\n  mpath.set(path, val, obj, '_doc', map, _copying);\n};\n\n/*!\n * Returns an array of values from object `o`.\n *\n * @param {Object} o\n * @return {Array}\n * @private\n */\n\nexports.object = {};\nexports.object.vals = function vals(o) {\n  const keys = Object.keys(o);\n  let i = keys.length;\n  const ret = [];\n\n  while (i--) {\n    ret.push(o[keys[i]]);\n  }\n\n  return ret;\n};\n\n/*!\n * @see exports.options\n */\n\nexports.object.shallowCopy = exports.options;\n\n/*!\n * Safer helper for hasOwnProperty checks\n *\n * @param {Object} obj\n * @param {String} prop\n */\n\nconst hop = Object.prototype.hasOwnProperty;\nexports.object.hasOwnProperty = function(obj, prop) {\n  return hop.call(obj, prop);\n};\n\n/*!\n * Determine if `val` is null or undefined\n *\n * @return {Boolean}\n */\n\nexports.isNullOrUndefined = function(val) {\n  return val === null || val === undefined;\n};\n\n/*!\n * ignore\n */\n\nexports.array = {};\n\n/*!\n * Flattens an array.\n *\n * [ 1, [ 2, 3, [4] ]] -> [1,2,3,4]\n *\n * @param {Array} arr\n * @param {Function} [filter] If passed, will be invoked with each item in the array. If `filter` returns a falsey value, the item will not be included in the results.\n * @return {Array}\n * @private\n */\n\nexports.array.flatten = function flatten(arr, filter, ret) {\n  ret || (ret = []);\n\n  arr.forEach(function(item) {\n    if (Array.isArray(item)) {\n      flatten(item, filter, ret);\n    } else {\n      if (!filter || filter(item)) {\n        ret.push(item);\n      }\n    }\n  });\n\n  return ret;\n};\n\n/*!\n * Removes duplicate values from an array\n *\n * [1, 2, 3, 3, 5] => [1, 2, 3, 5]\n * [ ObjectId(\"550988ba0c19d57f697dc45e\"), ObjectId(\"550988ba0c19d57f697dc45e\") ]\n *    => [ObjectId(\"550988ba0c19d57f697dc45e\")]\n *\n * @param {Array} arr\n * @return {Array}\n * @private\n */\n\nexports.array.unique = function(arr) {\n  const primitives = {};\n  const ids = {};\n  const ret = [];\n  const length = arr.length;\n  for (let i = 0; i < length; ++i) {\n    if (typeof arr[i] === 'number' || typeof arr[i] === 'string' || arr[i] == null) {\n      if (primitives[arr[i]]) {\n        continue;\n      }\n      ret.push(arr[i]);\n      primitives[arr[i]] = true;\n    } else if (arr[i] instanceof ObjectId) {\n      if (ids[arr[i].toString()]) {\n        continue;\n      }\n      ret.push(arr[i]);\n      ids[arr[i].toString()] = true;\n    } else {\n      ret.push(arr[i]);\n    }\n  }\n\n  return ret;\n};\n\n/*!\n * Determines if two buffers are equal.\n *\n * @param {Buffer} a\n * @param {Object} b\n */\n\nexports.buffer = {};\nexports.buffer.areEqual = function(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    return false;\n  }\n  if (!Buffer.isBuffer(b)) {\n    return false;\n  }\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0, len = a.length; i < len; ++i) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.getFunctionName = function(fn) {\n  if (fn.name) {\n    return fn.name;\n  }\n  return (fn.toString().trim().match(/^function\\s*([^\\s(]+)/) || [])[1];\n};\n\nexports.decorate = function(destination, source) {\n  for (const key in source) {\n    destination[key] = source[key];\n  }\n};\n\n/**\n * merges to with a copy of from\n *\n * @param {Object} to\n * @param {Object} fromObj\n * @api private\n */\n\nexports.mergeClone = function(to, fromObj) {\n  if (isMongooseObject(fromObj)) {\n    fromObj = fromObj.toObject({\n      transform: false,\n      virtuals: false,\n      depopulate: true,\n      getters: false,\n      flattenDecimals: false\n    });\n  }\n  const keys = Object.keys(fromObj);\n  const len = keys.length;\n  let i = 0;\n  let key;\n\n  while (i < len) {\n    key = keys[i++];\n    if (typeof to[key] === 'undefined') {\n      to[key] = exports.clone(fromObj[key], {\n        transform: false,\n        virtuals: false,\n        depopulate: true,\n        getters: false,\n        flattenDecimals: false\n      });\n    } else {\n      let val = fromObj[key];\n      if (val != null && val.valueOf && !(val instanceof Date)) {\n        val = val.valueOf();\n      }\n      if (exports.isObject(val)) {\n        let obj = val;\n        if (isMongooseObject(val) && !val.isMongooseBuffer) {\n          obj = obj.toObject({\n            transform: false,\n            virtuals: false,\n            depopulate: true,\n            getters: false,\n            flattenDecimals: false\n          });\n        }\n        if (val.isMongooseBuffer) {\n          obj = Buffer.from(obj);\n        }\n        exports.mergeClone(to[key], obj);\n      } else {\n        to[key] = exports.clone(val, {\n          flattenDecimals: false\n        });\n      }\n    }\n  }\n};\n\n/**\n * Executes a function on each element of an array (like _.each)\n *\n * @param {Array} arr\n * @param {Function} fn\n * @api private\n */\n\nexports.each = function(arr, fn) {\n  for (let i = 0; i < arr.length; ++i) {\n    fn(arr[i]);\n  }\n};\n\n/*!\n * ignore\n */\n\nexports.noop = function() {};\n","'use strict';\n\nconst MongooseError = require('./mongooseError');\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseError;\n\n/**\n * The default built-in validator error messages.\n *\n * @see Error.messages #error_messages_MongooseError-messages\n * @api public\n */\n\nMongooseError.messages = require('./messages');\n\n// backward compat\nMongooseError.Messages = MongooseError.messages;\n\n/**\n * An instance of this error class will be returned when `save()` fails\n * because the underlying\n * document was not found. The constructor takes one parameter, the\n * conditions that mongoose passed to `update()` when trying to update\n * the document.\n *\n * @api public\n */\n\nMongooseError.DocumentNotFoundError = require('./notFound');\n\n/**\n * An instance of this error class will be returned when mongoose failed to\n * cast a value.\n *\n * @api public\n */\n\nMongooseError.CastError = require('./cast');\n\n/**\n * An instance of this error class will be returned when [validation](/docs/validation.html) failed.\n *\n * @api public\n */\n\nMongooseError.ValidationError = require('./validation');\n\n/**\n * A `ValidationError` has a hash of `errors` that contain individual `ValidatorError` instances\n *\n * @api public\n */\n\nMongooseError.ValidatorError = require('./validator');\n\n/**\n * An instance of this error class will be returned when you call `save()` after\n * the document in the database was changed in a potentially unsafe way. See\n * the [`versionKey` option](/docs/guide.html#versionKey) for more information.\n *\n * @api public\n */\n\nMongooseError.VersionError = require('./version');\n\n/**\n * An instance of this error class will be returned when you call `save()` multiple\n * times on the same document in parallel. See the [FAQ](/docs/faq.html) for more\n * information.\n *\n * @api public\n */\n\nMongooseError.ParallelSaveError = require('./parallelSave');\n\n/**\n * Thrown when a model with the given name was already registered on the connection.\n * See [the FAQ about `OverwriteModelError`](/docs/faq.html#overwrite-model-error).\n *\n * @api public\n */\n\nMongooseError.OverwriteModelError = require('./overwriteModel');\n\n/**\n * Thrown when you try to access a model that has not been registered yet\n *\n * @api public\n */\n\nMongooseError.MissingSchemaError = require('./missingSchema');\n\n/**\n * An instance of this error will be returned if you used an array projection\n * and then modified the array in an unsafe way.\n *\n * @api public\n */\n\nMongooseError.DivergentArrayError = require('./divergentArray');\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst InternalCache = require('./internal');\nconst MongooseError = require('./error');\nconst MixedSchema = require('./schema/mixed');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst ObjectParameterError = require('./error/objectParameter');\nconst StrictModeError = require('./error/strict');\nconst ValidatorError = require('./schematype').ValidatorError;\nconst VirtualType = require('./virtualtype');\nconst cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');\nconst compile = require('./helpers/document/compile').compile;\nconst defineKey = require('./helpers/document/compile').defineKey;\nconst flatten = require('./helpers/common').flatten;\nconst get = require('lodash.get');\nconst getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');\nconst idGetter = require('./plugins/idGetter');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst isExclusive = require('./helpers/projection/isExclusive');\nconst inspect = require('util').inspect;\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst mpath = require('mpath');\nconst utils = require('./utils');\n\nconst ValidationError = MongooseError.ValidationError;\nconst clone = utils.clone;\nconst deepEqual = utils.deepEqual;\nconst isMongooseObject = utils.isMongooseObject;\n\nlet DocumentArray;\nlet MongooseArray;\nlet Embedded;\n\nconst specialProperties = ['__proto__', 'constructor', 'prototype'];\n\n/**\n * The core Mongoose document constructor. You should not call this directly,\n * the Mongoose [Model constructor](./api.html#Model) calls this for you.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retreived from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, fields, skipId, options) {\n  if (typeof skipId === 'object' && skipId != null) {\n    options = skipId;\n    skipId = options.skipId;\n  }\n  options = options || {};\n\n  this.$__ = new InternalCache;\n  this.$__.emitter = new EventEmitter();\n  this.isNew = 'isNew' in options ? options.isNew : true;\n  this.errors = undefined;\n  this.$__.$options = options || {};\n\n  if (obj != null && typeof obj !== 'object') {\n    throw new ObjectParameterError(obj, 'obj', 'Document');\n  }\n\n  const schema = this.schema;\n\n  if (typeof fields === 'boolean') {\n    this.$__.strictMode = fields;\n    fields = undefined;\n  } else {\n    this.$__.strictMode = schema.options.strict;\n    this.$__.selected = fields;\n  }\n\n  const required = schema.requiredPaths(true);\n  for (let i = 0; i < required.length; ++i) {\n    this.$__.activePaths.require(required[i]);\n  }\n\n  this.$__.emitter.setMaxListeners(0);\n\n  let exclude = null;\n\n  // determine if this doc is a result of a query with\n  // excluded fields\n  if (fields && utils.getFunctionName(fields.constructor) === 'Object') {\n    exclude = isExclusive(fields);\n  }\n\n  const hasIncludedChildren = exclude === false && fields ?\n    $__hasIncludedChildren(fields) :\n    {};\n\n  this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);\n\n  // By default, defaults get applied **before** setting initial values\n  // Re: gh-6155\n  $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {\n    isNew: this.isNew\n  });\n\n  if (obj) {\n    if (obj instanceof Document) {\n      this.isNew = obj.isNew;\n    }\n    // Skip set hooks\n    if (this.$__original_set) {\n      this.$__original_set(obj, undefined, true);\n    } else {\n      this.$set(obj, undefined, true);\n    }\n  }\n\n  // Function defaults get applied **after** setting initial values so they\n  // see the full doc rather than an empty one, unless they opt out.\n  // Re: gh-3781, gh-6155\n  if (options.willInit) {\n    this.once('init', () => {\n      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n        isNew: this.isNew\n      });\n    });\n  } else {\n    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {\n      isNew: this.isNew\n    });\n  }\n\n  this.$__._id = this._id;\n\n  if (!schema.options.strict && obj) {\n    const _this = this;\n    const keys = Object.keys(this._doc);\n\n    keys.forEach(function(key) {\n      if (!(key in schema.tree)) {\n        defineKey(key, null, _this);\n      }\n    });\n  }\n\n  applyQueue(this);\n}\n\n/*!\n * Document exposes the NodeJS event emitter API, so you can use\n * `on`, `once`, etc.\n */\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document.prototype[emitterFn] = function() {\n      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);\n    };\n  });\n\nDocument.prototype.constructor = Document;\n\n/**\n * The documents schema.\n *\n * @api public\n * @property schema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.schema;\n\n/**\n * Boolean flag specifying if the document is new.\n *\n * @api public\n * @property isNew\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.isNew;\n\n/**\n * The string version of this documents _id.\n *\n * ####Note:\n *\n * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.\n *\n *     new Schema({ name: String }, { id: false });\n *\n * @api public\n * @see Schema options /docs/guide.html#options\n * @property id\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.id;\n\n/**\n * Hash containing current validation errors.\n *\n * @api public\n * @property errors\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.errors;\n\n/*!\n * ignore\n */\n\nfunction $__hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n  for (let j = 0; j < keys.length; ++j) {\n    const parts = keys[j].split('.');\n    const c = [];\n    for (let k = 0; k < parts.length; ++k) {\n      c.push(parts[k]);\n      hasIncludedChildren[c.join('.')] = 1;\n    }\n  }\n\n  return hasIncludedChildren;\n}\n\n/*!\n * ignore\n */\n\nfunction $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip, options) {\n  const paths = Object.keys(doc.schema.paths);\n  const plen = paths.length;\n  const init = options && 'isNew' in options ? options.isNew : false;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && skipId) {\n      continue;\n    }\n\n    const type = doc.schema.paths[p];\n    const path = p.split('.');\n    const len = path.length;\n    let included = false;\n    let doc_ = doc._doc;\n\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (typeof type.defaultValue === 'function') {\n          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n            break;\n          }\n          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n            break;\n          }\n        } else if (!isBeforeSetters) {\n          // Non-function defaults should always run **before** setters\n          continue;\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            def = type.getDefault(doc, init);\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          } else if (included) {\n            // selected field\n            def = type.getDefault(doc, init);\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              doc.$__.activePaths.default(p);\n            }\n          }\n        } else {\n          def = type.getDefault(doc, init);\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            doc.$__.activePaths.default(p);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n}\n\n/**\n * Builds the default doc structure\n *\n * @param {Object} obj\n * @param {Object} [fields]\n * @param {Boolean} [skipId]\n * @api private\n * @method $__buildDoc\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {\n  const doc = {};\n\n  const paths = Object.keys(this.schema.paths).\n    // Don't build up any paths that are underneath a map, we don't know\n    // what the keys will be\n    filter(p => !p.includes('$*'));\n  const plen = paths.length;\n  let ii = 0;\n\n  for (; ii < plen; ++ii) {\n    const p = paths[ii];\n\n    if (p === '_id') {\n      if (skipId) {\n        continue;\n      }\n      if (obj && '_id' in obj) {\n        continue;\n      }\n    }\n\n    const path = p.split('.');\n    const len = path.length;\n    const last = len - 1;\n    let curPath = '';\n    let doc_ = doc;\n    let included = false;\n\n    for (let i = 0; i < len; ++i) {\n      const piece = path[i];\n\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      // support excluding intermediary levels\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        if (curPath in fields) {\n          included = true;\n        } else if (!hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (i < last) {\n        doc_ = doc_[piece] || (doc_[piece] = {});\n      }\n    }\n  }\n\n  this._doc = doc;\n};\n\n/*!\n * Converts to POJO when you use the document for querying\n */\n\nDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Initializes the document without setters or marking anything modified.\n *\n * Called internally after a document is returned from mongodb. Normally,\n * you do **not** need to call this function on your own.\n *\n * This function triggers `init` [middleware](/docs/middleware.html).\n * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).\n *\n * @param {Object} doc document returned by mongo\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.init = function(doc, opts, fn) {\n  if (typeof opts === 'function') {\n    fn = opts;\n    opts = null;\n  }\n\n  this.$__init(doc, opts);\n\n  if (fn) {\n    fn(null, this);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__init = function(doc, opts) {\n  this.isNew = false;\n  this.$init = true;\n\n  // handle docs with populated paths\n  // If doc._id is not null or undefined\n  if (doc._id !== null && doc._id !== undefined &&\n    opts && opts.populated && opts.populated.length) {\n    const id = String(doc._id);\n    for (let i = 0; i < opts.populated.length; ++i) {\n      const item = opts.populated[i];\n      if (item.isVirtual) {\n        this.populated(item.path, utils.getValue(item.path, doc), item);\n      } else {\n        this.populated(item.path, item._docs[id], item);\n      }\n    }\n  }\n\n  init(this, doc, this._doc);\n\n  this.emit('init', this);\n  this.constructor.emit('init', this);\n\n  this.$__._id = this._id;\n\n  return this;\n};\n\n/*!\n * Init helper.\n *\n * @param {Object} self document instance\n * @param {Object} obj raw mongodb doc\n * @param {Object} doc object we are initializing\n * @api private\n */\n\nfunction init(self, obj, doc, prefix) {\n  prefix = prefix || '';\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  let schema;\n  let path;\n  let i;\n  let index = 0;\n\n  while (index < len) {\n    _init(index++);\n  }\n\n  function _init(index) {\n    i = keys[index];\n    path = prefix + i;\n    schema = self.schema.path(path);\n\n    // Should still work if not a model-level discriminator, but should not be\n    // necessary. This is *only* to catch the case where we queried using the\n    // base model and the discriminated model has a projection\n    if (self.schema.$isRootDiscriminator && !self.isSelected(path)) {\n      return;\n    }\n\n    if (!schema && utils.isObject(obj[i]) &&\n        (!obj[i].constructor || utils.getFunctionName(obj[i].constructor) === 'Object')) {\n      // assume nested object\n      if (!doc[i]) {\n        doc[i] = {};\n      }\n      init(self, obj[i], doc[i], path + '.');\n    } else if (!schema) {\n      doc[i] = obj[i];\n    } else {\n      if (obj[i] === null) {\n        doc[i] = null;\n      } else if (obj[i] !== undefined) {\n        const intCache = obj[i].$__ || {};\n        const wasPopulated = intCache.wasPopulated || null;\n        if (schema && !wasPopulated) {\n          try {\n            doc[i] = schema.cast(obj[i], self, true);\n          } catch (e) {\n            self.invalidate(e.path, new ValidatorError({\n              path: e.path,\n              message: e.message,\n              type: 'cast',\n              value: e.value\n            }));\n          }\n        } else {\n          doc[i] = obj[i];\n        }\n      }\n      // mark as hydrated\n      if (!self.isModified(path)) {\n        self.$__.activePaths.init(path);\n      }\n    }\n  }\n}\n\n/**\n * Sends an update command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.update](#model_Model.update)\n *\n * @see Model.update #model_Model.update\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.update = function update() {\n  const args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.update.apply(this.constructor, args);\n};\n\n/**\n * Sends an updateOne command with this document `_id` as the query selector.\n *\n * ####Example:\n *\n *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);\n *\n * ####Valid options:\n *\n *  - same as in [Model.updateOne](#model_Model.updateOne)\n *\n * @see Model.updateOne #model_Model.updateOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.updateOne = function updateOne() {\n  const args = utils.args(arguments);\n  args.unshift({_id: this._id});\n  return this.constructor.updateOne.apply(this.constructor, args);\n};\n\n/**\n * Sends a replaceOne command with this document `_id` as the query selector.\n *\n * ####Valid options:\n *\n *  - same as in [Model.replaceOne](#model_Model.replaceOne)\n *\n * @see Model.replaceOne #model_Model.replaceOne\n * @param {Object} doc\n * @param {Object} options\n * @param {Function} callback\n * @return {Query}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.replaceOne = function replaceOne() {\n  const args = utils.args(arguments);\n  args.unshift({ _id: this._id });\n  return this.constructor.replaceOne.apply(this.constructor, args);\n};\n\n/**\n * Getter/setter around the session associated with this document. Used to\n * automatically set `session` if you `save()` a doc that you got from a\n * query with an associated session.\n *\n * ####Example:\n *\n *     const session = MyModel.startSession();\n *     const doc = await MyModel.findOne().session(session);\n *     doc.$session() === session; // true\n *     doc.$session(null);\n *     doc.$session() === null; // true\n *\n * If this is a top-level document, setting the session propagates to all child\n * docs.\n *\n * @param {ClientSession} [session] overwrite the current session\n * @return {ClientSession}\n * @method $session\n * @api public\n * @memberOf Document\n */\n\nDocument.prototype.$session = function $session(session) {\n  if (arguments.length === 0) {\n    return this.$__.session;\n  }\n  this.$__.session = session;\n\n  if (!this.ownerDocument) {\n    const subdocs = this.$__getAllSubdocs();\n    for (const child of subdocs) {\n      child.$session(session);\n    }\n  }\n\n  return session;\n};\n\n/**\n * Alias for `set()`, used internally to avoid conflicts\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @method $set\n * @name $set\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$set = function $set(path, val, type, options) {\n  if (type && utils.getFunctionName(type.constructor) === 'Object') {\n    options = type;\n    type = undefined;\n  }\n\n  options = options || {};\n  const merge = options.merge;\n  const adhoc = type && type !== true;\n  const constructing = type === true;\n  let adhocs;\n  let keys;\n  let i = 0;\n  let pathtype;\n  let key;\n  let prefix;\n\n  const strict = 'strict' in options\n    ? options.strict\n    : this.$__.strictMode;\n\n  if (adhoc) {\n    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});\n    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  if (typeof path !== 'string') {\n    // new Document({ key: val })\n    if (path === null || path === void 0) {\n      const _ = path;\n      path = val;\n      val = _;\n    } else {\n      prefix = val ? val + '.' : '';\n\n      if (path instanceof Document) {\n        if (path.$__isNested) {\n          path = path.toObject();\n        } else {\n          path = path._doc;\n        }\n      }\n\n      keys = Object.keys(path);\n      const len = keys.length;\n\n      if (len === 0 && !this.schema.options.minimize) {\n        if (val) {\n          this.$set(val, {});\n        }\n        return this;\n      }\n\n      while (i < len) {\n        _handleIndex.call(this, i++);\n      }\n\n      return this;\n    }\n  }\n\n  function _handleIndex(i) {\n    key = keys[i];\n    const pathName = prefix + key;\n    pathtype = this.schema.pathType(pathName);\n\n    // On initial set, delete any nested keys if we're going to overwrite\n    // them to ensure we keep the user's key order.\n    if (type === true &&\n        !prefix &&\n        path[key] != null &&\n        pathtype === 'nested' &&\n        this._doc[key] != null &&\n        Object.keys(this._doc[key]).length === 0) {\n      delete this._doc[key];\n    }\n\n    if (path[key] !== null &&\n        path[key] !== void 0 &&\n        // need to know if plain object - no Buffer, ObjectId, ref, etc\n        utils.isObject(path[key]) &&\n        (!path[key].constructor || utils.getFunctionName(path[key].constructor) === 'Object') &&\n        pathtype !== 'virtual' &&\n        pathtype !== 'real' &&\n        !(this.$__path(pathName) instanceof MixedSchema) &&\n        !(this.schema.paths[pathName] &&\n        this.schema.paths[pathName].options &&\n        this.schema.paths[pathName].options.ref)) {\n      this.$set(path[key], prefix + key, constructing);\n    } else if (strict) {\n      // Don't overwrite defaults with undefined keys (gh-3981)\n      if (constructing && path[key] === void 0 &&\n          this.get(key) !== void 0) {\n        return;\n      }\n\n      if (pathtype === 'adhocOrUndefined') {\n        pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });\n      }\n\n      if (pathtype === 'real' || pathtype === 'virtual') {\n        // Check for setting single embedded schema to document (gh-3535)\n        let p = path[key];\n        if (this.schema.paths[pathName] &&\n            this.schema.paths[pathName].$isSingleNested &&\n            path[key] instanceof Document) {\n          p = p.toObject({ virtuals: false, transform: false });\n        }\n        this.$set(prefix + key, p, constructing);\n      } else if (pathtype === 'nested' && path[key] instanceof Document) {\n        this.$set(prefix + key,\n          path[key].toObject({transform: false}), constructing);\n      } else if (strict === 'throw') {\n        if (pathtype === 'nested') {\n          throw new ObjectExpectedError(key, path[key]);\n        } else {\n          throw new StrictModeError(key);\n        }\n      }\n    } else if (path[key] !== void 0) {\n      this.$set(prefix + key, path[key], constructing);\n    }\n  }\n\n  const pathType = this.schema.pathType(path);\n  if (pathType === 'nested' && val) {\n    if (utils.isObject(val) &&\n        (!val.constructor || utils.getFunctionName(val.constructor) === 'Object')) {\n      if (!merge) {\n        this.setValue(path, null);\n        cleanModifiedSubpaths(this, path);\n      } else {\n        return this.$set(val, path, constructing);\n      }\n\n      const keys = Object.keys(val);\n      this.setValue(path, {});\n      for (const key of keys) {\n        this.$set(path + '.' + key, val[key], constructing);\n      }\n      this.markModified(path);\n      cleanModifiedSubpaths(this, path, { skipDocArrays: true });\n      return this;\n    }\n    this.invalidate(path, new MongooseError.CastError('Object', val, path));\n    return this;\n  }\n\n  let schema;\n  const parts = path.split('.');\n\n  if (pathType === 'adhocOrUndefined' && strict) {\n    // check for roots that are Mixed types\n    let mixed;\n\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n\n      // If path is underneath a virtual, bypass everything and just set it.\n      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {\n        mpath.set(path, val, this);\n        return this;\n      }\n\n      schema = this.schema.path(subpath);\n      if (schema == null) {\n        continue;\n      }\n\n      if (schema instanceof MixedSchema) {\n        // allow changes to sub paths of mixed types\n        mixed = true;\n        break;\n      }\n    }\n\n    if (schema == null) {\n      // Check for embedded discriminators\n      schema = getEmbeddedDiscriminatorPath(this, path);\n    }\n\n    if (!mixed && !schema) {\n      if (strict === 'throw') {\n        throw new StrictModeError(path);\n      }\n      return this;\n    }\n  } else if (pathType === 'virtual') {\n    schema = this.schema.virtualpath(path);\n    schema.applySetters(val, this);\n    return this;\n  } else {\n    schema = this.$__path(path);\n  }\n\n  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it\n  let cur = this._doc;\n  let curPath = '';\n  for (i = 0; i < parts.length - 1; ++i) {\n    cur = cur[parts[i]];\n    curPath += (curPath.length > 0 ? '.' : '') + parts[i];\n    if (!cur) {\n      this.$set(curPath, {});\n      // Hack re: gh-5800. If nested field is not selected, it probably exists\n      // so `MongoError: cannot use the part (nested of nested.num) to\n      // traverse the element ({nested: null})` is not likely. If user gets\n      // that error, its their fault for now. We should reconsider disallowing\n      // modifying not selected paths for 6.x\n      if (!this.isSelected(curPath)) {\n        this.unmarkModified(curPath);\n      }\n      cur = this.getValue(curPath);\n    }\n  }\n\n  let pathToMark;\n\n  // When using the $set operator the path to the field must already exist.\n  // Else mongodb throws: \"LEFT_SUBFIELD only supports Object\"\n\n  if (parts.length <= 1) {\n    pathToMark = path;\n  } else {\n    for (i = 0; i < parts.length; ++i) {\n      const subpath = parts.slice(0, i + 1).join('.');\n      if (this.isDirectModified(subpath) // earlier prefixes that are already\n      // marked as dirty have precedence\n          || this.get(subpath) === null) {\n        pathToMark = subpath;\n        break;\n      }\n    }\n\n    if (!pathToMark) {\n      pathToMark = path;\n    }\n  }\n\n  // if this doc is being constructed we should not trigger getters\n  const priorVal = (() => {\n    if (this.$__.$options.priorDoc != null) {\n      return this.$__.$options.priorDoc.getValue(path);\n    }\n    if (constructing) {\n      return void 0;\n    }\n    return this.getValue(path);\n  })();\n\n  if (!schema) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n    return this;\n  }\n\n  let shouldSet = true;\n  try {\n    // If the user is trying to set a ref path to a document with\n    // the correct model name, treat it as populated\n    const refMatches = (() => {\n      if (schema.options == null) {\n        return false;\n      }\n      if (!(val instanceof Document)) {\n        return false;\n      }\n      const model = val.constructor;\n\n      // Check ref\n      const ref = schema.options.ref;\n      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {\n        return true;\n      }\n\n      // Check refPath\n      const refPath = schema.options.refPath;\n      if (refPath == null) {\n        return false;\n      }\n      const modelName = val.get(refPath);\n      if (modelName === model.modelName || modelName === model.baseModelName) {\n        return true;\n      }\n      return false;\n    })();\n\n    let didPopulate = false;\n    if (refMatches && val instanceof Document) {\n      if (this.ownerDocument) {\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val._id, {model: val.constructor});\n      } else {\n        this.populated(path, val._id, {model: val.constructor});\n      }\n      didPopulate = true;\n    }\n\n    let popOpts;\n    if (schema.options &&\n        Array.isArray(schema.options[this.schema.options.typeKey]) &&\n        schema.options[this.schema.options.typeKey].length &&\n        schema.options[this.schema.options.typeKey][0].ref &&\n        Array.isArray(val) &&\n        val.length > 0 &&\n        val[0] instanceof Document &&\n        val[0].constructor.modelName &&\n        (schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.baseModelName || schema.options[this.schema.options.typeKey][0].ref === val[0].constructor.modelName)) {\n      if (this.ownerDocument) {\n        popOpts = { model: val[0].constructor };\n        this.ownerDocument().populated(this.$__fullPath(path),\n          val.map(function(v) { return v._id; }), popOpts);\n      } else {\n        popOpts = { model: val[0].constructor };\n        this.populated(path, val.map(function(v) { return v._id; }), popOpts);\n      }\n      didPopulate = true;\n    }\n\n    // If this path is underneath a single nested schema, we'll call the setter\n    // later in `$__set()` because we don't take `_doc` when we iterate through\n    // a single nested doc. That's to make sure we get the correct context.\n    // Otherwise we would double-call the setter, see gh-7196.\n    if (this.schema.singleNestedPaths[path] == null) {\n      const setterContext = constructing && this.$__.$options.priorDoc ?\n        this.$__.$options.priorDoc :\n        this;\n      val = schema.applySetters(val, setterContext, false, priorVal);\n    }\n\n    if (!didPopulate && this.$__.populated) {\n      delete this.$__.populated[path];\n    }\n\n    this.$markValid(path);\n  } catch (e) {\n    this.invalidate(path,\n      new MongooseError.CastError(schema.instance, val, path, e));\n    shouldSet = false;\n  }\n\n  if (shouldSet) {\n    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);\n  }\n\n  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {\n    cleanModifiedSubpaths(this, path);\n  }\n\n  return this;\n};\n\n/**\n * Sets the value of a path, or many paths.\n *\n * ####Example:\n *\n *     // path, value\n *     doc.set(path, value)\n *\n *     // object\n *     doc.set({\n *         path  : value\n *       , path2 : {\n *            path  : value\n *         }\n *     })\n *\n *     // on-the-fly cast to number\n *     doc.set(path, value, Number)\n *\n *     // on-the-fly cast to string\n *     doc.set(path, value, String)\n *\n *     // changing strict mode behavior\n *     doc.set(path, value, { strict: false });\n *\n * @param {String|Object} path path or object of key/vals to set\n * @param {Any} val the value to set\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for \"on-the-fly\" attributes\n * @param {Object} [options] optionally specify options that modify the behavior of the set\n * @api public\n * @method set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.set = Document.prototype.$set;\n\n/**\n * Determine if we should mark this change as modified.\n *\n * @return {Boolean}\n * @api private\n * @method $__shouldModify\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  if (this.isNew) {\n    return true;\n  }\n\n  if (val === void 0 && !this.isSelected(path)) {\n    // when a path is not selected in a query, its initial\n    // value will be undefined.\n    return true;\n  }\n\n  if (val === void 0 && path in this.$__.activePaths.states.default) {\n    // we're just unsetting the default value which was never saved\n    return false;\n  }\n\n  // gh-3992: if setting a populated field to a doc, don't mark modified\n  // if they have the same _id\n  if (this.populated(path) &&\n      val instanceof Document &&\n      deepEqual(val._id, priorVal)) {\n    return false;\n  }\n\n  if (!deepEqual(val, priorVal || this.get(path))) {\n    return true;\n  }\n\n  if (!constructing &&\n      val !== null &&\n      val !== undefined &&\n      path in this.$__.activePaths.states.default &&\n      deepEqual(val, schema.getDefault(this, constructing))) {\n    // a path with a default was $unset on the server\n    // and the user is setting it to the same value again\n    return true;\n  }\n  return false;\n};\n\n/**\n * Handles the actual setting of the value and marking the path modified if appropriate.\n *\n * @api private\n * @method $__set\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {\n  Embedded = Embedded || require('./types/embedded');\n\n  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,\n    schema, val, priorVal);\n  const _this = this;\n\n  if (shouldModify) {\n    this.markModified(pathToMark);\n\n    // handle directly setting arrays (gh-1126)\n    MongooseArray || (MongooseArray = require('./types/array'));\n    if (val && val.isMongooseArray) {\n      val._registerAtomic('$set', val);\n\n      // Update embedded document parent references (gh-5189)\n      if (val.isMongooseDocumentArray) {\n        val.forEach(function(item) {\n          item && item.__parentArray && (item.__parentArray = val);\n        });\n      }\n\n      // Small hack for gh-1638: if we're overwriting the entire array, ignore\n      // paths that were modified before the array overwrite\n      this.$__.activePaths.forEach(function(modifiedPath) {\n        if (modifiedPath.indexOf(path + '.') === 0) {\n          _this.$__.activePaths.ignore(modifiedPath);\n        }\n      });\n    }\n  }\n\n  let obj = this._doc;\n  let i = 0;\n  const l = parts.length;\n  let cur = '';\n\n  for (; i < l; i++) {\n    const next = i + 1;\n    const last = next === l;\n    cur += (cur ? '.' + parts[i] : parts[i]);\n    if (specialProperties.indexOf(parts[i]) !== -1) {\n      return;\n    }\n\n    if (last) {\n      if (obj instanceof Map) {\n        obj.set(parts[i], val);\n      } else {\n        obj[parts[i]] = val;\n      }\n    } else {\n      if (obj[parts[i]] && utils.getFunctionName(obj[parts[i]].constructor) === 'Object') {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {\n        obj = obj[parts[i]];\n      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {\n        obj = obj[parts[i]];\n      } else {\n        obj[parts[i]] = obj[parts[i]] || {};\n        obj = obj[parts[i]];\n      }\n    }\n  }\n};\n\n/**\n * Gets a raw value from a path (no getters)\n *\n * @param {String} path\n * @api private\n */\n\nDocument.prototype.getValue = function(path) {\n  return utils.getValue(path, this._doc);\n};\n\n/**\n * Sets a raw value for a path (no casting, setters, transformations)\n *\n * @param {String} path\n * @param {Object} value\n * @api private\n */\n\nDocument.prototype.setValue = function(path, val) {\n  utils.setValue(path, val, this._doc);\n  return this;\n};\n\n/**\n * Returns the value of a path.\n *\n * ####Example\n *\n *     // path\n *     doc.get('age') // 47\n *\n *     // dynamic casting to a string\n *     doc.get('age', String) // \"47\"\n *\n * @param {String} path\n * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes\n * @api public\n */\n\nDocument.prototype.get = function(path, type, options) {\n  let adhoc;\n  options = options || {};\n  if (type) {\n    adhoc = this.schema.interpretAsType(path, type, this.schema.options);\n  }\n\n  const schema = this.$__path(path) || this.schema.virtualpath(path);\n  const pieces = path.split('.');\n  let obj = this._doc;\n\n  if (schema instanceof VirtualType) {\n    if (schema.getters.length === 0) {\n      return void 0;\n    }\n    return schema.applyGetters(null, this);\n  }\n\n  for (let i = 0, l = pieces.length; i < l; i++) {\n    if (obj && obj._doc) {\n      obj = obj._doc;\n    }\n\n    if (obj == null) {\n      obj = void 0;\n    } else if (obj instanceof Map) {\n      obj = obj.get(pieces[i]);\n    } else if (i === l - 1) {\n      obj = utils.getValue(pieces[i], obj);\n    } else {\n      obj = obj[pieces[i]];\n    }\n  }\n\n  if (adhoc) {\n    obj = adhoc.cast(obj);\n  }\n\n  if (schema) {\n    obj = schema.applyGetters(obj, this);\n  } else if (this.schema.nested[path] && options.virtuals) {\n    // Might need to apply virtuals if this is a nested path\n    return applyGetters(this, utils.clone(obj), 'virtuals', { path: path });\n  }\n\n  return obj;\n};\n\n/**\n * Returns the schematype for the given `path`.\n *\n * @param {String} path\n * @api private\n * @method $__path\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__path = function(path) {\n  const adhocs = this.$__.adhocPaths;\n  const adhocType = adhocs && adhocs[path];\n\n  if (adhocType) {\n    return adhocType;\n  }\n  return this.schema.path(path);\n};\n\n/**\n * Marks the path as having pending changes to write to the db.\n *\n * _Very helpful when using [Mixed](./schematypes.html#mixed) types._\n *\n * ####Example:\n *\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *     doc.save() // changes to mixed.type are now persisted\n *\n * @param {String} path the path to mark modified\n * @param {Document} [scope] the scope to run validators with\n * @api public\n */\n\nDocument.prototype.markModified = function(path, scope) {\n  this.$__.activePaths.modify(path);\n  if (scope != null && !this.ownerDocument) {\n    this.$__.pathsToScopes[path] = scope;\n  }\n};\n\n/**\n * Clears the modified state on the specified path.\n *\n * ####Example:\n *\n *     doc.foo = 'bar';\n *     doc.unmarkModified('foo');\n *     doc.save(); // changes to foo will not be persisted\n *\n * @param {String} path the path to unmark modified\n * @api public\n */\n\nDocument.prototype.unmarkModified = function(path) {\n  this.$__.activePaths.init(path);\n  delete this.$__.pathsToScopes[path];\n};\n\n/**\n * Don't run validation on this path or persist changes to this path.\n *\n * ####Example:\n *\n *     doc.foo = null;\n *     doc.$ignore('foo');\n *     doc.save(); // changes to foo will not be persisted and validators won't be run\n *\n * @memberOf Document\n * @instance\n * @method $ignore\n * @param {String} path the path to ignore\n * @api public\n */\n\nDocument.prototype.$ignore = function(path) {\n  this.$__.activePaths.ignore(path);\n};\n\n/**\n * Returns the list of paths that have been modified.\n *\n * @param {Object} [options]\n * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.\n * @return {Array}\n * @api public\n */\n\nDocument.prototype.modifiedPaths = function(options) {\n  options = options || {};\n  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n  const _this = this;\n  return directModifiedPaths.reduce(function(list, path) {\n    const parts = path.split('.');\n    list = list.concat(parts.reduce(function(chains, part, i) {\n      return chains.concat(parts.slice(0, i).concat(part).join('.'));\n    }, []).filter(function(chain) {\n      return (list.indexOf(chain) === -1);\n    }));\n\n    if (!options.includeChildren) {\n      return list;\n    }\n\n    let cur = _this.get(path);\n    if (cur != null && typeof cur === 'object') {\n      if (cur._doc) {\n        cur = cur._doc;\n      }\n      if (Array.isArray(cur)) {\n        const len = cur.length;\n        for (let i = 0; i < len; ++i) {\n          if (list.indexOf(path + '.' + i) === -1) {\n            list.push(path + '.' + i);\n            if (cur[i] != null && cur[i].$__) {\n              const modified = cur[i].modifiedPaths();\n              for (const childPath of modified) {\n                list.push(path + '.' + i + '.' + childPath);\n              }\n            }\n          }\n        }\n      } else {\n        Object.keys(cur).\n          filter(function(key) {\n            return list.indexOf(path + '.' + key) === -1;\n          }).\n          forEach(function(key) {\n            list.push(path + '.' + key);\n          });\n      }\n    }\n\n    return list;\n  }, []);\n};\n\n/**\n * Returns true if this document was modified, else false.\n *\n * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isModified()                      // true\n *     doc.isModified('documents')           // true\n *     doc.isModified('documents.0.title')   // true\n *     doc.isModified('documents otherProp') // true\n *     doc.isDirectModified('documents')     // false\n *\n * @param {String} [path] optional\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isModified = function(paths, modifiedPaths) {\n  if (paths) {\n    if (!Array.isArray(paths)) {\n      paths = paths.split(' ');\n    }\n    const modified = modifiedPaths || this.modifiedPaths();\n    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);\n    const isModifiedChild = paths.some(function(path) {\n      return !!~modified.indexOf(path);\n    });\n    return isModifiedChild || paths.some(function(path) {\n      return directModifiedPaths.some(function(mod) {\n        return mod === path || path.indexOf(mod + '.') === 0;\n      });\n    });\n  }\n  return this.$__.activePaths.some('modify');\n};\n\n/**\n * Checks if a path is set to its default.\n *\n * ####Example\n *\n *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });\n *     var m = new MyModel();\n *     m.$isDefault('name'); // true\n *\n * @memberOf Document\n * @instance\n * @method $isDefault\n * @param {String} [path]\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.$isDefault = function(path) {\n  return (path in this.$__.activePaths.states.default);\n};\n\n/**\n * Getter/setter, determines whether the document was removed or not.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       product.isDeleted(); // true\n *       product.remove(); // no-op, doesn't send anything to the db\n *\n *       product.isDeleted(false);\n *       product.isDeleted(); // false\n *       product.remove(); // will execute a remove against the db\n *     })\n *\n * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted\n * @return {Boolean} whether mongoose thinks this doc is deleted.\n * @method $isDeleted\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.$isDeleted = function(val) {\n  if (arguments.length === 0) {\n    return !!this.$__.isDeleted;\n  }\n\n  this.$__.isDeleted = !!val;\n  return this;\n};\n\n/**\n * Returns true if `path` was directly set and modified, else false.\n *\n * ####Example\n *\n *     doc.set('documents.0.title', 'changed');\n *     doc.isDirectModified('documents.0.title') // true\n *     doc.isDirectModified('documents') // false\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectModified = function(path) {\n  return (path in this.$__.activePaths.states.modify);\n};\n\n/**\n * Checks if `path` was initialized.\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isInit = function(path) {\n  return (path in this.$__.activePaths.states.init);\n};\n\n/**\n * Checks if `path` was selected in the source query which initialized this document.\n *\n * ####Example\n *\n *     Thing.findOne().select('name').exec(function (err, doc) {\n *        doc.isSelected('name') // true\n *        doc.isSelected('age')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isSelected = function isSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    i = paths.length;\n    const pathDot = path + '.';\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n\n      if (cur.indexOf(pathDot) === 0) {\n        return inclusive || cur !== pathDot;\n      }\n\n      if (pathDot.indexOf(cur + '.') === 0) {\n        return inclusive;\n      }\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\n/**\n * Checks if `path` was explicitly selected. If no projection, always returns\n * true.\n *\n * ####Example\n *\n *     Thing.findOne().select('nested.name').exec(function (err, doc) {\n *        doc.isDirectSelected('nested.name') // true\n *        doc.isDirectSelected('nested.otherName') // false\n *        doc.isDirectSelected('nested')  // false\n *     })\n *\n * @param {String} path\n * @return {Boolean}\n * @api public\n */\n\nDocument.prototype.isDirectSelected = function isDirectSelected(path) {\n  if (this.$__.selected) {\n    if (path === '_id') {\n      return this.$__.selected._id !== 0;\n    }\n\n    const paths = Object.keys(this.$__.selected);\n    let i = paths.length;\n    let inclusive = null;\n    let cur;\n\n    if (i === 1 && paths[0] === '_id') {\n      // only _id was selected.\n      return this.$__.selected._id === 0;\n    }\n\n    while (i--) {\n      cur = paths[i];\n      if (cur === '_id') {\n        continue;\n      }\n      if (!isDefiningProjection(this.$__.selected[cur])) {\n        continue;\n      }\n      inclusive = !!this.$__.selected[cur];\n      break;\n    }\n\n    if (inclusive === null) {\n      return true;\n    }\n\n    if (path in this.$__.selected) {\n      return inclusive;\n    }\n\n    return !inclusive;\n  }\n\n  return true;\n};\n\n/**\n * Executes registered validation rules for this document.\n *\n * ####Note:\n *\n * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.\n *\n * ####Example:\n *\n *     doc.validate(function (err) {\n *       if (err) handleError(err);\n *       else // validation passed\n *     });\n *\n * @param {Object} optional options internal options\n * @param {Function} callback optional callback called after validation completes, passing an error if one occurred\n * @return {Promise} Promise\n * @api public\n */\n\nDocument.prototype.validate = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  return utils.promiseOrCallback(callback, cb => this.$__validate(function(error) {\n    cb(error);\n  }));\n};\n\n/*!\n * ignore\n */\n\nfunction _evaluateRequiredFunctions(doc) {\n  Object.keys(doc.$__.activePaths.states.require).forEach(path => {\n    const p = doc.schema.path(path);\n\n    if (p != null && typeof p.originalRequiredValue === 'function') {\n      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc);\n    }\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction _getPathsToValidate(doc) {\n  let i;\n  let len;\n  const skipSchemaValidators = {};\n\n  _evaluateRequiredFunctions(doc);\n\n  // only validate required fields when necessary\n  let paths = Object.keys(doc.$__.activePaths.states.require).filter(function(path) {\n    if (!doc.isSelected(path) && !doc.isModified(path)) {\n      return false;\n    }\n    if (path in doc.$__.cachedRequired) {\n      return doc.$__.cachedRequired[path];\n    }\n    return true;\n  });\n\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.init));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.modify));\n  paths = paths.concat(Object.keys(doc.$__.activePaths.states.default));\n\n  if (!doc.ownerDocument) {\n    const subdocs = doc.$__getAllSubdocs();\n    let subdoc;\n    len = subdocs.length;\n    const modifiedPaths = doc.modifiedPaths();\n    for (i = 0; i < len; ++i) {\n      subdoc = subdocs[i];\n      if (doc.isModified(subdoc.$basePath, modifiedPaths) &&\n          !doc.isDirectModified(subdoc.$basePath)) {\n        // Remove child paths for now, because we'll be validating the whole\n        // subdoc\n        paths = paths.filter(function(p) {\n          return p != null && p.indexOf(subdoc.$basePath + '.') !== 0;\n        });\n        paths.push(subdoc.$basePath);\n        skipSchemaValidators[subdoc.$basePath] = true;\n      }\n    }\n  }\n\n  // gh-661: if a whole array is modified, make sure to run validation on all\n  // the children as well\n  len = paths.length;\n  for (i = 0; i < len; ++i) {\n    const path = paths[i];\n\n    const _pathType = doc.schema.path(path);\n    if (!_pathType ||\n        !_pathType.$isMongooseArray ||\n        // To avoid potential performance issues, skip doc arrays whose children\n        // are not required. `getPositionalPathType()` may be slow, so avoid\n        // it unless we have a case of #6364\n        (_pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required'))) {\n      continue;\n    }\n\n    const val = doc.getValue(path);\n    if (val) {\n      const numElements = val.length;\n      for (let j = 0; j < numElements; ++j) {\n        paths.push(path + '.' + j);\n      }\n    }\n  }\n\n  const flattenOptions = { skipArrays: true };\n  len = paths.length;\n  for (i = 0; i < len; ++i) {\n    const pathToCheck = paths[i];\n    if (doc.schema.nested[pathToCheck]) {\n      let _v = doc.getValue(pathToCheck);\n      if (isMongooseObject(_v)) {\n        _v = _v.toObject({ transform: false });\n      }\n      const flat = flatten(_v, '', flattenOptions);\n      const _subpaths = Object.keys(flat).map(function(p) {\n        return pathToCheck + '.' + p;\n      });\n      paths = paths.concat(_subpaths);\n    }\n  }\n\n  len = paths.length;\n  for (i = 0; i < len; ++i) {\n    const path = paths[i];\n    const _pathType = doc.schema.path(path);\n    if (!_pathType || !_pathType.$isSchemaMap) {\n      continue;\n    }\n\n    const val = doc.getValue(path);\n    if (val == null) {\n      continue;\n    }\n    for (const key of val.keys()) {\n      paths.push(path + '.' + key);\n    }\n  }\n\n  return [paths, skipSchemaValidators];\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__validate = function(callback) {\n  const _this = this;\n  const _complete = () => {\n    const err = this.$__.validationError;\n    this.$__.validationError = undefined;\n    this.$__.cachedRequired = {};\n    this.emit('validate', _this);\n    this.constructor.emit('validate', _this);\n    if (err) {\n      for (const key in err.errors) {\n        // Make sure cast errors persist\n        if (!this.__parent && err.errors[key] instanceof MongooseError.CastError) {\n          this.invalidate(key, err.errors[key]);\n        }\n      }\n\n      return err;\n    }\n  };\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  const paths = pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (paths.length === 0) {\n    return process.nextTick(function() {\n      const error = _complete();\n      if (error) {\n        return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n      callback(null, _this);\n    });\n  }\n\n  const validated = {};\n  let total = 0;\n\n  const complete = function() {\n    const error = _complete();\n    if (error) {\n      return _this.schema.s.hooks.execPost('validate:error', _this, [ _this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n    callback(null, _this);\n  };\n\n  const validatePath = function(path) {\n    if (path == null || validated[path]) {\n      return;\n    }\n\n    validated[path] = true;\n    total++;\n\n    process.nextTick(function() {\n      const p = _this.schema.path(path);\n\n      if (!p) {\n        return --total || complete();\n      }\n\n      // If user marked as invalid or there was a cast error, don't validate\n      if (!_this.$isValid(path)) {\n        --total || complete();\n        return;\n      }\n\n      const val = _this.getValue(path);\n      const scope = path in _this.$__.pathsToScopes ?\n        _this.$__.pathsToScopes[path] :\n        _this;\n\n      p.doValidate(val, function(err) {\n        if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n          if (p.$isSingleNested &&\n              err.name === 'ValidationError' &&\n              p.schema.options.storeSubdocValidationError === false) {\n            return --total || complete();\n          }\n          _this.invalidate(path, err, undefined, true);\n        }\n        --total || complete();\n      }, scope, { skipSchemaValidators: skipSchemaValidators[path] });\n    });\n  };\n\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    validatePath(paths[i]);\n  }\n};\n\n/**\n * Executes registered validation rules (skipping asynchronous validators) for this document.\n *\n * ####Note:\n *\n * This method is useful if you need synchronous validation.\n *\n * ####Example:\n *\n *     var err = doc.validateSync();\n *     if ( err ){\n *       handleError( err );\n *     } else {\n *       // validation passed\n *     }\n *\n * @param {Array|string} pathsToValidate only validate the given paths\n * @return {MongooseError|undefined} MongooseError if there are errors during validation, or undefined if there is no error.\n * @api public\n */\n\nDocument.prototype.validateSync = function(pathsToValidate) {\n  const _this = this;\n\n  if (typeof pathsToValidate === 'string') {\n    pathsToValidate = pathsToValidate.split(' ');\n  }\n\n  // only validate required fields when necessary\n  const pathDetails = _getPathsToValidate(this);\n  let paths = pathDetails[0];\n  const skipSchemaValidators = pathDetails[1];\n\n  if (pathsToValidate && pathsToValidate.length) {\n    const tmp = [];\n    for (let i = 0; i < paths.length; ++i) {\n      if (pathsToValidate.indexOf(paths[i]) !== -1) {\n        tmp.push(paths[i]);\n      }\n    }\n    paths = tmp;\n  }\n\n  const validating = {};\n\n  paths.forEach(function(path) {\n    if (validating[path]) {\n      return;\n    }\n\n    validating[path] = true;\n\n    const p = _this.schema.path(path);\n    if (!p) {\n      return;\n    }\n    if (!_this.$isValid(path)) {\n      return;\n    }\n\n    const val = _this.getValue(path);\n    const err = p.doValidateSync(val, _this, {\n      skipSchemaValidators: skipSchemaValidators[path]\n    });\n    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {\n      if (p.$isSingleNested &&\n          err.name === 'ValidationError' &&\n          p.schema.options.storeSubdocValidationError === false) {\n        return;\n      }\n      _this.invalidate(path, err, undefined, true);\n    }\n  });\n\n  const err = _this.$__.validationError;\n  _this.$__.validationError = undefined;\n  _this.emit('validate', _this);\n  _this.constructor.emit('validate', _this);\n\n  if (err) {\n    for (const key in err.errors) {\n      // Make sure cast errors persist\n      if (err.errors[key] instanceof MongooseError.CastError) {\n        _this.invalidate(key, err.errors[key]);\n      }\n    }\n  }\n\n  return err;\n};\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * The `errorMsg` argument will become the message of the `ValidationError`.\n *\n * The `value` argument (if passed) will be available through the `ValidationError.value` property.\n *\n *     doc.invalidate('size', 'must be less than 20', 14);\n\n *     doc.validate(function (err) {\n *       console.log(err)\n *       // prints\n *       { message: 'Validation failed',\n *         name: 'ValidationError',\n *         errors:\n *          { size:\n *             { message: 'must be less than 20',\n *               name: 'ValidatorError',\n *               path: 'size',\n *               type: 'user defined',\n *               value: 14 } } }\n *     })\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} errorMsg the error which states the reason `path` was invalid\n * @param {Object|String|Number|any} value optional invalid value\n * @param {String} [kind] optional `kind` property for the error\n * @return {ValidationError} the current ValidationError, with all currently invalidated paths\n * @api public\n */\n\nDocument.prototype.invalidate = function(path, err, val, kind) {\n  if (!this.$__.validationError) {\n    this.$__.validationError = new ValidationError(this);\n  }\n\n  if (this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  if (!err || typeof err === 'string') {\n    err = new ValidatorError({\n      path: path,\n      message: err,\n      type: kind || 'user defined',\n      value: val\n    });\n  }\n\n  if (this.$__.validationError === err) {\n    return this.$__.validationError;\n  }\n\n  this.$__.validationError.addError(path, err);\n  return this.$__.validationError;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api public\n * @memberOf Document\n * @instance\n * @method $markValid\n */\n\nDocument.prototype.$markValid = function(path) {\n  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {\n    return;\n  }\n\n  delete this.$__.validationError.errors[path];\n  if (Object.keys(this.$__.validationError.errors).length === 0) {\n    this.$__.validationError = null;\n  }\n};\n\n/**\n * Saves this document.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product.save(function (err, product) {\n *       if (err) ..\n *     })\n *\n * The callback will receive two parameters\n *\n * 1. `err` if an error occurred\n * 2. `product` which is the saved `product`\n *\n * As an extra measure of flow control, save will return a Promise.\n * ####Example:\n *     product.save().then(function(product) {\n *        ...\n *     });\n *\n * @param {Object} [options] options optional options\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe)\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Function} [fn] optional callback\n * @method save\n * @memberOf Document\n * @instance\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @method $isValid\n * @memberOf Document\n * @instance\n * @api private\n */\n\nDocument.prototype.$isValid = function(path) {\n  return !this.$__.validationError || !this.$__.validationError.errors[path];\n};\n\n/**\n * Resets the internal modified state of this document.\n *\n * @api private\n * @return {Document}\n * @method $__reset\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__reset = function reset() {\n  let _this = this;\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return _this.getValue(i);\n    })\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    })\n    .forEach(function(array) {\n      let i = array.length;\n      while (i--) {\n        const doc = array[i];\n        if (!doc) {\n          continue;\n        }\n        doc.$__reset();\n      }\n\n      _this.$__.activePaths.init(array._path);\n\n      array._atomics = {};\n    });\n\n  this.$__.activePaths.\n    map('init', 'modify', function(i) {\n      return _this.getValue(i);\n    }).\n    filter(function(val) {\n      return val && val.$isSingleNested;\n    }).\n    forEach(function(doc) {\n      doc.$__reset();\n      _this.$__.activePaths.init(doc.$basePath);\n    });\n\n  // clear atomics\n  this.$__dirty().forEach(function(dirt) {\n    const type = dirt.value;\n\n    if (type && type._atomics) {\n      type._atomics = {};\n    }\n  });\n\n  // Clear 'dirty' cache\n  this.$__.activePaths.clear('modify');\n  this.$__.activePaths.clear('default');\n  this.$__.validationError = undefined;\n  this.errors = undefined;\n  _this = this;\n  this.schema.requiredPaths().forEach(function(path) {\n    _this.$__.activePaths.require(path);\n  });\n\n  return this;\n};\n\n/**\n * Returns this documents dirty paths / vals.\n *\n * @api private\n * @method $__dirty\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__dirty = function() {\n  const _this = this;\n\n  let all = this.$__.activePaths.map('modify', function(path) {\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  });\n\n  // gh-2558: if we had to set a default and the value is not undefined,\n  // we have to save as well\n  all = all.concat(this.$__.activePaths.map('default', function(path) {\n    if (path === '_id' || _this.getValue(path) == null) {\n      return;\n    }\n    return {\n      path: path,\n      value: _this.getValue(path),\n      schema: _this.$__path(path)\n    };\n  }));\n\n  // Sort dirty paths in a flat hierarchy.\n  all.sort(function(a, b) {\n    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));\n  });\n\n  // Ignore \"foo.a\" if \"foo\" is dirty already.\n  const minimal = [];\n  let lastPath;\n  let top;\n\n  all.forEach(function(item) {\n    if (!item) {\n      return;\n    }\n    if (item.path.indexOf(lastPath) !== 0) {\n      lastPath = item.path + '.';\n      minimal.push(item);\n      top = item;\n    } else {\n      // special case for top level MongooseArrays\n      if (top.value && top.value._atomics && top.value.hasAtomics()) {\n        // the `top` array itself and a sub path of `top` are being modified.\n        // the only way to honor all of both modifications is through a $set\n        // of entire array.\n        top.value._atomics = {};\n        top.value._atomics.$set = top.value;\n      }\n    }\n  });\n\n  top = lastPath = null;\n  return minimal;\n};\n\n/**\n * Assigns/compiles `schema` into this documents prototype.\n *\n * @param {Schema} schema\n * @api private\n * @method $__setSchema\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__setSchema = function(schema) {\n  schema.plugin(idGetter, { deduplicate: true });\n  compile(schema.tree, this, undefined, schema.options);\n\n  // Apply default getters if virtual doesn't have any (gh-6262)\n  for (const key of Object.keys(schema.virtuals)) {\n    schema.virtuals[key]._applyDefaultGetters();\n  }\n\n  this.schema = schema;\n};\n\n\n/**\n * Get active path that were changed and are arrays\n *\n * @api private\n * @method $__getArrayPathsToValidate\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getArrayPathsToValidate = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n\n  // validate all document arrays.\n  return this.$__.activePaths\n    .map('init', 'modify', function(i) {\n      return this.getValue(i);\n    }.bind(this))\n    .filter(function(val) {\n      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;\n    }).reduce(function(seed, array) {\n      return seed.concat(array);\n    }, [])\n    .filter(function(doc) {\n      return doc;\n    });\n};\n\n\n/**\n * Get all subdocs (by bfs)\n *\n * @api private\n * @method $__getAllSubdocs\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__getAllSubdocs = function() {\n  DocumentArray || (DocumentArray = require('./types/documentarray'));\n  Embedded = Embedded || require('./types/embedded');\n\n  function docReducer(doc, seed, path) {\n    const val = path ? doc[path] : doc;\n    if (val instanceof Embedded) {\n      seed.push(val);\n    }\n    else if (val instanceof Map) {\n      seed = Array.from(val.keys()).reduce(function(seed, path) {\n        return docReducer(val.get(path), seed, null);\n      }, seed);\n    }\n    else if (val && val.$isSingleNested) {\n      seed = Object.keys(val._doc).reduce(function(seed, path) {\n        return docReducer(val._doc, seed, path);\n      }, seed);\n      seed.push(val);\n    }\n    else if (val && val.isMongooseDocumentArray) {\n      val.forEach(function _docReduce(doc) {\n        if (!doc || !doc._doc) {\n          return;\n        }\n        if (doc instanceof Embedded) {\n          seed.push(doc);\n        }\n        seed = Object.keys(doc._doc).reduce(function(seed, path) {\n          return docReducer(doc._doc, seed, path);\n        }, seed);\n      });\n    } else if (val instanceof Document && val.$__isNested) {\n      if (val) {\n        seed = Object.keys(val).reduce(function(seed, path) {\n          return docReducer(val, seed, path);\n        }, seed);\n      }\n    }\n    return seed;\n  }\n\n  const _this = this;\n  const subDocs = Object.keys(this._doc).reduce(function(seed, path) {\n    return docReducer(_this, seed, path);\n  }, []);\n\n  return subDocs;\n};\n\n/*!\n * Runs queued functions\n */\n\nfunction applyQueue(doc) {\n  const q = doc.schema && doc.schema.callQueue;\n  if (!q.length) {\n    return;\n  }\n  let pair;\n\n  for (let i = 0; i < q.length; ++i) {\n    pair = q[i];\n    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {\n      doc[pair[0]].apply(doc, pair[1]);\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nDocument.prototype.$__handleReject = function handleReject(err) {\n  // emit on the Model if listening\n  if (this.listeners('error').length) {\n    this.emit('error', err);\n  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {\n    this.constructor.emit('error', err);\n  } else if (this.listeners && this.listeners('error').length) {\n    this.emit('error', err);\n  }\n};\n\n/**\n * Internal helper for toObject() and toJSON() that doesn't manipulate options\n *\n * @api private\n * @method $toObject\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$toObject = function(options, json) {\n  let defaultOptions = {\n    transform: true,\n    flattenDecimals: true\n  };\n\n  const path = json ? 'toJSON' : 'toObject';\n  const baseOptions = get(this, 'constructor.base.options.' + path, {});\n  const schemaOptions = get(this, 'schema.options', {});\n  // merge base default options with Schema's set default options if available.\n  // `clone` is necessary here because `utils.options` directly modifies the second input.\n  defaultOptions = utils.options(defaultOptions, clone(baseOptions));\n  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));\n\n  // If options do not exist or is not an object, set it to empty object\n  options = options && utils.getFunctionName(options.constructor) === 'Object' ?\n    clone(options) :\n    {};\n\n  let _minimize;\n  if (options.minimize != null) {\n    _minimize = options.minimize;\n  } else if (defaultOptions.minimize != null) {\n    _minimize = defaultOptions.minimize;\n  } else {\n    _minimize = schemaOptions.minimize;\n  }\n\n  // The original options that will be passed to `clone()`. Important because\n  // `clone()` will recursively call `$toObject()` on embedded docs, so we\n  // need the original options the user passed in, plus `_isNested` and\n  // `_parentOptions` for checking whether we need to depopulate.\n  const cloneOptions = Object.assign(utils.clone(options), {\n    _isNested: true,\n    json: json,\n    minimize: _minimize\n  });\n\n  const depopulate = options.depopulate ||\n    get(options, '_parentOptions.depopulate', false);\n  // _isNested will only be true if this is not the top level document, we\n  // should never depopulate\n  if (depopulate && options._isNested && this.$__.wasPopulated) {\n    // populated paths that we set to a document\n    return clone(this._id, cloneOptions);\n  }\n\n  // merge default options with input options.\n  options = utils.options(defaultOptions, options);\n  options._isNested = true;\n  options.json = json;\n  options.minimize = _minimize;\n\n  cloneOptions._parentOptions = options;\n\n  // remember the root transform function\n  // to save it from being overwritten by sub-transform functions\n  const originalTransform = options.transform;\n\n  let ret = clone(this._doc, cloneOptions) || {};\n\n  if (options.getters) {\n    applyGetters(this, ret, 'paths', cloneOptions);\n    // applyGetters for paths will add nested empty objects;\n    // if minimize is set, we need to remove them.\n    if (options.minimize) {\n      ret = minimize(ret) || {};\n    }\n  }\n\n  if (options.virtuals || options.getters && options.virtuals !== false) {\n    applyGetters(this, ret, 'virtuals', cloneOptions);\n  }\n\n  if (options.versionKey === false && this.schema.options.versionKey) {\n    delete ret[this.schema.options.versionKey];\n  }\n\n  let transform = options.transform;\n\n  // In the case where a subdocument has its own transform function, we need to\n  // check and see if the parent has a transform (options.transform) and if the\n  // child schema has a transform (this.schema.options.toObject) In this case,\n  // we need to adjust options.transform to be the child schema's transform and\n  // not the parent schema's\n  if (transform === true || (schemaOptions.toObject && transform)) {\n    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;\n\n    if (opts) {\n      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);\n    }\n  } else {\n    options.transform = originalTransform;\n  }\n\n  if (typeof transform === 'function') {\n    const xformed = transform(this, ret, options);\n    if (typeof xformed !== 'undefined') {\n      ret = xformed;\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Converts this document into a plain javascript object, ready for storage in MongoDB.\n *\n * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.\n *\n * ####Options:\n *\n * - `getters` apply all getters (path and virtual getters), defaults to false\n * - `virtuals` apply virtual getters (can override `getters` option), defaults to false\n * - `minimize` remove empty objects (defaults to true)\n * - `transform` a transform function to apply to the resulting document before returning\n * - `depopulate` depopulate any populated paths, replacing them with their original refs (defaults to false)\n * - `versionKey` whether to include the version key (defaults to true)\n *\n * ####Getters/Virtuals\n *\n * Example of only applying path getters\n *\n *     doc.toObject({ getters: true, virtuals: false })\n *\n * Example of only applying virtual getters\n *\n *     doc.toObject({ virtuals: true })\n *\n * Example of applying both path and virtual getters\n *\n *     doc.toObject({ getters: true })\n *\n * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.\n *\n *     schema.set('toObject', { virtuals: true })\n *\n * ####Transform\n *\n * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.\n *\n * Transform functions receive three arguments\n *\n *     function (doc, ret, options) {}\n *\n * - `doc` The mongoose document which is being converted\n * - `ret` The plain object representation which has been converted\n * - `options` The options in use (either schema options or the options passed inline)\n *\n * ####Example\n *\n *     // specify the transform schema option\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       // remove the _id of every document before returning the result\n *       delete ret._id;\n *       return ret;\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { name: 'Wreck-it Ralph' }\n *\n * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       return { movie: ret.name }\n *     }\n *\n *     // without the transformation in the schema\n *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }\n *\n *     // with the transformation\n *     doc.toObject(); // { movie: 'Wreck-it Ralph' }\n *\n * _Note: if a transform function returns `undefined`, the return value will be ignored._\n *\n * Transformations may also be applied inline, overridding any transform set in the options:\n *\n *     function xform (doc, ret, options) {\n *       return { inline: ret.name, custom: true }\n *     }\n *\n *     // pass the transform as an inline option\n *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }\n *\n * If you want to skip transformations, use `transform: false`:\n *\n *     if (!schema.options.toObject) schema.options.toObject = {};\n *     schema.options.toObject.hide = '_id';\n *     schema.options.toObject.transform = function (doc, ret, options) {\n *       if (options.hide) {\n *         options.hide.split(' ').forEach(function (prop) {\n *           delete ret[prop];\n *         });\n *       }\n *       return ret;\n *     }\n *\n *     var doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });\n *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }\n *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }\n *\n * Transforms are applied _only to the document and are not applied to sub-documents_.\n *\n * Transforms, like all of these options, are also available for `toJSON`.\n *\n * See [schema options](/docs/guide.html#toObject) for some more details.\n *\n * _During save, no custom options are applied to the document before being sent to the database._\n *\n * @param {Object} [options]\n * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals\n * @param {Boolean} [options.virtuals=false] if true, apply virtuals. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals\n * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output\n * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object\n * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.\n * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output\n * @return {Object} js object\n * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toObject = function(options) {\n  return this.$toObject(options);\n};\n\n/*!\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object}\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (utils.isObject(val) && !Buffer.isBuffer(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n\n/*!\n * Applies virtuals properties to `json`.\n *\n * @param {Document} self\n * @param {Object} json\n * @param {String} type either `virtuals` or `paths`\n * @return {Object} `json`\n */\n\nfunction applyGetters(self, json, type, options) {\n  const schema = self.schema;\n  const paths = Object.keys(schema[type]);\n  let i = paths.length;\n  const numPaths = i;\n  let path;\n  let assignPath;\n  let cur = self._doc;\n  let v;\n\n  if (!cur) {\n    return json;\n  }\n\n  if (type === 'virtuals') {\n    options = options || {};\n    for (i = 0; i < numPaths; ++i) {\n      path = paths[i];\n      // We may be applying virtuals to a nested object, for example if calling\n      // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,\n      // will be a trailing substring of the `path`.\n      assignPath = path;\n      if (options.path != null) {\n        if (!path.startsWith(options.path + '.')) {\n          continue;\n        }\n        assignPath = path.substr(options.path.length + 1);\n      }\n      const parts = assignPath.split('.');\n      v = clone(self.get(path), options);\n      if (v === void 0) {\n        continue;\n      }\n      const plen = parts.length;\n      cur = json;\n      for (let j = 0; j < plen - 1; ++j) {\n        cur[parts[j]] = cur[parts[j]] || {};\n        cur = cur[parts[j]];\n      }\n      cur[parts[plen - 1]] = v;\n    }\n\n    return json;\n  }\n\n  while (i--) {\n    path = paths[i];\n\n    const parts = path.split('.');\n    const plen = parts.length;\n    const last = plen - 1;\n    let branch = json;\n    let part;\n    cur = self._doc;\n\n    for (let ii = 0; ii < plen; ++ii) {\n      part = parts[ii];\n      v = cur[part];\n      if (ii === last) {\n        branch[part] = clone(self.get(path), options);\n      } else if (v == null) {\n        if (part in cur) {\n          branch[part] = v;\n        }\n        break;\n      } else {\n        branch = branch[part] || (branch[part] = {});\n      }\n      cur = v;\n    }\n  }\n\n  return json;\n}\n\n/**\n * The return value of this method is used in calls to JSON.stringify(doc).\n *\n * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.\n *\n *     schema.set('toJSON', { virtuals: true })\n *\n * See [schema options](/docs/guide.html#toJSON) for details.\n *\n * @param {Object} options\n * @return {Object}\n * @see Document#toObject #document_Document-toObject\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toJSON = function(options) {\n  return this.$toObject(options, true);\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method inspect\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.inspect = function(options) {\n  const isPOJO = options &&\n    utils.getFunctionName(options.constructor) === 'Object';\n  let opts;\n  if (isPOJO) {\n    opts = options;\n    opts.minimize = false;\n  }\n  return this.toObject(opts);\n};\n\nif (inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  Document.prototype[inspect.custom] = Document.prototype.inspect;\n}\n\n/**\n * Helper for console.log\n *\n * @api public\n * @method toString\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.toString = function() {\n  return inspect(this.inspect());\n};\n\n/**\n * Returns true if the Document stores the same data as doc.\n *\n * Documents are considered equal when they have matching `_id`s, unless neither\n * document has an `_id`, in which case this function falls back to using\n * `deepEqual()`.\n *\n * @param {Document} doc a document to compare\n * @return {Boolean}\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.equals = function(doc) {\n  if (!doc) {\n    return false;\n  }\n\n  const tid = this.get('_id');\n  const docid = doc.get ? doc.get('_id') : doc;\n  if (!tid && !docid) {\n    return deepEqual(this, doc);\n  }\n  return tid && tid.equals\n    ? tid.equals(docid)\n    : tid === docid;\n};\n\n/**\n * Populates document references, executing the `callback` when complete.\n * If you want to use promises instead, use this function with\n * [`execPopulate()`](#document_Document-execPopulate)\n *\n * ####Example:\n *\n *     doc\n *     .populate('company')\n *     .populate({\n *       path: 'notes',\n *       match: /airline/,\n *       select: 'text',\n *       model: 'modelName'\n *       options: opts\n *     }, function (err, user) {\n *       assert(doc._id === user._id) // the document itself is passed\n *     })\n *\n *     // summary\n *     doc.populate(path)                   // not executed\n *     doc.populate(options);               // not executed\n *     doc.populate(path, callback)         // executed\n *     doc.populate(options, callback);     // executed\n *     doc.populate(callback);              // executed\n *     doc.populate(options).execPopulate() // executed, returns promise\n *\n *\n * ####NOTE:\n *\n * Population does not occur unless a `callback` is passed *or* you explicitly\n * call `execPopulate()`.\n * Passing the same path a second time will overwrite the previous path options.\n * See [Model.populate()](#model_Model.populate) for explaination of options.\n *\n * @see Model.populate #model_Model.populate\n * @see Document.execPopulate #document_Document-execPopulate\n * @param {String|Object} [path] The path to populate or an options object\n * @param {Function} [callback] When passed, population is invoked\n * @api public\n * @return {Document} this\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.populate = function populate() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  const pop = this.$__.populate || (this.$__.populate = {});\n  const args = utils.args(arguments);\n  let fn;\n\n  if (typeof args[args.length - 1] === 'function') {\n    fn = args.pop();\n  }\n\n  // allow `doc.populate(callback)`\n  if (args.length) {\n    // use hash to remove duplicate paths\n    const res = utils.populate.apply(null, args);\n    for (let i = 0; i < res.length; ++i) {\n      pop[res[i].path] = res[i];\n    }\n  }\n\n  if (fn) {\n    const paths = utils.object.vals(pop);\n    this.$__.populate = undefined;\n    let topLevelModel = this.constructor;\n    if (this.$__isNested) {\n      topLevelModel = this.$__.scope.constructor;\n      const nestedPath = this.$__.nestedPath;\n      paths.forEach(function(populateOptions) {\n        populateOptions.path = nestedPath + '.' + populateOptions.path;\n      });\n    }\n\n    // Use `$session()` by default if the document has an associated session\n    // See gh-6754\n    if (this.$session() != null) {\n      const session = this.$session();\n      paths.forEach(path => {\n        if (path.options == null) {\n          path.options = { session: session };\n          return;\n        }\n        if (!('session' in path.options)) {\n          path.options.session = session;\n        }\n      });\n    }\n\n    topLevelModel.populate(this, paths, fn);\n  }\n\n  return this;\n};\n\n/**\n * Explicitly executes population and returns a promise. Useful for ES2015\n * integration.\n *\n * ####Example:\n *\n *     var promise = doc.\n *       populate('company').\n *       populate({\n *         path: 'notes',\n *         match: /airline/,\n *         select: 'text',\n *         model: 'modelName'\n *         options: opts\n *       }).\n *       execPopulate();\n *\n *     // summary\n *     doc.execPopulate().then(resolve, reject);\n *\n *\n * @see Document.populate #document_Document-populate\n * @api public\n * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned\n * @return {Promise} promise that resolves to the document when population is done\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.execPopulate = function(callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    this.populate(cb);\n  });\n};\n\n/**\n * Gets _id(s) used during population of the given `path`.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name)         // Dr.Seuss\n *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, undefined is returned.\n *\n * @param {String} path\n * @return {Array|ObjectId|Number|Buffer|String|undefined}\n * @memberOf Document\n * @instance\n * @api public\n */\n\nDocument.prototype.populated = function(path, val, options) {\n  // val and options are internal\n  if (val === null || val === void 0) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    const v = this.$__.populated[path];\n    if (v) {\n      return v.value;\n    }\n    return undefined;\n  }\n\n  // internal\n\n  if (val === true) {\n    if (!this.$__.populated) {\n      return undefined;\n    }\n    return this.$__.populated[path];\n  }\n\n  this.$__.populated || (this.$__.populated = {});\n  this.$__.populated[path] = {value: val, options: options};\n  return val;\n};\n\n/**\n * Takes a populated field and returns it to its unpopulated state.\n *\n * ####Example:\n *\n *     Model.findOne().populate('author').exec(function (err, doc) {\n *       console.log(doc.author.name); // Dr.Seuss\n *       console.log(doc.depopulate('author'));\n *       console.log(doc.author); // '5144cf8050f071d979c118a7'\n *     })\n *\n * If the path was not populated, this is a no-op.\n *\n * @param {String} path\n * @return {Document} this\n * @see Document.populate #document_Document-populate\n * @api public\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.depopulate = function(path) {\n  if (typeof path === 'string') {\n    path = path.split(' ');\n  }\n  let i;\n  let populatedIds;\n  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];\n\n  if (arguments.length === 0) {\n    // Depopulate all\n    const keys = this.$__.populated ? Object.keys(this.$__.populated) : [];\n\n    for (i = 0; i < virtualKeys.length; i++) {\n      delete this.$$populatedVirtuals[virtualKeys[i]];\n      delete this._doc[virtualKeys[i]];\n    }\n\n    for (i = 0; i < keys.length; i++) {\n      populatedIds = this.populated(keys[i]);\n      if (!populatedIds) {\n        continue;\n      }\n      delete this.$__.populated[keys[i]];\n      this.$set(keys[i], populatedIds);\n    }\n    return this;\n  }\n\n  for (i = 0; i < path.length; i++) {\n    populatedIds = this.populated(path[i]);\n    if (!populatedIds) {\n      if (virtualKeys.indexOf(path[i]) === -1) {\n        continue;\n      } else {\n        delete this.$$populatedVirtuals[path[i]];\n        delete this._doc[path[i]];\n        continue;\n      }\n    }\n    delete this.$__.populated[path[i]];\n    this.$set(path[i], populatedIds);\n  }\n  return this;\n};\n\n\n/**\n * Returns the full path to this document.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf Document\n * @instance\n */\n\nDocument.prototype.$__fullPath = function(path) {\n  // overridden in SubDocuments\n  return path || '';\n};\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = require('./error');\nconst $exists = require('./schema/operators/exists');\nconst $type = require('./schema/operators/type');\nconst get = require('lodash.get');\nconst immediate = require('./helpers/immediate');\nconst utils = require('./utils');\nconst validatorErrorSymbol = require('./helpers/symbols').validatorErrorSymbol;\n\nconst CastError = MongooseError.CastError;\nconst ValidatorError = MongooseError.ValidatorError;\n\n/**\n * SchemaType constructor. Do **not** instantiate `SchemaType` directly.\n * Mongoose converts your schema paths into SchemaTypes automatically.\n *\n * ####Example:\n *\n *     const schema = new Schema({ name: String });\n *     schema.path('name') instanceof SchemaType; // true\n *\n * @param {String} path\n * @param {Object} [options]\n * @param {String} [instance]\n * @api public\n */\n\nfunction SchemaType(path, options, instance) {\n  this.path = path;\n  this.instance = instance;\n  this.validators = [];\n  this.setters = [];\n  this.getters = [];\n  this.options = options;\n  this._index = null;\n  this.selected;\n\n  for (const prop in options) {\n    if (this[prop] && typeof this[prop] === 'function') {\n      // { unique: true, index: true }\n      if (prop === 'index' && this._index) {\n        continue;\n      }\n\n      const val = options[prop];\n      // Special case so we don't screw up array defaults, see gh-5780\n      if (prop === 'default') {\n        this.default(val);\n        continue;\n      }\n\n      const opts = Array.isArray(val) ? val : [val];\n\n      this[prop].apply(this, opts);\n    }\n  }\n\n  Object.defineProperty(this, '$$context', {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value: null\n  });\n}\n\n/**\n * Sets a default value for this SchemaType.\n *\n * ####Example:\n *\n *     var schema = new Schema({ n: { type: Number, default: 10 })\n *     var M = db.model('M', schema)\n *     var m = new M;\n *     console.log(m.n) // 10\n *\n * Defaults can be either `functions` which return the value to use as the default or the literal value itself. Either way, the value will be cast based on its schema type before being set during document creation.\n *\n * ####Example:\n *\n *     // values are cast:\n *     var schema = new Schema({ aNumber: { type: Number, default: 4.815162342 }})\n *     var M = db.model('M', schema)\n *     var m = new M;\n *     console.log(m.aNumber) // 4.815162342\n *\n *     // default unique objects for Mixed types:\n *     var schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default(function () {\n *       return {};\n *     });\n *\n *     // if we don't use a function to return object literals for Mixed defaults,\n *     // each document will receive a reference to the same object literal creating\n *     // a \"shared\" object instance:\n *     var schema = new Schema({ mixed: Schema.Types.Mixed });\n *     schema.path('mixed').default({});\n *     var M = db.model('M', schema);\n *     var m1 = new M;\n *     m1.mixed.added = 1;\n *     console.log(m1.mixed); // { added: 1 }\n *     var m2 = new M;\n *     console.log(m2.mixed); // { added: 1 }\n *\n * @param {Function|any} val the default value\n * @return {defaultValue}\n * @api public\n */\n\nSchemaType.prototype.default = function(val) {\n  if (arguments.length === 1) {\n    if (val === void 0) {\n      this.defaultValue = void 0;\n      return void 0;\n    }\n    this.defaultValue = val;\n    return this.defaultValue;\n  } else if (arguments.length > 1) {\n    this.defaultValue = utils.args(arguments);\n  }\n  return this.defaultValue;\n};\n\n/**\n * Declares the index options for this schematype.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, index: true })\n *     var s = new Schema({ loc: { type: [Number], index: 'hashed' })\n *     var s = new Schema({ loc: { type: [Number], index: '2d', sparse: true })\n *     var s = new Schema({ loc: { type: [Number], index: { type: '2dsphere', sparse: true }})\n *     var s = new Schema({ date: { type: Date, index: { unique: true, expires: '1d' }})\n *     Schema.path('my.path').index(true);\n *     Schema.path('my.date').index({ expires: 60 });\n *     Schema.path('my.path').index({ unique: true, sparse: true });\n *\n * ####NOTE:\n *\n * _Indexes are created [in the background](https://docs.mongodb.com/manual/core/index-creation/#index-creation-background)\n * by default. If `background` is set to `false`, MongoDB will not execute any\n * read/write operations you send until the index build.\n * Specify `background: false` to override Mongoose's default._\n *\n * @param {Object|Boolean|String} options\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.index = function(options) {\n  this._index = options;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Declares an unique index.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, unique: true }});\n *     Schema.path('name').index({ unique: true });\n *\n * _NOTE: violating the constraint returns an `E11000` error from MongoDB when saving, not a Mongoose validation error._\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.unique = function(bool) {\n  if (this._index === false) {\n    if (!bool) {\n      return;\n    }\n    throw new Error('Path \"' + this.path + '\" may not have `index` set to ' +\n      'false and `unique` set to true');\n  }\n  if (this._index == null || this._index === true) {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = {type: this._index};\n  }\n\n  this._index.unique = bool;\n  return this;\n};\n\n/**\n * Declares a full text index.\n *\n * ###Example:\n *\n *      var s = new Schema({name : {type: String, text : true })\n *      Schema.path('name').index({text : true});\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.text = function(bool) {\n  if (this._index === null || this._index === undefined ||\n    typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = {type: this._index};\n  }\n\n  this._index.text = bool;\n  return this;\n};\n\n/**\n * Declares a sparse index.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, sparse: true })\n *     Schema.path('name').index({ sparse: true });\n *\n * @param {Boolean} bool\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.sparse = function(bool) {\n  if (this._index === null || this._index === undefined ||\n    typeof this._index === 'boolean') {\n    this._index = {};\n  } else if (typeof this._index === 'string') {\n    this._index = {type: this._index};\n  }\n\n  this._index.sparse = bool;\n  return this;\n};\n\n/**\n * Adds a setter to this schematype.\n *\n * ####Example:\n *\n *     function capitalize (val) {\n *       if (typeof val !== 'string') val = '';\n *       return val.charAt(0).toUpperCase() + val.substring(1);\n *     }\n *\n *     // defining within the schema\n *     var s = new Schema({ name: { type: String, set: capitalize }});\n *\n *     // or with the SchemaType\n *     var s = new Schema({ name: String })\n *     s.path('name').set(capitalize);\n *\n * Setters allow you to transform the data before it gets to the raw mongodb\n * document or query.\n *\n * Suppose you are implementing user registration for a website. Users provide\n * an email and password, which gets saved to mongodb. The email is a string\n * that you will want to normalize to lower case, in order to avoid one email\n * having more than one account -- e.g., otherwise, avenue@q.com can be registered for 2 accounts via avenue@q.com and AvEnUe@Q.CoM.\n *\n * You can set up email lower case normalization easily via a Mongoose setter.\n *\n *     function toLower(v) {\n *       return v.toLowerCase();\n *     }\n *\n *     var UserSchema = new Schema({\n *       email: { type: String, set: toLower }\n *     });\n *\n *     var User = db.model('User', UserSchema);\n *\n *     var user = new User({email: 'AVENUE@Q.COM'});\n *     console.log(user.email); // 'avenue@q.com'\n *\n *     // or\n *     var user = new User();\n *     user.email = 'Avenue@Q.com';\n *     console.log(user.email); // 'avenue@q.com'\n *     User.updateOne({ _id: _id }, { $set: { email: 'AVENUE@Q.COM' } }); // update to 'avenue@q.com'\n *\n * As you can see above, setters allow you to transform the data before it\n * stored in MongoDB, or before executing a query.\n *\n * _NOTE: we could have also just used the built-in `lowercase: true` SchemaType option instead of defining our own function._\n *\n *     new Schema({ email: { type: String, lowercase: true }})\n *\n * Setters are also passed a second argument, the schematype on which the setter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return val;\n *       }\n *     }\n *\n *     var VirusSchema = new Schema({\n *       name: { type: String, required: true, set: inspector },\n *       taxonomy: { type: String, set: inspector }\n *     })\n *\n *     var Virus = db.model('Virus', VirusSchema);\n *     var v = new Virus({ name: 'Parvoviridae', taxonomy: 'Parvovirinae' });\n *\n *     console.log(v.name);     // name is required\n *     console.log(v.taxonomy); // Parvovirinae\n *\n * You can also use setters to modify other properties on the document. If\n * you're setting a property `name` on a document, the setter will run with\n * `this` as the document. Be careful, in mongoose 5 setters will also run\n * when querying by `name` with `this` as the query.\n *\n * ```javascript\n * const nameSchema = new Schema({ name: String, keywords: [String] });\n * nameSchema.path('name').set(function(v) {\n *   // Need to check if `this` is a document, because in mongoose 5\n *   // setters will also run on queries, in which case `this` will be a\n *   // mongoose query object.\n *   if (this instanceof Document && v != null) {\n *     this.keywords = v.split(' ');\n *   }\n *   return v;\n * });\n * ```\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.set = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A setter must be a function.');\n  }\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Adds a getter to this schematype.\n *\n * ####Example:\n *\n *     function dob (val) {\n *       if (!val) return val;\n *       return (val.getMonth() + 1) + \"/\" + val.getDate() + \"/\" + val.getFullYear();\n *     }\n *\n *     // defining within the schema\n *     var s = new Schema({ born: { type: Date, get: dob })\n *\n *     // or by retreiving its SchemaType\n *     var s = new Schema({ born: Date })\n *     s.path('born').get(dob)\n *\n * Getters allow you to transform the representation of the data as it travels from the raw mongodb document to the value that you see.\n *\n * Suppose you are storing credit card numbers and you want to hide everything except the last 4 digits to the mongoose user. You can do so by defining a getter in the following way:\n *\n *     function obfuscate (cc) {\n *       return '****-****-****-' + cc.slice(cc.length-4, cc.length);\n *     }\n *\n *     var AccountSchema = new Schema({\n *       creditCardNumber: { type: String, get: obfuscate }\n *     });\n *\n *     var Account = db.model('Account', AccountSchema);\n *\n *     Account.findById(id, function (err, found) {\n *       console.log(found.creditCardNumber); // '****-****-****-1234'\n *     });\n *\n * Getters are also passed a second argument, the schematype on which the getter was defined. This allows for tailored behavior based on options passed in the schema.\n *\n *     function inspector (val, schematype) {\n *       if (schematype.options.required) {\n *         return schematype.path + ' is required';\n *       } else {\n *         return schematype.path + ' is not';\n *       }\n *     }\n *\n *     var VirusSchema = new Schema({\n *       name: { type: String, required: true, get: inspector },\n *       taxonomy: { type: String, get: inspector }\n *     })\n *\n *     var Virus = db.model('Virus', VirusSchema);\n *\n *     Virus.findById(id, function (err, virus) {\n *       console.log(virus.name);     // name is required\n *       console.log(virus.taxonomy); // taxonomy is not\n *     })\n *\n * @param {Function} fn\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.get = function(fn) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('A getter must be a function.');\n  }\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Adds validator(s) for this document path.\n *\n * Validators always receive the value to validate as their first argument and\n * must return `Boolean`. Returning `false` or throwing an error means\n * validation failed.\n *\n * The error message argument is optional. If not passed, the [default generic error message template](#error_messages_MongooseError-messages) will be used.\n *\n * ####Examples:\n *\n *     // make sure every value is equal to \"something\"\n *     function validator (val) {\n *       return val == 'something';\n *     }\n *     new Schema({ name: { type: String, validate: validator }});\n *\n *     // with a custom error message\n *\n *     var custom = [validator, 'Uh oh, {PATH} does not equal \"something\".']\n *     new Schema({ name: { type: String, validate: custom }});\n *\n *     // adding many validators at a time\n *\n *     var many = [\n *         { validator: validator, msg: 'uh oh' }\n *       , { validator: anotherValidator, msg: 'failed' }\n *     ]\n *     new Schema({ name: { type: String, validate: many }});\n *\n *     // or utilizing SchemaType methods directly:\n *\n *     var schema = new Schema({ name: 'string' });\n *     schema.path('name').validate(validator, 'validation of `{PATH}` failed with value `{VALUE}`');\n *\n * ####Error message templates:\n *\n * From the examples above, you may have noticed that error messages support\n * basic templating. There are a few other template keywords besides `{PATH}`\n * and `{VALUE}` too. To find out more, details are available\n * [here](#error_messages_MongooseError.messages).\n *\n * If Mongoose's built-in error message templating isn't enough, Mongoose\n * supports setting the `message` property to a function.\n *\n *     schema.path('name').validate({\n *       validator: function() { return v.length > 5; },\n *       // `errors['name']` will be \"name must have length 5, got 'foo'\"\n *       message: function(props) {\n *         return `${props.path} must have length 5, got '${props.value}'`;\n *       }\n *     });\n *\n * To bypass Mongoose's error messages and just copy the error message that\n * the validator throws, do this:\n *\n *     schema.path('name').validate({\n *       validator: function() { throw new Error('Oops!'); },\n *       // `errors['name']` will be \"Oops!\"\n *       message: function(props) { return props.reason.message; }\n *     });\n *\n * ####Asynchronous validation:\n *\n * Mongoose supports validators that return a promise. A validator that returns\n * a promise is called an _async validator_. Async validators run in\n * parallel, and `validate()` will wait until all async validators have settled.\n *\n *     schema.path('name').validate({\n *       validator: function (value) {\n *         return new Promise(function (resolve, reject) {\n *           resolve(false); // validation failed\n *         });\n *       }\n *     });\n *\n * You might use asynchronous validators to retreive other documents from the database to validate against or to meet other I/O bound validation needs.\n *\n * Validation occurs `pre('save')` or whenever you manually execute [document#validate](#document_Document-validate).\n *\n * If validation fails during `pre('save')` and no callback was passed to receive the error, an `error` event will be emitted on your Models associated db [connection](#connection_Connection), passing the validation error object along.\n *\n *     var conn = mongoose.createConnection(..);\n *     conn.on('error', handleError);\n *\n *     var Product = conn.model('Product', yourSchema);\n *     var dvd = new Product(..);\n *     dvd.save(); // emits error on the `conn` above\n *\n * If you want to handle these errors at the Model level, add an `error`\n * listener to your Model as shown below.\n *\n *     // registering an error listener on the Model lets us handle errors more locally\n *     Product.on('error', handleError);\n *\n * @param {RegExp|Function|Object} obj validator function, or hash describing options\n * @param {Function} [obj.validator] validator function. If the validator function returns `undefined` or a truthy value, validation succeeds. If it returns falsy (except `undefined`) or throws an error, validation fails.\n * @param {String|Function} [obj.message] optional error message. If function, should return the error message as a string\n * @param {Boolean} [obj.propsParameter=false] If true, Mongoose will pass the validator properties object (with the `validator` function, `message`, etc.) as the 2nd arg to the validator function. This is disabled by default because many validators [rely on positional args](https://github.com/chriso/validator.js#validators), so turning this on may cause unpredictable behavior in external validators.\n * @param {String|Function} [errorMsg] optional error message. If function, should return the error message as a string\n * @param {String} [type] optional validator type\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.validate = function(obj, message, type) {\n  if (typeof obj === 'function' || obj && utils.getFunctionName(obj.constructor) === 'RegExp') {\n    let properties;\n    if (message instanceof Object && !type) {\n      properties = utils.clone(message);\n      if (!properties.message) {\n        properties.message = properties.msg;\n      }\n      properties.validator = obj;\n      properties.type = properties.type || 'user defined';\n    } else {\n      if (!message) {\n        message = MongooseError.messages.general.default;\n      }\n      if (!type) {\n        type = 'user defined';\n      }\n      properties = {message: message, type: type, validator: obj};\n    }\n    this.validators.push(properties);\n    return this;\n  }\n\n  let i;\n  let length;\n  let arg;\n\n  for (i = 0, length = arguments.length; i < length; i++) {\n    arg = arguments[i];\n    if (!(arg && utils.getFunctionName(arg.constructor) === 'Object')) {\n      const msg = 'Invalid validator. Received (' + typeof arg + ') '\n          + arg\n          + '. See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate';\n\n      throw new Error(msg);\n    }\n    this.validate(arg.validator, arg);\n  }\n\n  return this;\n};\n\n/**\n * Adds a required validator to this SchemaType. The validator gets added\n * to the front of this SchemaType's validators array using `unshift()`.\n *\n * ####Example:\n *\n *     var s = new Schema({ born: { type: Date, required: true })\n *\n *     // or with custom error message\n *\n *     var s = new Schema({ born: { type: Date, required: '{PATH} is required!' })\n *\n *     // or with a function\n *\n *     var s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: function() { return this.userId != null; }\n *       }\n *     })\n *\n *     // or with a function and a custom message\n *     var s = new Schema({\n *       userId: ObjectId,\n *       username: {\n *         type: String,\n *         required: [\n *           function() { return this.userId != null; },\n *           'username is required if id is specified'\n *         ]\n *       }\n *     })\n *\n *     // or through the path API\n *\n *     Schema.path('name').required(true);\n *\n *     // with custom error messaging\n *\n *     Schema.path('name').required(true, 'grrr :( ');\n *\n *     // or make a path conditionally required based on a function\n *     var isOver18 = function() { return this.age >= 18; };\n *     Schema.path('voterRegistrationId').required(isOver18);\n *\n * The required validator uses the SchemaType's `checkRequired` function to\n * determine whether a given value satisfies the required validator. By default,\n * a value satisfies the required validator if `val != null` (that is, if\n * the value is not null nor undefined). However, most built-in mongoose schema\n * types override the default `checkRequired` function:\n *\n * @param {Boolean|Function|Object} required enable/disable the validator, or function that returns required boolean, or options object\n * @param {Boolean|Function} [options.isRequired] enable/disable the validator, or function that returns required boolean\n * @param {Function} [options.ErrorConstructor] custom error constructor. The constructor receives 1 parameter, an object containing the validator properties.\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @see SchemaArray#checkRequired #schema_array_SchemaArray.checkRequired\n * @see SchemaBoolean#checkRequired #schema_boolean_SchemaBoolean-checkRequired\n * @see SchemaBuffer#checkRequired #schema_buffer_SchemaBuffer.schemaName\n * @see SchemaNumber#checkRequired #schema_number_SchemaNumber-min\n * @see SchemaObjectId#checkRequired #schema_objectid_ObjectId-auto\n * @see SchemaString#checkRequired #schema_string_SchemaString-checkRequired\n * @api public\n */\n\nSchemaType.prototype.required = function(required, message) {\n  let customOptions = {};\n  if (typeof required === 'object') {\n    customOptions = required;\n    message = customOptions.message || message;\n    required = required.isRequired;\n  }\n\n  if (required === false) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.requiredValidator;\n    }, this);\n\n    this.isRequired = false;\n    delete this.originalRequiredValue;\n    return this;\n  }\n\n  const _this = this;\n  this.isRequired = true;\n\n  this.requiredValidator = function(v) {\n    const cachedRequired = get(this, '$__.cachedRequired');\n\n    // no validation when this path wasn't selected in the query.\n    if (cachedRequired != null && !this.isSelected(_this.path) && !this.isModified(_this.path)) {\n      return true;\n    }\n\n    // `$cachedRequired` gets set in `_evaluateRequiredFunctions()` so we\n    // don't call required functions multiple times in one validate call\n    // See gh-6801\n    if (cachedRequired != null && _this.path in cachedRequired) {\n      const res = cachedRequired[_this.path] ?\n        _this.checkRequired(v, this) :\n        true;\n      delete cachedRequired[_this.path];\n      return res;\n    } else if (typeof required === 'function') {\n      return required.apply(this) ? _this.checkRequired(v, this) : true;\n    }\n\n    return _this.checkRequired(v, this);\n  };\n  this.originalRequiredValue = required;\n\n  if (typeof required === 'string') {\n    message = required;\n    required = undefined;\n  }\n\n  const msg = message || MongooseError.messages.general.required;\n  this.validators.unshift(Object.assign({}, customOptions, {\n    validator: this.requiredValidator,\n    message: msg,\n    type: 'required'\n  }));\n\n  return this;\n};\n\n/**\n * Set the model that this path refers to. This is the option that [populate](https://mongoosejs.com/docs/populate.html)\n * looks at to determine the foreign collection it should query.\n *\n * ####Example:\n *     const userSchema = new Schema({ name: String });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const postSchema = new Schema({ user: mongoose.ObjectId });\n *     postSchema.path('user').ref('User'); // By model name\n *     postSchema.path('user').ref(User); // Can pass the model as well\n *\n *     // Or you can just declare the `ref` inline in your schema\n *     const postSchema2 = new Schema({\n *       user: { type: mongoose.ObjectId, ref: User }\n *     });\n *\n * @param {String|Model|Function} ref either a model name, a [Model](https://mongoosejs.com/docs/models.html), or a function that returns a model name or model.\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.ref = function(ref) {\n  this.options.ref = ref;\n  return this;\n};\n\n/**\n * Gets the default value\n *\n * @param {Object} scope the scope which callback are executed\n * @param {Boolean} init\n * @api private\n */\n\nSchemaType.prototype.getDefault = function(scope, init) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret !== null && ret !== undefined) {\n    if (typeof ret === 'object' && (!this.options || !this.options.shared)) {\n      ret = utils.clone(ret);\n    }\n\n    const casted = this.cast(ret, scope, init);\n    if (casted && casted.$isSingleNested) {\n      casted.$parent = scope;\n    }\n    return casted;\n  }\n  return ret;\n};\n\n/*!\n * Applies setters without casting\n *\n * @api private\n */\n\nSchemaType.prototype._applySetters = function(value, scope, init, priorVal) {\n  let v = value;\n  const setters = this.setters;\n  let len = setters.length;\n  const caster = this.caster;\n\n  while (len--) {\n    v = setters[len].call(scope, v, this);\n  }\n\n  if (Array.isArray(v) && caster && caster.setters) {\n    const newVal = [];\n    for (let i = 0; i < v.length; i++) {\n      newVal.push(caster.applySetters(v[i], scope, init, priorVal));\n    }\n    v = newVal;\n  }\n\n  return v;\n};\n\n/**\n * Applies setters\n *\n * @param {Object} value\n * @param {Object} scope\n * @param {Boolean} init\n * @api private\n */\n\nSchemaType.prototype.applySetters = function(value, scope, init, priorVal, options) {\n  let v = this._applySetters(value, scope, init, priorVal, options);\n\n  if (v == null) {\n    return v;\n  }\n\n  // do not cast until all setters are applied #665\n  v = this.cast(v, scope, init, priorVal, options);\n\n  return v;\n};\n\n/**\n * Applies getters to a value\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaType.prototype.applyGetters = function(value, scope) {\n  let v = value;\n  const getters = this.getters;\n  const len = getters.length;\n\n  if (len === 0) {\n    return v;\n  }\n\n  for (let i = 0; i < len; ++i) {\n    v = getters[i].call(scope, v, this);\n  }\n\n  return v;\n};\n\n/**\n * Sets default `select()` behavior for this path.\n *\n * Set to `true` if this path should always be included in the results, `false` if it should be excluded by default. This setting can be overridden at the query level.\n *\n * ####Example:\n *\n *     T = db.model('T', new Schema({ x: { type: String, select: true }}));\n *     T.find(..); // field x will always be selected ..\n *     // .. unless overridden;\n *     T.find().select('-x').exec(callback);\n *\n * @param {Boolean} val\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaType.prototype.select = function select(val) {\n  this.selected = !!val;\n  return this;\n};\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * @param {any} value\n * @param {Function} callback\n * @param {Object} scope\n * @api private\n */\n\nSchemaType.prototype.doValidate = function(value, fn, scope) {\n  let err = false;\n  const path = this.path;\n  let count = this.validators.length;\n\n  if (!count) {\n    return fn(null);\n  }\n\n  const validate = function(ok, validatorProperties) {\n    if (err) {\n      return;\n    }\n    if (ok === undefined || ok) {\n      if (--count <= 0) {\n        immediate(function() {\n          fn(null);\n        });\n      }\n    } else {\n      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n      err = new ErrorConstructor(validatorProperties);\n      err[validatorErrorSymbol] = true;\n      immediate(function() {\n        fn(err);\n      });\n    }\n  };\n\n  const _this = this;\n  this.validators.forEach(function(v) {\n    if (err) {\n      return;\n    }\n\n    const validator = v.validator;\n    let ok;\n\n    const validatorProperties = utils.clone(v);\n    validatorProperties.path = path;\n    validatorProperties.value = value;\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties);\n    } else if (typeof validator === 'function') {\n      if (value === undefined && validator !== _this.requiredValidator) {\n        validate(true, validatorProperties);\n        return;\n      }\n      if (validatorProperties.isAsync) {\n        asyncValidate(validator, scope, value, validatorProperties, validate);\n      } else {\n        try {\n          if (validatorProperties.propsParameter) {\n            ok = validator.call(scope, value, validatorProperties);\n          } else {\n            ok = validator.call(scope, value);\n          }\n        } catch (error) {\n          ok = false;\n          validatorProperties.reason = error;\n          if (error.message) {\n            validatorProperties.message = error.message;\n          }\n        }\n        if (ok != null && typeof ok.then === 'function') {\n          ok.then(\n            function(ok) { validate(ok, validatorProperties); },\n            function(error) {\n              validatorProperties.reason = error;\n              ok = false;\n              validate(ok, validatorProperties);\n            });\n        } else {\n          validate(ok, validatorProperties);\n        }\n      }\n    }\n  });\n};\n\n/*!\n * Handle async validators\n */\n\nfunction asyncValidate(validator, scope, value, props, cb) {\n  let called = false;\n  const returnVal = validator.call(scope, value, function(ok, customMsg) {\n    if (called) {\n      return;\n    }\n    called = true;\n    if (customMsg) {\n      props.message = customMsg;\n    }\n    cb(ok, props);\n  });\n  if (typeof returnVal === 'boolean') {\n    called = true;\n    cb(returnVal, props);\n  } else if (returnVal && typeof returnVal.then === 'function') {\n    // Promise\n    returnVal.then(\n      function(ok) {\n        if (called) {\n          return;\n        }\n        called = true;\n        cb(ok, props);\n      },\n      function(error) {\n        if (called) {\n          return;\n        }\n        called = true;\n\n        props.reason = error;\n        cb(false, props);\n      });\n  }\n}\n\n/**\n * Performs a validation of `value` using the validators declared for this SchemaType.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @param {any} value\n * @param {Object} scope\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaType.prototype.doValidateSync = function(value, scope) {\n  let err = null;\n  const path = this.path;\n  const count = this.validators.length;\n\n  if (!count) {\n    return null;\n  }\n\n  const validate = function(ok, validatorProperties) {\n    if (err) {\n      return;\n    }\n    if (ok !== undefined && !ok) {\n      const ErrorConstructor = validatorProperties.ErrorConstructor || ValidatorError;\n      err = new ErrorConstructor(validatorProperties);\n      err[validatorErrorSymbol] = true;\n    }\n  };\n\n  let validators = this.validators;\n  if (value === void 0) {\n    if (this.validators.length > 0 && this.validators[0].type === 'required') {\n      validators = [this.validators[0]];\n    } else {\n      return null;\n    }\n  }\n\n  validators.forEach(function(v) {\n    if (err) {\n      return;\n    }\n\n    const validator = v.validator;\n    const validatorProperties = utils.clone(v);\n    validatorProperties.path = path;\n    validatorProperties.value = value;\n    let ok;\n\n    // Skip any explicit async validators. Validators that return a promise\n    // will still run, but won't trigger any errors.\n    if (validator.isAsync) {\n      return;\n    }\n\n    if (validator instanceof RegExp) {\n      validate(validator.test(value), validatorProperties);\n    } else if (typeof validator === 'function') {\n      try {\n        if (validatorProperties.propsParameter) {\n          ok = validator.call(scope, value, validatorProperties);\n        } else {\n          ok = validator.call(scope, value);\n        }\n      } catch (error) {\n        ok = false;\n        validatorProperties.reason = error;\n      }\n\n      // Skip any validators that return a promise, we can't handle those\n      // synchronously\n      if (ok != null && typeof ok.then === 'function') {\n        return;\n      }\n      validate(ok, validatorProperties);\n    }\n  });\n\n  return err;\n};\n\n/**\n * Determines if value is a valid Reference.\n *\n * @param {SchemaType} self\n * @param {Object} value\n * @param {Document} doc\n * @param {Boolean} init\n * @return {Boolean}\n * @api private\n */\n\nSchemaType._isRef = function(self, value, doc, init) {\n  // fast path\n  let ref = init && self.options && (self.options.ref || self.options.refPath);\n\n  if (!ref && doc && doc.$__ != null) {\n    // checks for\n    // - this populated with adhoc model and no ref was set in schema OR\n    // - setting / pushing values after population\n    const path = doc.$__fullPath(self.path);\n    const owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    ref = owner.populated(path);\n  }\n\n  if (ref) {\n    if (value == null) {\n      return true;\n    }\n    if (!Buffer.isBuffer(value) && // buffers are objects too\n        value._bsontype !== 'Binary' // raw binary value from the db\n        && utils.isObject(value) // might have deselected _id in population query\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.castForQuery(val);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(val)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(m);\n  });\n}\n\n/*!\n * Just like handleArray, except also allows `[]` because surprisingly\n * `$in: [1, []]` works fine\n */\n\nfunction handle$in(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(val)];\n  }\n  return val.map(function(m) {\n    if (Array.isArray(m) && m.length === 0) {\n      return m;\n    }\n    return _this.castForQuery(m);\n  });\n}\n\n/*!\n * ignore\n */\n\nSchemaType.prototype.$conditionalHandlers = {\n  $all: handleArray,\n  $eq: handleSingle,\n  $in: handle$in,\n  $ne: handleSingle,\n  $nin: handleArray,\n  $exists: $exists,\n  $type: $type\n};\n\n/*!\n * Wraps `castForQuery` to handle context\n */\n\nSchemaType.prototype.castForQueryWrapper = function(params) {\n  this.$$context = params.context;\n  if ('$conditional' in params) {\n    return this.castForQuery(params.$conditional, params.val);\n  }\n  if (params.$skipQueryCastForUpdate) {\n    return this._castForQuery(params.val);\n  }\n  return this.castForQuery(params.val);\n};\n\n/**\n * Cast the given value with the given optional query operator.\n *\n * @param {String} [$conditional] query operator, like `$eq` or `$in`\n * @param {any} val\n * @api private\n */\n\nSchemaType.prototype.castForQuery = function($conditional, val) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  return this._castForQuery(val);\n};\n\n/*!\n * Internal switch for runSetters\n *\n * @api private\n */\n\nSchemaType.prototype._castForQuery = function(val) {\n  return this.applySetters(val, this.$$context);\n};\n\n/**\n * Default check for if this path satisfies the `required` validator.\n *\n * @param {any} val\n * @api private\n */\n\nSchemaType.prototype.checkRequired = function(val) {\n  return val != null;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = SchemaType;\n\nexports.CastError = CastError;\n\nexports.ValidatorError = ValidatorError;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = require('./mongooseError');\nconst util = require('util');\n\n/**\n * Casting Error constructor.\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nfunction CastError(type, value, path, reason) {\n  let stringValue = util.inspect(value);\n  stringValue = stringValue.replace(/^'/, '\"').replace(/'$/, '\"');\n  if (stringValue.charAt(0) !== '\"') {\n    stringValue = '\"' + stringValue + '\"';\n  }\n  MongooseError.call(this, 'Cast to ' + type + ' failed for value ' +\n    stringValue + ' at path \"' + path + '\"');\n  this.name = 'CastError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.stringValue = stringValue;\n  this.kind = type;\n  this.value = value;\n  this.path = path;\n  this.reason = reason;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nCastError.prototype = Object.create(MongooseError.prototype);\nCastError.prototype.constructor = MongooseError;\n\n/*!\n * ignore\n */\n\nCastError.prototype.setModel = function(model) {\n  this.model = model;\n  this.message = 'Cast to ' + this.kind + ' failed for value ' +\n    this.stringValue + ' at path \"' + this.path + '\"' + ' for model \"' +\n    model.modelName + '\"';\n};\n\n/*!\n * exports\n */\n\nmodule.exports = CastError;\n","/*!\n * depd\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar callSiteToString = require('./lib/compat').callSiteToString\nvar eventListenerCount = require('./lib/compat').eventListenerCount\nvar relative = require('path').relative\n\n/**\n * Module exports.\n */\n\nmodule.exports = depd\n\n/**\n * Get the path to base files on.\n */\n\nvar basePath = process.cwd()\n\n/**\n * Determine if namespace is contained in the string.\n */\n\nfunction containsNamespace (str, namespace) {\n  var vals = str.split(/[ ,]+/)\n  var ns = String(namespace).toLowerCase()\n\n  for (var i = 0; i < vals.length; i++) {\n    var val = vals[i]\n\n    // namespace contained\n    if (val && (val === '*' || val.toLowerCase() === ns)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Convert a data descriptor to accessor descriptor.\n */\n\nfunction convertDataDescriptorToAccessor (obj, prop, message) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)\n  var value = descriptor.value\n\n  descriptor.get = function getter () { return value }\n\n  if (descriptor.writable) {\n    descriptor.set = function setter (val) { return (value = val) }\n  }\n\n  delete descriptor.value\n  delete descriptor.writable\n\n  Object.defineProperty(obj, prop, descriptor)\n\n  return descriptor\n}\n\n/**\n * Create arguments string to keep arity.\n */\n\nfunction createArgumentsString (arity) {\n  var str = ''\n\n  for (var i = 0; i < arity; i++) {\n    str += ', arg' + i\n  }\n\n  return str.substr(2)\n}\n\n/**\n * Create stack string from stack.\n */\n\nfunction createStackString (stack) {\n  var str = this.name + ': ' + this.namespace\n\n  if (this.message) {\n    str += ' deprecated ' + this.message\n  }\n\n  for (var i = 0; i < stack.length; i++) {\n    str += '\\n    at ' + callSiteToString(stack[i])\n  }\n\n  return str\n}\n\n/**\n * Create deprecate for namespace in caller.\n */\n\nfunction depd (namespace) {\n  if (!namespace) {\n    throw new TypeError('argument namespace is required')\n  }\n\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n  var file = site[0]\n\n  function deprecate (message) {\n    // call to self as log\n    log.call(deprecate, message)\n  }\n\n  deprecate._file = file\n  deprecate._ignored = isignored(namespace)\n  deprecate._namespace = namespace\n  deprecate._traced = istraced(namespace)\n  deprecate._warned = Object.create(null)\n\n  deprecate.function = wrapfunction\n  deprecate.property = wrapproperty\n\n  return deprecate\n}\n\n/**\n * Determine if namespace is ignored.\n */\n\nfunction isignored (namespace) {\n  /* istanbul ignore next: tested in a child processs */\n  if (process.noDeprecation) {\n    // --no-deprecation support\n    return true\n  }\n\n  var str = process.env.NO_DEPRECATION || ''\n\n  // namespace ignored\n  return containsNamespace(str, namespace)\n}\n\n/**\n * Determine if namespace is traced.\n */\n\nfunction istraced (namespace) {\n  /* istanbul ignore next: tested in a child processs */\n  if (process.traceDeprecation) {\n    // --trace-deprecation support\n    return true\n  }\n\n  var str = process.env.TRACE_DEPRECATION || ''\n\n  // namespace traced\n  return containsNamespace(str, namespace)\n}\n\n/**\n * Display deprecation message.\n */\n\nfunction log (message, site) {\n  var haslisteners = eventListenerCount(process, 'deprecation') !== 0\n\n  // abort early if no destination\n  if (!haslisteners && this._ignored) {\n    return\n  }\n\n  var caller\n  var callFile\n  var callSite\n  var depSite\n  var i = 0\n  var seen = false\n  var stack = getStack()\n  var file = this._file\n\n  if (site) {\n    // provided site\n    depSite = site\n    callSite = callSiteLocation(stack[1])\n    callSite.name = depSite.name\n    file = callSite[0]\n  } else {\n    // get call site\n    i = 2\n    depSite = callSiteLocation(stack[i])\n    callSite = depSite\n  }\n\n  // get caller of deprecated thing in relation to file\n  for (; i < stack.length; i++) {\n    caller = callSiteLocation(stack[i])\n    callFile = caller[0]\n\n    if (callFile === file) {\n      seen = true\n    } else if (callFile === this._file) {\n      file = this._file\n    } else if (seen) {\n      break\n    }\n  }\n\n  var key = caller\n    ? depSite.join(':') + '__' + caller.join(':')\n    : undefined\n\n  if (key !== undefined && key in this._warned) {\n    // already warned\n    return\n  }\n\n  this._warned[key] = true\n\n  // generate automatic message from call site\n  var msg = message\n  if (!msg) {\n    msg = callSite === depSite || !callSite.name\n      ? defaultMessage(depSite)\n      : defaultMessage(callSite)\n  }\n\n  // emit deprecation if listeners exist\n  if (haslisteners) {\n    var err = DeprecationError(this._namespace, msg, stack.slice(i))\n    process.emit('deprecation', err)\n    return\n  }\n\n  // format and write message\n  var format = process.stderr.isTTY\n    ? formatColor\n    : formatPlain\n  var output = format.call(this, msg, caller, stack.slice(i))\n  process.stderr.write(output + '\\n', 'utf8')\n}\n\n/**\n * Get call site location as array.\n */\n\nfunction callSiteLocation (callSite) {\n  var file = callSite.getFileName() || '<anonymous>'\n  var line = callSite.getLineNumber()\n  var colm = callSite.getColumnNumber()\n\n  if (callSite.isEval()) {\n    file = callSite.getEvalOrigin() + ', ' + file\n  }\n\n  var site = [file, line, colm]\n\n  site.callSite = callSite\n  site.name = callSite.getFunctionName()\n\n  return site\n}\n\n/**\n * Generate a default message from the site.\n */\n\nfunction defaultMessage (site) {\n  var callSite = site.callSite\n  var funcName = site.name\n\n  // make useful anonymous name\n  if (!funcName) {\n    funcName = '<anonymous@' + formatLocation(site) + '>'\n  }\n\n  var context = callSite.getThis()\n  var typeName = context && callSite.getTypeName()\n\n  // ignore useless type name\n  if (typeName === 'Object') {\n    typeName = undefined\n  }\n\n  // make useful type name\n  if (typeName === 'Function') {\n    typeName = context.name || typeName\n  }\n\n  return typeName && callSite.getMethodName()\n    ? typeName + '.' + funcName\n    : funcName\n}\n\n/**\n * Format deprecation message without color.\n */\n\nfunction formatPlain (msg, caller, stack) {\n  var timestamp = new Date().toUTCString()\n\n  var formatted = timestamp +\n    ' ' + this._namespace +\n    ' deprecated ' + msg\n\n  // add stack trace\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    at ' + callSiteToString(stack[i])\n    }\n\n    return formatted\n  }\n\n  if (caller) {\n    formatted += ' at ' + formatLocation(caller)\n  }\n\n  return formatted\n}\n\n/**\n * Format deprecation message with color.\n */\n\nfunction formatColor (msg, caller, stack) {\n  var formatted = '\\x1b[36;1m' + this._namespace + '\\x1b[22;39m' + // bold cyan\n    ' \\x1b[33;1mdeprecated\\x1b[22;39m' + // bold yellow\n    ' \\x1b[0m' + msg + '\\x1b[39m' // reset\n\n  // add stack trace\n  if (this._traced) {\n    for (var i = 0; i < stack.length; i++) {\n      formatted += '\\n    \\x1b[36mat ' + callSiteToString(stack[i]) + '\\x1b[39m' // cyan\n    }\n\n    return formatted\n  }\n\n  if (caller) {\n    formatted += ' \\x1b[36m' + formatLocation(caller) + '\\x1b[39m' // cyan\n  }\n\n  return formatted\n}\n\n/**\n * Format call site location.\n */\n\nfunction formatLocation (callSite) {\n  return relative(basePath, callSite[0]) +\n    ':' + callSite[1] +\n    ':' + callSite[2]\n}\n\n/**\n * Get the stack as array of call sites.\n */\n\nfunction getStack () {\n  var limit = Error.stackTraceLimit\n  var obj = {}\n  var prep = Error.prepareStackTrace\n\n  Error.prepareStackTrace = prepareObjectStackTrace\n  Error.stackTraceLimit = Math.max(10, limit)\n\n  // capture the stack\n  Error.captureStackTrace(obj)\n\n  // slice this function off the top\n  var stack = obj.stack.slice(1)\n\n  Error.prepareStackTrace = prep\n  Error.stackTraceLimit = limit\n\n  return stack\n}\n\n/**\n * Capture call site stack from v8.\n */\n\nfunction prepareObjectStackTrace (obj, stack) {\n  return stack\n}\n\n/**\n * Return a wrapped function in a deprecation message.\n */\n\nfunction wrapfunction (fn, message) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('argument fn must be a function')\n  }\n\n  var args = createArgumentsString(fn.length)\n  var deprecate = this // eslint-disable-line no-unused-vars\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n\n  site.name = fn.name\n\n   // eslint-disable-next-line no-eval\n  var deprecatedfn = eval('(function (' + args + ') {\\n' +\n    '\"use strict\"\\n' +\n    'log.call(deprecate, message, site)\\n' +\n    'return fn.apply(this, arguments)\\n' +\n    '})')\n\n  return deprecatedfn\n}\n\n/**\n * Wrap property in a deprecation message.\n */\n\nfunction wrapproperty (obj, prop, message) {\n  if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    throw new TypeError('argument obj must be object')\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(obj, prop)\n\n  if (!descriptor) {\n    throw new TypeError('must call property on owner object')\n  }\n\n  if (!descriptor.configurable) {\n    throw new TypeError('property must be configurable')\n  }\n\n  var deprecate = this\n  var stack = getStack()\n  var site = callSiteLocation(stack[1])\n\n  // set site name\n  site.name = prop\n\n  // convert data descriptor\n  if ('value' in descriptor) {\n    descriptor = convertDataDescriptorToAccessor(obj, prop, message)\n  }\n\n  var get = descriptor.get\n  var set = descriptor.set\n\n  // wrap getter\n  if (typeof get === 'function') {\n    descriptor.get = function getter () {\n      log.call(deprecate, message, site)\n      return get.apply(this, arguments)\n    }\n  }\n\n  // wrap setter\n  if (typeof set === 'function') {\n    descriptor.set = function setter () {\n      log.call(deprecate, message, site)\n      return set.apply(this, arguments)\n    }\n  }\n\n  Object.defineProperty(obj, prop, descriptor)\n}\n\n/**\n * Create DeprecationError for deprecation\n */\n\nfunction DeprecationError (namespace, message, stack) {\n  var error = new Error()\n  var stackString\n\n  Object.defineProperty(error, 'constructor', {\n    value: DeprecationError\n  })\n\n  Object.defineProperty(error, 'message', {\n    configurable: true,\n    enumerable: false,\n    value: message,\n    writable: true\n  })\n\n  Object.defineProperty(error, 'name', {\n    enumerable: false,\n    configurable: true,\n    value: 'DeprecationError',\n    writable: true\n  })\n\n  Object.defineProperty(error, 'namespace', {\n    configurable: true,\n    enumerable: false,\n    value: namespace,\n    writable: true\n  })\n\n  Object.defineProperty(error, 'stack', {\n    configurable: true,\n    enumerable: false,\n    get: function () {\n      if (stackString !== undefined) {\n        return stackString\n      }\n\n      // prepare stack trace\n      return (stackString = createStackString.call(this, stack))\n    },\n    set: function setter (val) {\n      stackString = val\n    }\n  })\n\n  return error\n}\n","'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst get = require('lodash.get');\nconst isDefiningProjection = require('./helpers/projection/isDefiningProjection');\nconst utils = require('./utils');\n\n/*!\n * Prepare a set of path options for query population.\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptions = function preparePopulationOptions(query, options) {\n  const pop = utils.object.vals(query.options.populate);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  return pop;\n};\n\n/*!\n * Prepare a set of path options for query population. This is the MongooseQuery\n * version\n *\n * @param {Query} query\n * @param {Object} options\n * @return {Array}\n */\n\nexports.preparePopulationOptionsMQ = function preparePopulationOptionsMQ(query, options) {\n  const pop = utils.object.vals(query._mongooseOptions.populate);\n\n  // lean options should trickle through all queries\n  if (options.lean != null) {\n    pop.\n      filter(p => get(p, 'options.lean') == null).\n      forEach(makeLean(options.lean));\n  }\n\n  const session = get(query, 'options.session', null);\n  if (session != null) {\n    pop.forEach(path => {\n      if (path.options == null) {\n        path.options = { session: session };\n        return;\n      }\n      if (!('session' in path.options)) {\n        path.options.session = session;\n      }\n    });\n  }\n\n  const projection = query._fieldsForExec();\n  pop.forEach(p => {\n    p._queryProjection = projection;\n  });\n\n  return pop;\n};\n\n\n/*!\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Model} model\n * @param {string} value\n */\nfunction getDiscriminatorByValue(model, value) {\n  let discriminator = null;\n  if (!model.discriminators) {\n    return discriminator;\n  }\n  for (const name in model.discriminators) {\n    const it = model.discriminators[name];\n    if (\n      it.schema &&\n      it.schema.discriminatorMapping &&\n      it.schema.discriminatorMapping.value == value\n    ) {\n      discriminator = it;\n      break;\n    }\n  }\n  return discriminator;\n}\n\nexports.getDiscriminatorByValue = getDiscriminatorByValue;\n\n/*!\n * If the document is a mapped discriminator type, it returns a model instance for that type, otherwise,\n * it returns an instance of the given model.\n *\n * @param {Model}  model\n * @param {Object} doc\n * @param {Object} fields\n *\n * @return {Model}\n */\nexports.createModel = function createModel(model, doc, fields, userProvidedFields) {\n  model.hooks.execPreSync('createModel', doc);\n  const discriminatorMapping = model.schema ?\n    model.schema.discriminatorMapping :\n    null;\n\n  const key = discriminatorMapping && discriminatorMapping.isRoot ?\n    discriminatorMapping.key :\n    null;\n\n  const value = doc[key];\n  if (key && value && model.discriminators) {\n    const discriminator = model.discriminators[value] || getDiscriminatorByValue(model, value);\n    if (discriminator) {\n      const _fields = utils.clone(userProvidedFields);\n      exports.applyPaths(_fields, discriminator.schema);\n      return new discriminator(undefined, _fields, true);\n    }\n  }\n\n  return new model(undefined, fields, {\n    skipId: true,\n    isNew: false,\n    willInit: true\n  });\n};\n\n/*!\n * ignore\n */\n\nexports.applyPaths = function applyPaths(fields, schema) {\n  // determine if query is selecting or excluding fields\n  let exclude;\n  let keys;\n  let ki;\n  let field;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    ki = keys.length;\n\n    while (ki--) {\n      if (keys[ki][0] === '+') {\n        continue;\n      }\n      field = fields[keys[ki]];\n      // Skip `$meta` and `$slice`\n      if (!isDefiningProjection(field)) {\n        continue;\n      }\n      exclude = field === 0;\n      break;\n    }\n  }\n\n  // if selecting, apply default schematype select:true fields\n  // if excluding, apply schematype select:false fields\n\n  const selected = [];\n  const excluded = [];\n  const stack = [];\n\n  const analyzePath = function(path, type) {\n    const plusPath = '+' + path;\n    const hasPlusPath = fields && plusPath in fields;\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n    }\n\n    if (typeof type.selected !== 'boolean') return;\n\n    if (hasPlusPath) {\n      // forced inclusion\n      delete fields[plusPath];\n\n      // if there are other fields being included, add this one\n      // if no other included fields, leave this out (implied inclusion)\n      if (exclude === false && keys.length > 1 && !~keys.indexOf(path)) {\n        fields[path] = 1;\n      }\n\n      return;\n    }\n\n    // check for parent exclusions\n    const pieces = path.split('.');\n    const root = pieces[0];\n    if (~excluded.indexOf(root)) {\n      return;\n    }\n\n    // Special case: if user has included a parent path of a discriminator key,\n    // don't explicitly project in the discriminator key because that will\n    // project out everything else under the parent path\n    if (!exclude && get(type, 'options.$skipDiscriminatorCheck', false)) {\n      let cur = '';\n      for (let i = 0; i < pieces.length; ++i) {\n        cur += (cur.length === 0 ? '' : '.') + pieces[i];\n        const projection = get(fields, cur, false);\n        if (projection && typeof projection !== 'object') {\n          return;\n        }\n      }\n    }\n\n    (type.selected ? selected : excluded).push(path);\n  };\n\n  analyzeSchema(schema);\n\n  switch (exclude) {\n    case true:\n      for (let i = 0; i < excluded.length; ++i) {\n        fields[excluded[i]] = 0;\n      }\n      break;\n    case false:\n      if (schema &&\n          schema.paths['_id'] &&\n          schema.paths['_id'].options &&\n          schema.paths['_id'].options.select === false) {\n        fields._id = 0;\n      }\n      for (let i = 0; i < selected.length; ++i) {\n        fields[selected[i]] = 1;\n      }\n      break;\n    case undefined:\n      if (fields == null) {\n        break;\n      }\n      // Any leftover plus paths must in the schema, so delete them (gh-7017)\n      for (const key of Object.keys(fields || {})) {\n        if (key.charAt(0) === '+') {\n          delete fields[key];\n        }\n      }\n\n      // user didn't specify fields, implies returning all fields.\n      // only need to apply excluded fields and delete any plus paths\n      for (let i = 0; i < excluded.length; ++i) {\n        fields[excluded[i]] = 0;\n      }\n      break;\n  }\n\n  function analyzeSchema(schema, prefix) {\n    prefix || (prefix = '');\n\n    // avoid recursion\n    if (stack.indexOf(schema) !== -1) {\n      return;\n    }\n    stack.push(schema);\n\n    schema.eachPath(function(path, type) {\n      if (prefix) path = prefix + '.' + path;\n\n      analyzePath(path, type);\n\n      // array of subdocs?\n      if (type.schema) {\n        analyzeSchema(type.schema, path);\n      }\n    });\n\n    stack.pop();\n  }\n};\n\n/*!\n * Set each path query option to lean\n *\n * @param {Object} option\n */\n\nfunction makeLean(val) {\n  return function(option) {\n    option.options || (option.options = {});\n    option.options.lean = val;\n  };\n}\n\n/*!\n * Handle the `WriteOpResult` from the server\n */\n\nexports.handleWriteOpResult = function handleWriteOpResult(callback) {\n  return function _handleWriteOpResult(error, res) {\n    if (error) {\n      return callback(error);\n    }\n    return callback(null, res.result);\n  };\n};\n","'use strict';\n\n/*!\n * ignore\n */\n\nlet driver = null;\n\nmodule.exports.get = function() {\n  return driver;\n};\n\nmodule.exports.set = function(v) {\n  driver = v;\n};\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @api private\n */\n\nvar Buffer = require('safe-buffer').Buffer\nvar contentDisposition = require('content-disposition');\nvar contentType = require('content-type');\nvar deprecate = require('depd')('express');\nvar flatten = require('array-flatten');\nvar mime = require('send').mime;\nvar etag = require('etag');\nvar proxyaddr = require('proxy-addr');\nvar qs = require('qs');\nvar querystring = require('querystring');\n\n/**\n * Return strong ETag for `body`.\n *\n * @param {String|Buffer} body\n * @param {String} [encoding]\n * @return {String}\n * @api private\n */\n\nexports.etag = createETagGenerator({ weak: false })\n\n/**\n * Return weak ETag for `body`.\n *\n * @param {String|Buffer} body\n * @param {String} [encoding]\n * @return {String}\n * @api private\n */\n\nexports.wetag = createETagGenerator({ weak: true })\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.isAbsolute = function(path){\n  if ('/' === path[0]) return true;\n  if (':' === path[1] && ('\\\\' === path[2] || '/' === path[2])) return true; // Windows device path\n  if ('\\\\\\\\' === path.substring(0, 2)) return true; // Microsoft Azure absolute path\n};\n\n/**\n * Flatten the given `arr`.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.flatten = deprecate.function(flatten,\n  'utils.flatten: use array-flatten npm module instead');\n\n/**\n * Normalize the given `type`, for example \"html\" becomes \"text/html\".\n *\n * @param {String} type\n * @return {Object}\n * @api private\n */\n\nexports.normalizeType = function(type){\n  return ~type.indexOf('/')\n    ? acceptParams(type)\n    : { value: mime.lookup(type), params: {} };\n};\n\n/**\n * Normalize `types`, for example \"html\" becomes \"text/html\".\n *\n * @param {Array} types\n * @return {Array}\n * @api private\n */\n\nexports.normalizeTypes = function(types){\n  var ret = [];\n\n  for (var i = 0; i < types.length; ++i) {\n    ret.push(exports.normalizeType(types[i]));\n  }\n\n  return ret;\n};\n\n/**\n * Generate Content-Disposition header appropriate for the filename.\n * non-ascii filenames are urlencoded and a filename* parameter is added\n *\n * @param {String} filename\n * @return {String}\n * @api private\n */\n\nexports.contentDisposition = deprecate.function(contentDisposition,\n  'utils.contentDisposition: use content-disposition npm module instead');\n\n/**\n * Parse accept params `str` returning an\n * object with `.value`, `.quality` and `.params`.\n * also includes `.originalIndex` for stable sorting\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction acceptParams(str, index) {\n  var parts = str.split(/ *; */);\n  var ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };\n\n  for (var i = 1; i < parts.length; ++i) {\n    var pms = parts[i].split(/ *= */);\n    if ('q' === pms[0]) {\n      ret.quality = parseFloat(pms[1]);\n    } else {\n      ret.params[pms[0]] = pms[1];\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compile \"etag\" value to function.\n *\n * @param  {Boolean|String|Function} val\n * @return {Function}\n * @api private\n */\n\nexports.compileETag = function(val) {\n  var fn;\n\n  if (typeof val === 'function') {\n    return val;\n  }\n\n  switch (val) {\n    case true:\n      fn = exports.wetag;\n      break;\n    case false:\n      break;\n    case 'strong':\n      fn = exports.etag;\n      break;\n    case 'weak':\n      fn = exports.wetag;\n      break;\n    default:\n      throw new TypeError('unknown value for etag function: ' + val);\n  }\n\n  return fn;\n}\n\n/**\n * Compile \"query parser\" value to function.\n *\n * @param  {String|Function} val\n * @return {Function}\n * @api private\n */\n\nexports.compileQueryParser = function compileQueryParser(val) {\n  var fn;\n\n  if (typeof val === 'function') {\n    return val;\n  }\n\n  switch (val) {\n    case true:\n      fn = querystring.parse;\n      break;\n    case false:\n      fn = newObject;\n      break;\n    case 'extended':\n      fn = parseExtendedQueryString;\n      break;\n    case 'simple':\n      fn = querystring.parse;\n      break;\n    default:\n      throw new TypeError('unknown value for query parser function: ' + val);\n  }\n\n  return fn;\n}\n\n/**\n * Compile \"proxy trust\" value to function.\n *\n * @param  {Boolean|String|Number|Array|Function} val\n * @return {Function}\n * @api private\n */\n\nexports.compileTrust = function(val) {\n  if (typeof val === 'function') return val;\n\n  if (val === true) {\n    // Support plain true/false\n    return function(){ return true };\n  }\n\n  if (typeof val === 'number') {\n    // Support trusting hop count\n    return function(a, i){ return i < val };\n  }\n\n  if (typeof val === 'string') {\n    // Support comma-separated values\n    val = val.split(/ *, */);\n  }\n\n  return proxyaddr.compile(val || []);\n}\n\n/**\n * Set the charset in a given Content-Type string.\n *\n * @param {String} type\n * @param {String} charset\n * @return {String}\n * @api private\n */\n\nexports.setCharset = function setCharset(type, charset) {\n  if (!type || !charset) {\n    return type;\n  }\n\n  // parse type\n  var parsed = contentType.parse(type);\n\n  // set charset\n  parsed.parameters.charset = charset;\n\n  // format type\n  return contentType.format(parsed);\n};\n\n/**\n * Create an ETag generator function, generating ETags with\n * the given options.\n *\n * @param {object} options\n * @return {function}\n * @private\n */\n\nfunction createETagGenerator (options) {\n  return function generateETag (body, encoding) {\n    var buf = !Buffer.isBuffer(body)\n      ? Buffer.from(body, encoding)\n      : body\n\n    return etag(buf, options)\n  }\n}\n\n/**\n * Parse an extended query string with qs.\n *\n * @return {Object}\n * @private\n */\n\nfunction parseExtendedQueryString(str) {\n  return qs.parse(str, {\n    allowPrototypes: true\n  });\n}\n\n/**\n * Return new empty object.\n *\n * @return {Object}\n * @api private\n */\n\nfunction newObject() {\n  return {};\n}\n","/**\n * ObjectId type constructor\n *\n * ####Example\n *\n *     var id = new mongoose.Types.ObjectId;\n *\n * @constructor ObjectId\n */\n\n'use strict';\n\nconst ObjectId = require('../driver').get().ObjectId;\n\n/*!\n * Getter for convenience with populate, see gh-6115\n */\n\nObject.defineProperty(ObjectId.prototype, '_id', {\n  enumerable: false,\n  configurable: true,\n  get: function() {\n    return this;\n  }\n});\n\nmodule.exports = ObjectId;\n","'use strict';\n\n/*!\n * ignore\n */\n\nexports.internalToObjectOptions = {\n  transform: false,\n  virtuals: false,\n  getters: false,\n  _skipDepopulateTopLevel: true,\n  depopulate: true,\n  flattenDecimals: false\n};\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst SchemaType = require('../schematype');\nconst symbols = require('./symbols');\nconst utils = require('../utils');\n\n/**\n * Mixed SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Mixed(path, options) {\n  if (options && options.default) {\n    const def = options.default;\n    if (Array.isArray(def) && def.length === 0) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared && utils.isObject(def) && Object.keys(def).length === 0) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function() {\n        return {};\n      };\n    }\n  }\n\n  SchemaType.call(this, path, options, 'Mixed');\n\n  this[symbols.schemaMixedSymbol] = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nMixed.schemaName = 'Mixed';\n\n/*!\n * Inherits from SchemaType.\n */\nMixed.prototype = Object.create(SchemaType.prototype);\nMixed.prototype.constructor = Mixed;\n\n/**\n * Casts `val` for Mixed.\n *\n * _this is a no-op_\n *\n * @param {Object} value to cast\n * @api private\n */\n\nMixed.prototype.cast = function(val) {\n  return val;\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nMixed.prototype.castForQuery = function($cond, val) {\n  if (arguments.length === 2) {\n    return val;\n  }\n  return $cond;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Mixed;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseArray = require('./array');\nconst ObjectId = require('./objectid');\nconst ObjectIdSchema = require('../schema/objectid');\nconst get = require('lodash.get');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst utils = require('../utils');\nconst Document = require('../document');\nconst getDiscriminatorByValue = require('../queryhelpers').getDiscriminatorByValue;\nconst util = require('util');\n\n/*!\n * ignore\n */\n\nclass CoreMongooseArray extends Array {\n  get isMongooseArray() {\n    return true;\n  }\n\n  remove() {}\n}\n\n/**\n * DocumentArray constructor\n *\n * @param {Array} values\n * @param {String} path the path to this array\n * @param {Document} doc parent document\n * @api private\n * @return {MongooseDocumentArray}\n * @inherits MongooseArray\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseDocumentArray(values, path, doc) {\n  // TODO: replace this with `new CoreMongooseArray().concat()` when we remove\n  // support for node 4.x and 5.x, see https://i.imgur.com/UAAHk4S.png\n  const arr = new CoreMongooseArray();\n  if (Array.isArray(values)) values.forEach(v => arr.push(v));\n  arr._path = path;\n\n  const props = {\n    isMongooseDocumentArray: true,\n    validators: [],\n    _atomics: {},\n    _schema: void 0,\n    _handlers: void 0\n  };\n\n  // Values always have to be passed to the constructor to initialize, since\n  // otherwise MongooseArray#push will mark the array as modified to the parent.\n  const keysMA = Object.keys(MongooseArray.mixin);\n  let numKeys = keysMA.length;\n  for (let j = 0; j < numKeys; ++j) {\n    arr[keysMA[j]] = MongooseArray.mixin[keysMA[j]];\n  }\n\n  const keysMDA = Object.keys(MongooseDocumentArray.mixin);\n  numKeys = keysMDA.length;\n  for (let i = 0; i < numKeys; ++i) {\n    arr[keysMDA[i]] = MongooseDocumentArray.mixin[keysMDA[i]];\n  }\n  if (util.inspect.custom) {\n    props[util.inspect.custom] = arr.inspect;\n  }\n\n  const keysP = Object.keys(props);\n  numKeys = keysP.length;\n  for (let k = 0; k < numKeys; ++k) {\n    arr[keysP[k]] = props[keysP[k]];\n  }\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020 && #3034)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n\n    // `schema.path()` doesn't drill into nested arrays properly yet, see\n    // gh-6398, gh-6602. This is a workaround because nested arrays are\n    // always plain non-document arrays, so once you get to a document array\n    // nesting is done. Matryoshka code.\n    while (get(arr, '_schema.$isMongooseArray') &&\n        !get(arr, '_schema.$isMongooseDocumentArray')) {\n      arr._schema = arr._schema.casterConstructor;\n    }\n\n    // Tricky but this may be a document array embedded in a normal array,\n    // in which case `path` would point to the embedded array. See #6405, #6398\n    if (arr._schema && !arr._schema.$isMongooseDocumentArray) {\n      arr._schema = arr._schema.casterConstructor;\n    }\n\n    arr._handlers = {\n      isNew: arr.notify('isNew'),\n      save: arr.notify('save')\n    };\n\n    doc.on('save', arr._handlers.save);\n    doc.on('isNew', arr._handlers.isNew);\n  }\n\n  return arr;\n}\n\n/*!\n * Inherits from MongooseArray\n */\n\nMongooseDocumentArray.mixin = {\n  /*!\n   * ignore\n   */\n  toBSON: function() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  /**\n   * Overrides MongooseArray#cast\n   *\n   * @method _cast\n   * @api private\n   * @receiver MongooseDocumentArray\n   */\n\n  _cast: function(value, index) {\n    let Constructor = this._schema.casterConstructor;\n    const isInstance = Constructor.$isMongooseDocumentArray ?\n      value && value.isMongooseDocumentArray :\n      value instanceof Constructor;\n    if (isInstance ||\n        // Hack re: #5001, see #5005\n        (value && value.constructor && value.constructor.baseCasterConstructor === Constructor)) {\n      if (!(value.__parent && value.__parentArray)) {\n        // value may have been created using array.create()\n        value.__parent = this._parent;\n        value.__parentArray = this;\n      }\n      value.$setIndex(index);\n      return value;\n    }\n\n    if (value === undefined || value === null) {\n      return null;\n    }\n\n    // handle cast('string') or cast(ObjectId) etc.\n    // only objects are permitted so we can safely assume that\n    // non-objects are to be interpreted as _id\n    if (Buffer.isBuffer(value) ||\n        value instanceof ObjectId || !utils.isObject(value)) {\n      value = {_id: value};\n    }\n\n    if (value &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof value[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[value[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, value[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    if (Constructor.$isMongooseDocumentArray) {\n      return Constructor.cast(value, this, undefined, undefined, index);\n    }\n    return new Constructor(value, this, undefined, undefined, index);\n  },\n\n  /**\n   * Searches array items for the first document with a matching _id.\n   *\n   * ####Example:\n   *\n   *     var embeddedDoc = m.array.id(some_id);\n   *\n   * @return {EmbeddedDocument|null} the subdocument or null if not found.\n   * @param {ObjectId|String|Number|Buffer} id\n   * @TODO cast to the _id based on schema for proper comparison\n   * @method id\n   * @api public\n   * @receiver MongooseDocumentArray\n   */\n\n  id: function(id) {\n    let casted,\n        sid,\n        _id;\n\n    try {\n      const casted_ = ObjectIdSchema.prototype.cast.call({}, id);\n      if (casted_) {\n        casted = String(casted_);\n      }\n    } catch (e) {\n      casted = null;\n    }\n\n    for (let i = 0, l = this.length; i < l; i++) {\n      if (!this[i]) {\n        continue;\n      }\n      _id = this[i].get('_id');\n\n      if (_id === null || typeof _id === 'undefined') {\n        continue;\n      } else if (_id instanceof Document) {\n        sid || (sid = String(id));\n        if (sid == _id._id) {\n          return this[i];\n        }\n      } else if (!(id instanceof ObjectId) && !(_id instanceof ObjectId)) {\n        if (utils.deepEqual(id, _id)) {\n          return this[i];\n        }\n      } else if (casted == _id) {\n        return this[i];\n      }\n    }\n\n    return null;\n  },\n\n  /**\n   * Returns a native js Array of plain js objects\n   *\n   * ####NOTE:\n   *\n   * _Each sub-document is converted to a plain object by calling its `#toObject` method._\n   *\n   * @param {Object} [options] optional options to pass to each documents `toObject` method call during conversion\n   * @return {Array}\n   * @method toObject\n   * @api public\n   * @receiver MongooseDocumentArray\n   */\n\n  toObject: function(options) {\n    return this.map(function(doc) {\n      try {\n        return doc.toObject(options);\n      } catch (e) {\n        return doc || null;\n      }\n    });\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @method inspect\n   * @api public\n   * @receiver MongooseDocumentArray\n   */\n\n  inspect: function() {\n    return this.toObject();\n  },\n\n  /**\n   * Creates a subdocument casted to this schema.\n   *\n   * This is the same subdocument constructor used for casting.\n   *\n   * @param {Object} obj the value to cast to this arrays SubDocument schema\n   * @method create\n   * @api public\n   * @receiver MongooseDocumentArray\n   */\n\n  create: function(obj) {\n    let Constructor = this._schema.casterConstructor;\n    if (obj &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof obj[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[obj[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, obj[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    return new Constructor(obj);\n  },\n\n  /**\n   * Creates a fn that notifies all child docs of `event`.\n   *\n   * @param {String} event\n   * @return {Function}\n   * @method notify\n   * @api private\n   * @receiver MongooseDocumentArray\n   */\n\n  notify: function notify(event) {\n    const _this = this;\n    return function notify(val, _arr) {\n      _arr = _arr || _this;\n      let i = _arr.length;\n      while (i--) {\n        if (_arr[i] == null) {\n          continue;\n        }\n        switch (event) {\n          // only swap for save event for now, we may change this to all event types later\n          case 'save':\n            val = _this[i];\n            break;\n          default:\n            // NO-OP\n            break;\n        }\n\n        if (_arr[i].isMongooseArray) {\n          notify(val, _arr[i]);\n        } else if (_arr[i]) {\n          _arr[i].emit(event, val);\n        }\n      }\n    };\n  }\n\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = MongooseDocumentArray;\n","/*!\n * bytes\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015 Jed Watson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = bytes;\nmodule.exports.format = format;\nmodule.exports.parse = parse;\n\n/**\n * Module variables.\n * @private\n */\n\nvar formatThousandsRegExp = /\\B(?=(\\d{3})+(?!\\d))/g;\n\nvar formatDecimalsRegExp = /(?:\\.0*|(\\.[^0]+)0+)$/;\n\nvar map = {\n  b:  1,\n  kb: 1 << 10,\n  mb: 1 << 20,\n  gb: 1 << 30,\n  tb: ((1 << 30) * 1024)\n};\n\nvar parseRegExp = /^((-|\\+)?(\\d+(?:\\.\\d+)?)) *(kb|mb|gb|tb)$/i;\n\n/**\n * Convert the given value in bytes into a string or parse to string to an integer in bytes.\n *\n * @param {string|number} value\n * @param {{\n *  case: [string],\n *  decimalPlaces: [number]\n *  fixedDecimals: [boolean]\n *  thousandsSeparator: [string]\n *  unitSeparator: [string]\n *  }} [options] bytes options.\n *\n * @returns {string|number|null}\n */\n\nfunction bytes(value, options) {\n  if (typeof value === 'string') {\n    return parse(value);\n  }\n\n  if (typeof value === 'number') {\n    return format(value, options);\n  }\n\n  return null;\n}\n\n/**\n * Format the given value in bytes into a string.\n *\n * If the value is negative, it is kept as such. If it is a float,\n * it is rounded.\n *\n * @param {number} value\n * @param {object} [options]\n * @param {number} [options.decimalPlaces=2]\n * @param {number} [options.fixedDecimals=false]\n * @param {string} [options.thousandsSeparator=]\n * @param {string} [options.unit=]\n * @param {string} [options.unitSeparator=]\n *\n * @returns {string|null}\n * @public\n */\n\nfunction format(value, options) {\n  if (!Number.isFinite(value)) {\n    return null;\n  }\n\n  var mag = Math.abs(value);\n  var thousandsSeparator = (options && options.thousandsSeparator) || '';\n  var unitSeparator = (options && options.unitSeparator) || '';\n  var decimalPlaces = (options && options.decimalPlaces !== undefined) ? options.decimalPlaces : 2;\n  var fixedDecimals = Boolean(options && options.fixedDecimals);\n  var unit = (options && options.unit) || '';\n\n  if (!unit || !map[unit.toLowerCase()]) {\n    if (mag >= map.tb) {\n      unit = 'TB';\n    } else if (mag >= map.gb) {\n      unit = 'GB';\n    } else if (mag >= map.mb) {\n      unit = 'MB';\n    } else if (mag >= map.kb) {\n      unit = 'KB';\n    } else {\n      unit = 'B';\n    }\n  }\n\n  var val = value / map[unit.toLowerCase()];\n  var str = val.toFixed(decimalPlaces);\n\n  if (!fixedDecimals) {\n    str = str.replace(formatDecimalsRegExp, '$1');\n  }\n\n  if (thousandsSeparator) {\n    str = str.replace(formatThousandsRegExp, thousandsSeparator);\n  }\n\n  return str + unitSeparator + unit;\n}\n\n/**\n * Parse the string value into an integer in bytes.\n *\n * If no unit is given, it is assumed the value is in bytes.\n *\n * @param {number|string} val\n *\n * @returns {number|null}\n * @public\n */\n\nfunction parse(val) {\n  if (typeof val === 'number' && !isNaN(val)) {\n    return val;\n  }\n\n  if (typeof val !== 'string') {\n    return null;\n  }\n\n  // Test if the string passed is valid\n  var results = parseRegExp.exec(val);\n  var floatValue;\n  var unit = 'b';\n\n  if (!results) {\n    // Nothing could be extracted from the given string\n    floatValue = parseInt(val, 10);\n    unit = 'b'\n  } else {\n    // Retrieve the value and the unit\n    floatValue = parseFloat(results[1]);\n    unit = results[4].toLowerCase();\n  }\n\n  return Math.floor(map[unit] * floatValue);\n}\n","/*!\n * http-errors\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar deprecate = require('depd')('http-errors')\nvar setPrototypeOf = require('setprototypeof')\nvar statuses = require('statuses')\nvar inherits = require('inherits')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = createError\nmodule.exports.HttpError = createHttpErrorConstructor()\n\n// Populate exports for all constructors\npopulateConstructorExports(module.exports, statuses.codes, module.exports.HttpError)\n\n/**\n * Get the code class of a status code.\n * @private\n */\n\nfunction codeClass (status) {\n  return Number(String(status).charAt(0) + '00')\n}\n\n/**\n * Create a new HTTP Error.\n *\n * @returns {Error}\n * @public\n */\n\nfunction createError () {\n  // so much arity going on ~_~\n  var err\n  var msg\n  var status = 500\n  var props = {}\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i]\n    if (arg instanceof Error) {\n      err = arg\n      status = err.status || err.statusCode || status\n      continue\n    }\n    switch (typeof arg) {\n      case 'string':\n        msg = arg\n        break\n      case 'number':\n        status = arg\n        if (i !== 0) {\n          deprecate('non-first-argument status code; replace with createError(' + arg + ', ...)')\n        }\n        break\n      case 'object':\n        props = arg\n        break\n    }\n  }\n\n  if (typeof status === 'number' && (status < 400 || status >= 600)) {\n    deprecate('non-error status code; use only 4xx or 5xx status codes')\n  }\n\n  if (typeof status !== 'number' ||\n    (!statuses[status] && (status < 400 || status >= 600))) {\n    status = 500\n  }\n\n  // constructor\n  var HttpError = createError[status] || createError[codeClass(status)]\n\n  if (!err) {\n    // create error\n    err = HttpError\n      ? new HttpError(msg)\n      : new Error(msg || statuses[status])\n    Error.captureStackTrace(err, createError)\n  }\n\n  if (!HttpError || !(err instanceof HttpError) || err.status !== status) {\n    // add properties to generic error\n    err.expose = status < 500\n    err.status = err.statusCode = status\n  }\n\n  for (var key in props) {\n    if (key !== 'status' && key !== 'statusCode') {\n      err[key] = props[key]\n    }\n  }\n\n  return err\n}\n\n/**\n * Create HTTP error abstract base class.\n * @private\n */\n\nfunction createHttpErrorConstructor () {\n  function HttpError () {\n    throw new TypeError('cannot construct abstract class')\n  }\n\n  inherits(HttpError, Error)\n\n  return HttpError\n}\n\n/**\n * Create a constructor for a client error.\n * @private\n */\n\nfunction createClientErrorConstructor (HttpError, name, code) {\n  var className = name.match(/Error$/) ? name : name + 'Error'\n\n  function ClientError (message) {\n    // create the error object\n    var msg = message != null ? message : statuses[code]\n    var err = new Error(msg)\n\n    // capture a stack trace to the construction point\n    Error.captureStackTrace(err, ClientError)\n\n    // adjust the [[Prototype]]\n    setPrototypeOf(err, ClientError.prototype)\n\n    // redefine the error message\n    Object.defineProperty(err, 'message', {\n      enumerable: true,\n      configurable: true,\n      value: msg,\n      writable: true\n    })\n\n    // redefine the error name\n    Object.defineProperty(err, 'name', {\n      enumerable: false,\n      configurable: true,\n      value: className,\n      writable: true\n    })\n\n    return err\n  }\n\n  inherits(ClientError, HttpError)\n\n  ClientError.prototype.status = code\n  ClientError.prototype.statusCode = code\n  ClientError.prototype.expose = true\n\n  return ClientError\n}\n\n/**\n * Create a constructor for a server error.\n * @private\n */\n\nfunction createServerErrorConstructor (HttpError, name, code) {\n  var className = name.match(/Error$/) ? name : name + 'Error'\n\n  function ServerError (message) {\n    // create the error object\n    var msg = message != null ? message : statuses[code]\n    var err = new Error(msg)\n\n    // capture a stack trace to the construction point\n    Error.captureStackTrace(err, ServerError)\n\n    // adjust the [[Prototype]]\n    setPrototypeOf(err, ServerError.prototype)\n\n    // redefine the error message\n    Object.defineProperty(err, 'message', {\n      enumerable: true,\n      configurable: true,\n      value: msg,\n      writable: true\n    })\n\n    // redefine the error name\n    Object.defineProperty(err, 'name', {\n      enumerable: false,\n      configurable: true,\n      value: className,\n      writable: true\n    })\n\n    return err\n  }\n\n  inherits(ServerError, HttpError)\n\n  ServerError.prototype.status = code\n  ServerError.prototype.statusCode = code\n  ServerError.prototype.expose = false\n\n  return ServerError\n}\n\n/**\n * Populate the exports object with constructors for every error class.\n * @private\n */\n\nfunction populateConstructorExports (exports, codes, HttpError) {\n  codes.forEach(function forEachCode (code) {\n    var CodeError\n    var name = toIdentifier(statuses[code])\n\n    switch (codeClass(code)) {\n      case 400:\n        CodeError = createClientErrorConstructor(HttpError, name, code)\n        break\n      case 500:\n        CodeError = createServerErrorConstructor(HttpError, name, code)\n        break\n    }\n\n    if (CodeError) {\n      // export the constructor\n      exports[code] = CodeError\n      exports[name] = CodeError\n    }\n  })\n\n  // backwards-compatibility\n  exports[\"I'mateapot\"] = deprecate.function(exports.ImATeapot,\n    '\"I\\'mateapot\"; use \"ImATeapot\" instead')\n}\n\n/**\n * Convert a string of words to a JavaScript identifier.\n * @private\n */\n\nfunction toIdentifier (str) {\n  return str.split(' ').map(function (token) {\n    return token.slice(0, 1).toUpperCase() + token.slice(1)\n  }).join('').replace(/[^ _0-9a-z]/gi, '')\n}\n","/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar typer = require('media-typer')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = typeofrequest\nmodule.exports.is = typeis\nmodule.exports.hasBody = hasbody\nmodule.exports.normalize = normalize\nmodule.exports.match = mimeMatch\n\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */\n\nfunction typeis (value, types_) {\n  var i\n  var types = types_\n\n  // remove parameters and normalize\n  var val = tryNormalizeType(value)\n\n  // no type or invalid\n  if (!val) {\n    return false\n  }\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1)\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // no types, return the content type\n  if (!types || !types.length) {\n    return val\n  }\n\n  var type\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1\n        ? val\n        : type\n    }\n  }\n\n  // no matches\n  return false\n}\n\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */\n\nfunction hasbody (req) {\n  return req.headers['transfer-encoding'] !== undefined ||\n    !isNaN(req.headers['content-length'])\n}\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nfunction typeofrequest (req, types_) {\n  var types = types_\n\n  // no body\n  if (!hasbody(req)) {\n    return null\n  }\n\n  // support flattened arguments\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1]\n    }\n  }\n\n  // request content type\n  var value = req.headers['content-type']\n\n  return typeis(value, types)\n}\n\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */\n\nfunction normalize (type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false\n  }\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded'\n    case 'multipart':\n      return 'multipart/*'\n  }\n\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type\n  }\n\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */\n\nfunction mimeMatch (expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false\n  }\n\n  // split types\n  var actualParts = actual.split('/')\n  var expectedParts = expected.split('/')\n\n  // invalid format\n  if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false\n  }\n\n  // validate type\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false\n  }\n\n  // validate suffix wildcard\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 &&\n      expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length)\n  }\n\n  // validate subtype\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction normalizeType (value) {\n  // parse the type\n  var type = typer.parse(value)\n\n  // remove the parameters\n  type.parameters = undefined\n\n  // reformat it\n  return typer.format(type)\n}\n\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction tryNormalizeType (value) {\n  try {\n    return normalizeType(value)\n  } catch (err) {\n    return null\n  }\n}\n","/*!\n * parseurl\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar url = require('url')\nvar parse = url.parse\nvar Url = url.Url\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = parseurl\nmodule.exports.original = originalurl\n\n/**\n * Parse the `req` url with memoization.\n *\n * @param {ServerRequest} req\n * @return {Object}\n * @public\n */\n\nfunction parseurl (req) {\n  var url = req.url\n\n  if (url === undefined) {\n    // URL is undefined\n    return undefined\n  }\n\n  var parsed = req._parsedUrl\n\n  if (fresh(url, parsed)) {\n    // Return cached URL parse\n    return parsed\n  }\n\n  // Parse the URL\n  parsed = fastparse(url)\n  parsed._raw = url\n\n  return (req._parsedUrl = parsed)\n};\n\n/**\n * Parse the `req` original url with fallback and memoization.\n *\n * @param {ServerRequest} req\n * @return {Object}\n * @public\n */\n\nfunction originalurl (req) {\n  var url = req.originalUrl\n\n  if (typeof url !== 'string') {\n    // Fallback\n    return parseurl(req)\n  }\n\n  var parsed = req._parsedOriginalUrl\n\n  if (fresh(url, parsed)) {\n    // Return cached URL parse\n    return parsed\n  }\n\n  // Parse the URL\n  parsed = fastparse(url)\n  parsed._raw = url\n\n  return (req._parsedOriginalUrl = parsed)\n};\n\n/**\n * Parse the `str` url with fast-path short-cut.\n *\n * @param {string} str\n * @return {Object}\n * @private\n */\n\nfunction fastparse (str) {\n  if (typeof str !== 'string' || str.charCodeAt(0) !== 0x2f /* / */) {\n    return parse(str)\n  }\n\n  var pathname = str\n  var query = null\n  var search = null\n\n  // This takes the regexp from https://github.com/joyent/node/pull/7878\n  // Which is /^(\\/[^?#\\s]*)(\\?[^#\\s]*)?$/\n  // And unrolls it into a for loop\n  for (var i = 1; i < str.length; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x3f: /* ?  */\n        if (search === null) {\n          pathname = str.substring(0, i)\n          query = str.substring(i + 1)\n          search = str.substring(i)\n        }\n        break\n      case 0x09: /* \\t */\n      case 0x0a: /* \\n */\n      case 0x0c: /* \\f */\n      case 0x0d: /* \\r */\n      case 0x20: /*    */\n      case 0x23: /* #  */\n      case 0xa0:\n      case 0xfeff:\n        return parse(str)\n    }\n  }\n\n  var url = Url !== undefined\n    ? new Url()\n    : {}\n  url.path = str\n  url.href = str\n  url.pathname = pathname\n  url.query = query\n  url.search = search\n\n  return url\n}\n\n/**\n * Determine if parsed is still fresh for url.\n *\n * @param {string} url\n * @param {object} parsedUrl\n * @return {boolean}\n * @private\n */\n\nfunction fresh (url, parsedUrl) {\n  return typeof parsedUrl === 'object' &&\n    parsedUrl !== null &&\n    (Url === undefined || parsedUrl instanceof Url) &&\n    parsedUrl._raw === url\n}\n","/*!\n * Centralize this so we can more easily work around issues with people\n * stubbing out `process.nextTick()` in tests using sinon:\n * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time\n * See gh-6074\n */\n\n'use strict';\n\nmodule.exports = function immediate(cb) {\n  return process.nextTick(cb);\n};\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ObjectId = require('../types/objectid');\nconst utils = require('../utils');\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options) {\n  let keys;\n  if (update && utils.isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }));\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result) {\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    result[path + key] = true;\n    if (utils.isMongooseObject(val) && !Buffer.isBuffer(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result);\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n    typeof val === 'object' &&\n    !(val instanceof Date) &&\n    !(val instanceof ObjectId) &&\n    (!Array.isArray(val) || val.length > 0) &&\n    !(val instanceof Buffer);\n}\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function isDefiningProjection(val) {\n  if (val == null) {\n    // `undefined` or `null` become exclusive projections\n    return true;\n  }\n  if (typeof val === 'object') {\n    // Only cases where a value does **not** define whether the whole projection\n    // is inclusive or exclusive are `$meta` and `$slice`.\n    return !('$meta' in val) && !('$slice' in val);\n  }\n  return true;\n};\n","/* eslint no-func-assign: 1 */\n\n/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst Document = require('../document_provider')();\nconst EventEmitter = require('events').EventEmitter;\nconst immediate = require('../helpers/immediate');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst get = require('lodash.get');\nconst utils = require('../utils');\nconst util = require('util');\nconst validatorErrorSymbol = require('../helpers/symbols').validatorErrorSymbol;\n\n/**\n * EmbeddedDocument constructor.\n *\n * @param {Object} obj js object returned from the db\n * @param {MongooseDocumentArray} parentArr the parent array of this document\n * @param {Boolean} skipId\n * @inherits Document\n * @api private\n */\n\nfunction EmbeddedDocument(obj, parentArr, skipId, fields, index) {\n  if (parentArr) {\n    this.__parentArray = parentArr;\n    this.__parent = parentArr._parent;\n  } else {\n    this.__parentArray = undefined;\n    this.__parent = undefined;\n  }\n  this.$setIndex(index);\n  this.$isDocumentArrayElement = true;\n\n  Document.call(this, obj, fields, skipId);\n\n  const _this = this;\n  this.on('isNew', function(val) {\n    _this.isNew = val;\n  });\n\n  _this.on('save', function() {\n    _this.constructor.emit('save', _this);\n  });\n}\n\n/*!\n * Inherit from Document\n */\nEmbeddedDocument.prototype = Object.create(Document.prototype);\nEmbeddedDocument.prototype.constructor = EmbeddedDocument;\n\nfor (const i in EventEmitter.prototype) {\n  EmbeddedDocument[i] = EventEmitter.prototype[i];\n}\n\nEmbeddedDocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/*!\n * ignore\n */\n\nEmbeddedDocument.prototype.$setIndex = function(index) {\n  this.__index = index;\n\n  if (get(this, '$__.validationError', null) != null) {\n    const keys = Object.keys(this.$__.validationError.errors);\n    for (const key of keys) {\n      this.invalidate(key, this.$__.validationError.errors[key]);\n    }\n  }\n};\n\n/**\n * Marks the embedded doc modified.\n *\n * ####Example:\n *\n *     var doc = blogpost.comments.id(hexstring);\n *     doc.mixed.type = 'changed';\n *     doc.markModified('mixed.type');\n *\n * @param {String} path the path which changed\n * @api public\n * @receiver EmbeddedDocument\n */\n\nEmbeddedDocument.prototype.markModified = function(path) {\n  this.$__.activePaths.modify(path);\n  if (!this.__parentArray) {\n    return;\n  }\n\n  if (this.isNew) {\n    // Mark the WHOLE parent array as modified\n    // if this is a new document (i.e., we are initializing\n    // a document),\n    this.__parentArray._markModified();\n  } else {\n    this.__parentArray._markModified(this, path);\n  }\n};\n\n/*!\n * ignore\n */\n\nEmbeddedDocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.arr[0].populate(\"path\")`, use ' +\n    '`doc.populate(\"arr.0.path\")`');\n};\n\n/**\n * Used as a stub for [hooks.js](https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3)\n *\n * ####NOTE:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nEmbeddedDocument.prototype.save = function(options, fn) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  }\n  options = options || {};\n\n  if (!options.suppressWarning) {\n    console.warn('mongoose: calling `save()` on a subdoc does **not** save ' +\n      'the document to MongoDB, it only runs save middleware. ' +\n      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +\n      'if you\\'re sure this behavior is right for your app.');\n  }\n\n  return utils.promiseOrCallback(fn, cb => {\n    this.$__save(cb);\n  });\n};\n\n/**\n * Used as a stub for middleware\n *\n * ####NOTE:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @method $__save\n * @api private\n */\n\nEmbeddedDocument.prototype.$__save = function(fn) {\n  return immediate(() => fn(null, this));\n};\n\n/*!\n * Registers remove event listeners for triggering\n * on subdocuments.\n *\n * @param {EmbeddedDocument} sub\n * @api private\n */\n\nfunction registerRemoveListener(sub) {\n  let owner = sub.ownerDocument();\n\n  function emitRemove() {\n    owner.removeListener('save', emitRemove);\n    owner.removeListener('remove', emitRemove);\n    sub.emit('remove', sub);\n    sub.constructor.emit('remove', sub);\n    owner = sub = null;\n  }\n\n  owner.on('save', emitRemove);\n  owner.on('remove', emitRemove);\n}\n\n/*!\n * no-op for hooks\n */\n\nEmbeddedDocument.prototype.$__remove = function(cb) {\n  return cb(null, this);\n};\n\n/**\n * Removes the subdocument from its parent array.\n *\n * @param {Object} [options]\n * @param {Function} [fn]\n * @api public\n */\n\nEmbeddedDocument.prototype.remove = function(options, fn) {\n  if ( typeof options === 'function' && !fn ) {\n    fn = options;\n    options = undefined;\n  }\n  if (!this.__parentArray || (options && options.noop)) {\n    fn && fn(null);\n    return this;\n  }\n\n  let _id;\n  if (!this.willRemove) {\n    _id = this._doc._id;\n    if (!_id) {\n      throw new Error('For your own good, Mongoose does not know ' +\n          'how to remove an EmbeddedDocument that has no _id');\n    }\n    this.__parentArray.pull({_id: _id});\n    this.willRemove = true;\n    registerRemoveListener(this);\n  }\n\n  if (fn) {\n    fn(null);\n  }\n\n  return this;\n};\n\n/**\n * Override #update method of parent documents.\n * @api private\n */\n\nEmbeddedDocument.prototype.update = function() {\n  throw new Error('The #update method is not available on EmbeddedDocuments');\n};\n\n/**\n * Helper for console.log\n *\n * @api public\n */\n\nEmbeddedDocument.prototype.inspect = function() {\n  return this.toObject({\n    transform: false,\n    virtuals: false,\n    flattenDecimals: false\n  });\n};\n\nif (util.inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  EmbeddedDocument.prototype[util.inspect.custom] = EmbeddedDocument.prototype.inspect;\n}\n\n/**\n * Marks a path as invalid, causing validation to fail.\n *\n * @param {String} path the field to invalidate\n * @param {String|Error} err error which states the reason `path` was invalid\n * @return {Boolean}\n * @api public\n */\n\nEmbeddedDocument.prototype.invalidate = function(path, err, val) {\n  Document.prototype.invalidate.call(this, path, err, val);\n\n  if (!this.__parent) {\n    if (err[validatorErrorSymbol] || err.name === 'ValidationError') {\n      return true;\n    }\n    throw err;\n  }\n\n  const index = this.__index;\n  if (typeof index !== 'undefined') {\n    const parentPath = this.__parentArray._path;\n    const fullPath = [parentPath, index, path].join('.');\n    this.__parent.invalidate(fullPath, err, val);\n  }\n\n  return true;\n};\n\n/**\n * Marks a path as valid, removing existing validation errors.\n *\n * @param {String} path the field to mark as valid\n * @api private\n * @method $markValid\n * @receiver EmbeddedDocument\n */\n\nEmbeddedDocument.prototype.$markValid = function(path) {\n  if (!this.__parent) {\n    return;\n  }\n\n  const index = this.__index;\n  if (typeof index !== 'undefined') {\n    const parentPath = this.__parentArray._path;\n    const fullPath = [parentPath, index, path].join('.');\n    this.__parent.$markValid(fullPath);\n  }\n};\n\n/*!\n * ignore\n */\n\nEmbeddedDocument.prototype.$ignore = function(path) {\n  Document.prototype.$ignore.call(this, path);\n\n  if (!this.__parent) {\n    return;\n  }\n\n  const index = this.__index;\n  if (typeof index !== 'undefined') {\n    const parentPath = this.__parentArray._path;\n    const fullPath = [parentPath, index, path].join('.');\n    this.__parent.$ignore(fullPath);\n  }\n};\n\n/**\n * Checks if a path is invalid\n *\n * @param {String} path the field to check\n * @api private\n * @method $isValid\n * @receiver EmbeddedDocument\n */\n\nEmbeddedDocument.prototype.$isValid = function(path) {\n  const index = this.__index;\n  if (typeof index !== 'undefined' && this.__parent) {\n    return !this.__parent.$__.validationError ||\n      !this.__parent.$__.validationError.errors[this.$__fullPath(path)];\n  }\n\n  return true;\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\n\nEmbeddedDocument.prototype.ownerDocument = function() {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  let parent = this.__parent;\n  if (!parent) {\n    return this;\n  }\n\n  while (parent.__parent || parent.$parent) {\n    parent = parent.__parent || parent.$parent;\n  }\n\n  this.$__.ownerDocument = parent;\n  return this.$__.ownerDocument;\n};\n\n/**\n * Returns the full path to this document. If optional `path` is passed, it is appended to the full path.\n *\n * @param {String} [path]\n * @return {String}\n * @api private\n * @method $__fullPath\n * @memberOf EmbeddedDocument\n * @instance\n */\n\nEmbeddedDocument.prototype.$__fullPath = function(path) {\n  if (!this.$__.fullPath) {\n    let parent = this; // eslint-disable-line consistent-this\n    if (!parent.__parent) {\n      return path;\n    }\n\n    const paths = [];\n    while (parent.__parent || parent.$parent) {\n      if (parent.__parent) {\n        paths.unshift(parent.__parentArray._path);\n      } else {\n        paths.unshift(parent.$basePath);\n      }\n      parent = parent.__parent || parent.$parent;\n    }\n\n    this.$__.fullPath = paths.join('.');\n\n    if (!this.$__.ownerDocument) {\n      // optimization\n      this.$__.ownerDocument = parent;\n    }\n  }\n\n  return path\n    ? this.$__.fullPath + '.' + path\n    : this.$__.fullPath;\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n */\n\nEmbeddedDocument.prototype.parent = function() {\n  return this.__parent;\n};\n\n/**\n * Returns this sub-documents parent array.\n *\n * @api public\n */\n\nEmbeddedDocument.prototype.parentArray = function() {\n  return this.__parentArray;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = EmbeddedDocument;\n","\n/*!\n * Module exports.\n */\n\n'use strict';\n\nexports.Array = require('./array');\nexports.Buffer = require('./buffer');\n\nexports.Document = // @deprecate\nexports.Embedded = require('./embedded');\n\nexports.DocumentArray = require('./documentarray');\nexports.Decimal128 = require('./decimal128');\nexports.ObjectId = require('./objectid');\n\nexports.Map = require('./map');\n\nexports.Subdocument = require('./subdocument');\n","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.substr(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value[0] === '\"') {\n        // remove quotes and escapes\n        value = value\n          .substr(1, value.length - 2)\n          .replace(QESC_REGEXP, '$1')\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar getBody = require('raw-body')\nvar iconv = require('iconv-lite')\nvar onFinished = require('on-finished')\nvar zlib = require('zlib')\n\n/**\n * Module exports.\n */\n\nmodule.exports = read\n\n/**\n * Read a request into a buffer and parse.\n *\n * @param {object} req\n * @param {object} res\n * @param {function} next\n * @param {function} parse\n * @param {function} debug\n * @param {object} options\n * @private\n */\n\nfunction read (req, res, next, parse, debug, options) {\n  var length\n  var opts = options\n  var stream\n\n  // flag as parsed\n  req._body = true\n\n  // read options\n  var encoding = opts.encoding !== null\n    ? opts.encoding\n    : null\n  var verify = opts.verify\n\n  try {\n    // get the content stream\n    stream = contentstream(req, debug, opts.inflate)\n    length = stream.length\n    stream.length = undefined\n  } catch (err) {\n    return next(err)\n  }\n\n  // set raw-body options\n  opts.length = length\n  opts.encoding = verify\n    ? null\n    : encoding\n\n  // assert charset is supported\n  if (opts.encoding === null && encoding !== null && !iconv.encodingExists(encoding)) {\n    return next(createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n      charset: encoding.toLowerCase(),\n      type: 'charset.unsupported'\n    }))\n  }\n\n  // read body\n  debug('read body')\n  getBody(stream, opts, function (error, body) {\n    if (error) {\n      var _error\n\n      if (error.type === 'encoding.unsupported') {\n        // echo back charset\n        _error = createError(415, 'unsupported charset \"' + encoding.toUpperCase() + '\"', {\n          charset: encoding.toLowerCase(),\n          type: 'charset.unsupported'\n        })\n      } else {\n        // set status code on error\n        _error = createError(400, error)\n      }\n\n      // read off entire request\n      stream.resume()\n      onFinished(req, function onfinished () {\n        next(createError(400, _error))\n      })\n      return\n    }\n\n    // verify\n    if (verify) {\n      try {\n        debug('verify body')\n        verify(req, res, body, encoding)\n      } catch (err) {\n        next(createError(403, err, {\n          body: body,\n          type: err.type || 'entity.verify.failed'\n        }))\n        return\n      }\n    }\n\n    // parse\n    var str = body\n    try {\n      debug('parse body')\n      str = typeof body !== 'string' && encoding !== null\n        ? iconv.decode(body, encoding)\n        : body\n      req.body = parse(str)\n    } catch (err) {\n      next(createError(400, err, {\n        body: str,\n        type: err.type || 'entity.parse.failed'\n      }))\n      return\n    }\n\n    next()\n  })\n}\n\n/**\n * Get the content stream of the request.\n *\n * @param {object} req\n * @param {function} debug\n * @param {boolean} [inflate=true]\n * @return {object}\n * @api private\n */\n\nfunction contentstream (req, debug, inflate) {\n  var encoding = (req.headers['content-encoding'] || 'identity').toLowerCase()\n  var length = req.headers['content-length']\n  var stream\n\n  debug('content-encoding \"%s\"', encoding)\n\n  if (inflate === false && encoding !== 'identity') {\n    throw createError(415, 'content encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n\n  switch (encoding) {\n    case 'deflate':\n      stream = zlib.createInflate()\n      debug('inflate body')\n      req.pipe(stream)\n      break\n    case 'gzip':\n      stream = zlib.createGunzip()\n      debug('gunzip body')\n      req.pipe(stream)\n      break\n    case 'identity':\n      stream = req\n      stream.length = length\n      break\n    default:\n      throw createError(415, 'unsupported content encoding \"' + encoding + '\"', {\n        encoding: encoding,\n        type: 'encoding.unsupported'\n      })\n  }\n\n  return stream\n}\n","/*!\n * on-finished\n * Copyright(c) 2013 Jonathan Ong\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = onFinished\nmodule.exports.isFinished = isFinished\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar first = require('ee-first')\n\n/**\n * Variables.\n * @private\n */\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function(fn){ process.nextTick(fn.bind.apply(fn, arguments)) }\n\n/**\n * Invoke callback when the response has finished, useful for\n * cleaning up resources afterwards.\n *\n * @param {object} msg\n * @param {function} listener\n * @return {object}\n * @public\n */\n\nfunction onFinished(msg, listener) {\n  if (isFinished(msg) !== false) {\n    defer(listener, null, msg)\n    return msg\n  }\n\n  // attach the listener to the message\n  attachListener(msg, listener)\n\n  return msg\n}\n\n/**\n * Determine if message is already finished.\n *\n * @param {object} msg\n * @return {boolean}\n * @public\n */\n\nfunction isFinished(msg) {\n  var socket = msg.socket\n\n  if (typeof msg.finished === 'boolean') {\n    // OutgoingMessage\n    return Boolean(msg.finished || (socket && !socket.writable))\n  }\n\n  if (typeof msg.complete === 'boolean') {\n    // IncomingMessage\n    return Boolean(msg.upgrade || !socket || !socket.readable || (msg.complete && !msg.readable))\n  }\n\n  // don't know\n  return undefined\n}\n\n/**\n * Attach a finished listener to the message.\n *\n * @param {object} msg\n * @param {function} callback\n * @private\n */\n\nfunction attachFinishedListener(msg, callback) {\n  var eeMsg\n  var eeSocket\n  var finished = false\n\n  function onFinish(error) {\n    eeMsg.cancel()\n    eeSocket.cancel()\n\n    finished = true\n    callback(error)\n  }\n\n  // finished on first message event\n  eeMsg = eeSocket = first([[msg, 'end', 'finish']], onFinish)\n\n  function onSocket(socket) {\n    // remove listener\n    msg.removeListener('socket', onSocket)\n\n    if (finished) return\n    if (eeMsg !== eeSocket) return\n\n    // finished on first socket event\n    eeSocket = first([[socket, 'error', 'close']], onFinish)\n  }\n\n  if (msg.socket) {\n    // socket already assigned\n    onSocket(msg.socket)\n    return\n  }\n\n  // wait for socket to be assigned\n  msg.on('socket', onSocket)\n\n  if (msg.socket === undefined) {\n    // node.js 0.8 patch\n    patchAssignSocket(msg, onSocket)\n  }\n}\n\n/**\n * Attach the listener to the message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction attachListener(msg, listener) {\n  var attached = msg.__onFinished\n\n  // create a private single listener with queue\n  if (!attached || !attached.queue) {\n    attached = msg.__onFinished = createListener(msg)\n    attachFinishedListener(msg, attached)\n  }\n\n  attached.queue.push(listener)\n}\n\n/**\n * Create listener on message.\n *\n * @param {object} msg\n * @return {function}\n * @private\n */\n\nfunction createListener(msg) {\n  function listener(err) {\n    if (msg.__onFinished === listener) msg.__onFinished = null\n    if (!listener.queue) return\n\n    var queue = listener.queue\n    listener.queue = null\n\n    for (var i = 0; i < queue.length; i++) {\n      queue[i](err, msg)\n    }\n  }\n\n  listener.queue = []\n\n  return listener\n}\n\n/**\n * Patch ServerResponse.prototype.assignSocket for node.js 0.8.\n *\n * @param {ServerResponse} res\n * @param {function} callback\n * @private\n */\n\nfunction patchAssignSocket(res, callback) {\n  var assignSocket = res.assignSocket\n\n  if (typeof assignSocket !== 'function') return\n\n  // res.on('socket', callback) is broken in 0.8\n  res.assignSocket = function _assignSocket(socket) {\n    assignSocket.call(this, socket)\n    callback(socket)\n  }\n}\n","/*!\n * encodeurl\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = encodeUrl\n\n/**\n * RegExp to match non-URL code points, *after* encoding (i.e. not including \"%\")\n * and including invalid escape sequences.\n * @private\n */\n\nvar ENCODE_CHARS_REGEXP = /(?:[^\\x21\\x25\\x26-\\x3B\\x3D\\x3F-\\x5B\\x5D\\x5F\\x61-\\x7A\\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g\n\n/**\n * RegExp to match unmatched surrogate pair.\n * @private\n */\n\nvar UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\\uD800-\\uDBFF])[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF]([^\\uDC00-\\uDFFF]|$)/g\n\n/**\n * String to replace unmatched surrogate pair with.\n * @private\n */\n\nvar UNMATCHED_SURROGATE_PAIR_REPLACE = '$1\\uFFFD$2'\n\n/**\n * Encode a URL to a percent-encoded form, excluding already-encoded sequences.\n *\n * This function will take an already-encoded URL and encode all the non-URL\n * code points. This function will not encode the \"%\" character unless it is\n * not part of a valid sequence (`%20` will be left as-is, but `%foo` will\n * be encoded as `%25foo`).\n *\n * This encode is meant to be \"safe\" and does not throw errors. It will try as\n * hard as it can to properly encode the given URL, including replacing any raw,\n * unpaired surrogate pairs with the Unicode replacement character prior to\n * encoding.\n *\n * @param {string} url\n * @return {string}\n * @public\n */\n\nfunction encodeUrl (url) {\n  return String(url)\n    .replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE)\n    .replace(ENCODE_CHARS_REGEXP, encodeURI)\n}\n","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","\n/*!\n * Connection states\n */\n\n'use strict';\n\nconst STATES = module.exports = exports = Object.create(null);\n\nconst disconnected = 'disconnected';\nconst connected = 'connected';\nconst connecting = 'connecting';\nconst disconnecting = 'disconnecting';\nconst uninitialized = 'uninitialized';\n\nSTATES[0] = disconnected;\nSTATES[1] = connected;\nSTATES[2] = connecting;\nSTATES[3] = disconnecting;\nSTATES[99] = uninitialized;\n\nSTATES[disconnected] = 0;\nSTATES[connected] = 1;\nSTATES[connecting] = 2;\nSTATES[disconnecting] = 3;\nSTATES[uninitialized] = 99;\n","/*!\n * ignore\n */\n\n'use strict';\n\nconst assert = require('assert');\nconst mquery = require('mquery');\n\n/**\n * Helper for multiplexing promise implementations\n *\n * @api private\n */\n\nconst store = {\n  _promise: null\n};\n\n/**\n * Get the current promise constructor\n *\n * @api private\n */\n\nstore.get = function() {\n  return store._promise;\n};\n\n/**\n * Set the current promise constructor\n *\n * @api private\n */\n\nstore.set = function(lib) {\n  assert.ok(typeof lib === 'function',\n    `mongoose.Promise must be a function, got ${lib}`);\n  store._promise = lib;\n  mquery.Promise = lib;\n};\n\n/*!\n * Use native promises by default\n */\n\nstore.set(global.Promise);\n\nmodule.exports = store;\n","/**\n * MongooseError constructor\n *\n * @param {String} msg Error message\n * @inherits Error https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error\n */\n\n'use strict';\n\nfunction MongooseError(msg) {\n  Error.call(this);\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.message = msg;\n  this.name = 'MongooseError';\n}\n\n/*!\n * Inherits from Error.\n */\n\nMongooseError.prototype = Object.create(Error.prototype);\nMongooseError.prototype.constructor = Error;\n\nmodule.exports = MongooseError;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst SchemaType = require('./schematype');\nconst VirtualType = require('./virtualtype');\nconst applyTimestampsToChildren = require('./helpers/update/applyTimestampsToChildren');\nconst applyTimestampsToUpdate = require('./helpers/update/applyTimestampsToUpdate');\nconst get = require('lodash.get');\nconst getIndexes = require('./helpers/schema/getIndexes');\nconst handleTimestampOption = require('./helpers/schema/handleTimestampOption');\nconst merge = require('./helpers/schema/merge');\nconst mpath = require('mpath');\nconst readPref = require('./driver').get().ReadPreference;\nconst util = require('util');\nconst utils = require('./utils');\nconst validateRef = require('./helpers/populate/validateRef');\n\nlet MongooseTypes;\n\nconst allMiddleware = require('./helpers/query/applyQueryMiddleware').\n  middlewareFunctions.\n  concat(require('./helpers/model/applyHooks').middlewareFunctions);\n\nlet id = 0;\n\n/**\n * Schema constructor.\n *\n * ####Example:\n *\n *     var child = new Schema({ name: String });\n *     var schema = new Schema({ name: String, age: Number, children: [child] });\n *     var Tree = mongoose.model('Tree', schema);\n *\n *     // setting schema options\n *     new Schema({ name: String }, { _id: false, autoIndex: false })\n *\n * ####Options:\n *\n * - [autoIndex](/docs/guide.html#autoIndex): bool - defaults to null (which means use the connection's autoIndex option)\n * - [autoCreate](/docs/guide.html#autoCreate): bool - defaults to null (which means use the connection's autoCreate option)\n * - [bufferCommands](/docs/guide.html#bufferCommands): bool - defaults to true\n * - [capped](/docs/guide.html#capped): bool - defaults to false\n * - [collection](/docs/guide.html#collection): string - no default\n * - [id](/docs/guide.html#id): bool - defaults to true\n * - [_id](/docs/guide.html#_id): bool - defaults to true\n * - `minimize`: bool - controls [document#toObject](#document_Document-toObject) behavior when called manually - defaults to true\n * - [read](/docs/guide.html#read): string\n * - [writeConcern](/docs/guide.html#writeConcern): object - defaults to null, use to override [the MongoDB server's default write concern settings](https://docs.mongodb.com/manual/reference/write-concern/)\n * - [shardKey](/docs/guide.html#shardKey): bool - defaults to `null`\n * - [strict](/docs/guide.html#strict): bool - defaults to true\n * - [toJSON](/docs/guide.html#toJSON) - object - no default\n * - [toObject](/docs/guide.html#toObject) - object - no default\n * - [typeKey](/docs/guide.html#typeKey) - string - defaults to 'type'\n * - [useNestedStrict](/docs/guide.html#useNestedStrict) - boolean - defaults to false\n * - [validateBeforeSave](/docs/guide.html#validateBeforeSave) - bool - defaults to `true`\n * - [versionKey](/docs/guide.html#versionKey): string - defaults to \"__v\"\n * - [collation](/docs/guide.html#collation): object - defaults to null (which means use no collation)\n * - [selectPopulatedPaths](/docs/guide.html#selectPopulatedPaths): boolean - defaults to `true`\n *\n * ####Note:\n *\n * _When nesting schemas, (`children` in the example above), always declare the child schema first before passing it into its parent._\n *\n * @param {Object} definition\n * @param {Object} [options]\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted after the schema is compiled into a `Model`.\n * @api public\n */\n\nfunction Schema(obj, options) {\n  if (!(this instanceof Schema)) {\n    return new Schema(obj, options);\n  }\n\n  this.obj = obj;\n  this.paths = {};\n  this.aliases = {};\n  this.subpaths = {};\n  this.virtuals = {};\n  this.singleNestedPaths = {};\n  this.nested = {};\n  this.inherits = {};\n  this.callQueue = [];\n  this._indexes = [];\n  this.methods = {};\n  this.methodOptions = {};\n  this.statics = {};\n  this.tree = {};\n  this.query = {};\n  this.childSchemas = [];\n  this.plugins = [];\n  // For internal debugging. Do not use this to try to save a schema in MDB.\n  this.$id = ++id;\n\n  this.s = {\n    hooks: new Kareem()\n  };\n\n  this.options = this.defaultOptions(options);\n\n  // build paths\n  if (obj) {\n    this.add(obj);\n  }\n\n  // check if _id's value is a subdocument (gh-2276)\n  const _idSubDoc = obj && obj._id && utils.isObject(obj._id);\n\n  // ensure the documents get an auto _id unless disabled\n  const auto_id = !this.paths['_id'] &&\n      (!this.options.noId && this.options._id) && !_idSubDoc;\n\n  if (auto_id) {\n    const _obj = {_id: {auto: true}};\n    _obj._id[this.options.typeKey] = Schema.ObjectId;\n    this.add(_obj);\n  }\n\n  this.setupTimestamp(this.options.timestamps);\n}\n\n/*!\n * Create virtual properties with alias field\n */\nfunction aliasFields(schema, paths) {\n  paths = paths || Object.keys(schema.paths);\n  for (const path of paths) {\n    const options = get(schema.paths[path], 'options');\n    if (options == null) {\n      continue;\n    }\n\n    const prop = schema.paths[path].path;\n    const alias = options.alias;\n\n    if (!alias) {\n      continue;\n    }\n\n    if (typeof alias !== 'string') {\n      throw new Error('Invalid value for alias option on ' + prop + ', got ' + alias);\n    }\n\n    schema.aliases[alias] = prop;\n\n    schema.\n      virtual(alias).\n      get((function(p) {\n        return function() {\n          if (typeof this.get === 'function') {\n            return this.get(p);\n          }\n          return this[p];\n        };\n      })(prop)).\n      set((function(p) {\n        return function(v) {\n          return this.set(p, v);\n        };\n      })(prop));\n  }\n}\n\n/*!\n * Inherit from EventEmitter.\n */\nSchema.prototype = Object.create(EventEmitter.prototype);\nSchema.prototype.constructor = Schema;\nSchema.prototype.instanceOfSchema = true;\n\n/*!\n * ignore\n */\n\nObject.defineProperty(Schema.prototype, '$schemaType', {\n  configurable: false,\n  enumerable: false,\n  writable: true\n});\n\n/**\n * Array of child schemas (from document arrays and single nested subdocs)\n * and their corresponding compiled models. Each element of the array is\n * an object with 2 properties: `schema` and `model`.\n *\n * This property is typically only useful for plugin authors and advanced users.\n * You do not need to interact with this property at all to use mongoose.\n *\n * @api public\n * @property childSchemas\n * @memberOf Schema\n * @instance\n */\n\nObject.defineProperty(Schema.prototype, 'childSchemas', {\n  configurable: false,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The original object passed to the schema constructor\n *\n * ####Example:\n *\n *     var schema = new Schema({ a: String }).add({ b: String });\n *     schema.obj; // { a: String }\n *\n * @api public\n * @property obj\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.obj;\n\n/**\n * Schema as flat paths\n *\n * ####Example:\n *     {\n *         '_id'        : SchemaType,\n *       , 'nested.key' : SchemaType,\n *     }\n *\n * @api private\n * @property paths\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.paths;\n\n/**\n * Schema as a tree\n *\n * ####Example:\n *     {\n *         '_id'     : ObjectId\n *       , 'nested'  : {\n *             'key' : String\n *         }\n *     }\n *\n * @api private\n * @property tree\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.tree;\n\n/**\n * Returns a deep copy of the schema\n *\n * @return {Schema} the cloned schema\n * @api public\n * @memberOf Schema\n * @instance\n */\n\nSchema.prototype.clone = function() {\n  const s = new Schema({}, this._userProvidedOptions);\n  s.obj = this.obj;\n  s.options = utils.clone(this.options);\n  s.callQueue = this.callQueue.map(function(f) { return f; });\n  s.methods = utils.clone(this.methods);\n  s.methodOptions = utils.clone(this.methodOptions);\n  s.statics = utils.clone(this.statics);\n  s.query = utils.clone(this.query);\n  s.plugins = Array.prototype.slice.call(this.plugins);\n  s._indexes = utils.clone(this._indexes);\n  s.s.hooks = this.s.hooks.clone();\n  s._originalSchema = this._originalSchema == null ?\n    this._originalSchema :\n    this._originalSchema.clone();\n\n  s.tree = utils.clone(this.tree);\n  s.paths = utils.clone(this.paths);\n  s.nested = utils.clone(this.nested);\n  s.subpaths = utils.clone(this.subpaths);\n  s.childSchemas = this.childSchemas.slice();\n  s.singleNestedPaths = utils.clone(this.singleNestedPaths);\n\n  s.virtuals = utils.clone(this.virtuals);\n  s.$globalPluginsApplied = this.$globalPluginsApplied;\n  s.$isRootDiscriminator = this.$isRootDiscriminator;\n\n  if (this.discriminatorMapping != null) {\n    s.discriminatorMapping = Object.assign({}, this.discriminatorMapping);\n  }\n  if (s.discriminators != null) {\n    s.discriminators = Object.assign({}, this.discriminators);\n  }\n\n  s.aliases = Object.assign({}, this.aliases);\n\n  // Bubble up `init` for backwards compat\n  s.on('init', v => this.emit('init', v));\n\n  return s;\n};\n\n/**\n * Returns default options for this schema, merged with `options`.\n *\n * @param {Object} options\n * @return {Object}\n * @api private\n */\n\nSchema.prototype.defaultOptions = function(options) {\n  if (options && options.safe === false) {\n    options.safe = {w: 0};\n  }\n\n  if (options && options.safe && options.safe.w === 0) {\n    // if you turn off safe writes, then versioning goes off as well\n    options.versionKey = false;\n  }\n\n  this._userProvidedOptions = options == null ? {} : utils.clone(options);\n\n  const baseOptions = get(this, 'base.options', {});\n  options = utils.options({\n    strict: 'strict' in baseOptions ? baseOptions.strict : true,\n    bufferCommands: true,\n    capped: false, // { size, max, autoIndexId }\n    versionKey: '__v',\n    discriminatorKey: '__t',\n    minimize: true,\n    autoIndex: null,\n    shardKey: null,\n    read: null,\n    validateBeforeSave: true,\n    // the following are only applied at construction time\n    noId: false, // deprecated, use { _id: false }\n    _id: true,\n    noVirtualId: false, // deprecated, use { id: false }\n    id: true,\n    typeKey: 'type'\n  }, utils.clone(options));\n\n  if (options.read) {\n    options.read = readPref(options.read);\n  }\n\n  return options;\n};\n\n/**\n * Adds key path / schema type pairs to this schema.\n *\n * ####Example:\n *\n *     const ToySchema = new Schema();\n *     ToySchema.add({ name: 'string', color: 'string', price: 'number' });\n *\n *     const TurboManSchema = new Schema();\n *     // You can also `add()` another schema and copy over all paths, virtuals,\n *     // getters, setters, indexes, methods, and statics.\n *     TurboManSchema.add(ToySchema).add({ year: Number });\n *\n * @param {Object|Schema} obj plain object with paths to add, or another schema\n * @param {String} [prefix] path to prefix the newly added paths with\n * @return {Schema} the Schema instance\n * @api public\n */\n\nSchema.prototype.add = function add(obj, prefix) {\n  if (obj instanceof Schema) {\n    merge(this, obj);\n    return;\n  }\n\n  prefix = prefix || '';\n  const keys = Object.keys(obj);\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n\n    if (obj[key] == null) {\n      throw new TypeError('Invalid value for schema path `' + prefix + key + '`');\n    }\n\n    if (Array.isArray(obj[key]) && obj[key].length === 1 && obj[key][0] == null) {\n      throw new TypeError('Invalid value for schema Array path `' + prefix + key + '`');\n    }\n\n    if (utils.isObject(obj[key]) &&\n        (!obj[key].constructor || utils.getFunctionName(obj[key].constructor) === 'Object') &&\n        (!obj[key][this.options.typeKey] || (this.options.typeKey === 'type' && obj[key].type.type))) {\n      if (Object.keys(obj[key]).length) {\n        // nested object { last: { name: String }}\n        this.nested[prefix + key] = true;\n        this.add(obj[key], prefix + key + '.');\n      } else {\n        if (prefix) {\n          this.nested[prefix.substr(0, prefix.length - 1)] = true;\n        }\n        this.path(prefix + key, obj[key]); // mixed type\n      }\n    } else {\n      if (prefix) {\n        this.nested[prefix.substr(0, prefix.length - 1)] = true;\n      }\n      this.path(prefix + key, obj[key]);\n    }\n  }\n\n  const addedKeys = Object.keys(obj).\n    map(key => prefix ? prefix + key : key);\n  aliasFields(this, addedKeys);\n  return this;\n};\n\n/**\n * Reserved document keys.\n *\n * Keys in this object are names that are rejected in schema declarations b/c they conflict with mongoose functionality. Using these key name will throw an error.\n *\n *      on, emit, _events, db, get, set, init, isNew, errors, schema, options, modelName, collection, _pres, _posts, toObject\n *\n * _NOTE:_ Use of these terms as method names is permitted, but play at your own risk, as they may be existing mongoose document methods you are stomping on.\n *\n *      var schema = new Schema(..);\n *      schema.methods.init = function () {} // potentially breaking\n */\n\nSchema.reserved = Object.create(null);\nSchema.prototype.reserved = Schema.reserved;\nconst reserved = Schema.reserved;\n// Core object\nreserved['prototype'] =\n// EventEmitter\nreserved.emit =\nreserved.on =\nreserved.once =\nreserved.listeners =\nreserved.removeListener =\n// document properties and functions\nreserved.collection =\nreserved.db =\nreserved.errors =\nreserved.init =\nreserved.isModified =\nreserved.isNew =\nreserved.get =\nreserved.modelName =\nreserved.save =\nreserved.schema =\nreserved.toObject =\nreserved.validate =\nreserved.remove =\n// hooks.js\nreserved._pres = reserved._posts = 1;\n\n/*!\n * Document keys to print warnings for\n */\n\nconst warnings = {};\nwarnings.increment = '`increment` should not be used as a schema path name ' +\n    'unless you have disabled versioning.';\n\n/**\n * Gets/sets schema paths.\n *\n * Sets a path (if arity 2)\n * Gets a path (if arity 1)\n *\n * ####Example\n *\n *     schema.path('name') // returns a SchemaType\n *     schema.path('name', Number) // changes the schemaType of `name` to Number\n *\n * @param {String} path\n * @param {Object} constructor\n * @api public\n */\n\nSchema.prototype.path = function(path, obj) {\n  if (obj === undefined) {\n    if (this.paths[path]) {\n      return this.paths[path];\n    }\n    if (this.subpaths[path]) {\n      return this.subpaths[path];\n    }\n    if (this.singleNestedPaths[path]) {\n      return this.singleNestedPaths[path];\n    }\n\n    // Look for maps\n    for (const _path of Object.keys(this.paths)) {\n      if (!_path.includes('.$*')) {\n        continue;\n      }\n      const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '.[^.]+') + '$');\n      if (re.test(path)) {\n        return this.paths[_path];\n      }\n    }\n\n    // subpaths?\n    return /\\.\\d+\\.?.*$/.test(path)\n      ? getPositionalPath(this, path)\n      : undefined;\n  }\n\n  // some path names conflict with document methods\n  if (reserved[path]) {\n    throw new Error('`' + path + '` may not be used as a schema pathname');\n  }\n\n  if (warnings[path]) {\n    console.log('WARN: ' + warnings[path]);\n  }\n\n  if (typeof obj === 'object' && 'ref' in obj) {\n    validateRef(obj.ref, path);\n  }\n\n  // update the tree\n  const subpaths = path.split(/\\./);\n  const last = subpaths.pop();\n  let branch = this.tree;\n\n  subpaths.forEach(function(sub, i) {\n    if (!branch[sub]) {\n      branch[sub] = {};\n    }\n    if (typeof branch[sub] !== 'object') {\n      const msg = 'Cannot set nested path `' + path + '`. '\n          + 'Parent path `'\n          + subpaths.slice(0, i).concat([sub]).join('.')\n          + '` already set to type ' + branch[sub].name\n          + '.';\n      throw new Error(msg);\n    }\n    branch = branch[sub];\n  });\n\n  branch[last] = utils.clone(obj);\n\n  this.paths[path] = this.interpretAsType(path, obj, this.options);\n  const schemaType = this.paths[path];\n\n  if (schemaType.$isSchemaMap) {\n    // Maps can have arbitrary keys, so `$*` is internal shorthand for \"any key\"\n    // The '$' is to imply this path should never be stored in MongoDB so we\n    // can easily build a regexp out of this path, and '*' to imply \"any key.\"\n    const mapPath = path + '.$*';\n    this.paths[path + '.$*'] = this.interpretAsType(mapPath,\n      obj.of || { type: {} }, this.options);\n    schemaType.$__schemaType = this.paths[path + '.$*'];\n  }\n\n  if (schemaType.$isSingleNested) {\n    for (const key in schemaType.schema.paths) {\n      this.singleNestedPaths[path + '.' + key] = schemaType.schema.paths[key];\n    }\n    for (const key in schemaType.schema.singleNestedPaths) {\n      this.singleNestedPaths[path + '.' + key] =\n        schemaType.schema.singleNestedPaths[key];\n    }\n\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.caster\n    });\n  } else if (schemaType.$isMongooseDocumentArray) {\n    this.childSchemas.push({\n      schema: schemaType.schema,\n      model: schemaType.casterConstructor\n    });\n  }\n\n  return this;\n};\n\n/**\n * Converts type arguments into Mongoose Types.\n *\n * @param {String} path\n * @param {Object} obj constructor\n * @api private\n */\n\nSchema.prototype.interpretAsType = function(path, obj, options) {\n  if (obj instanceof SchemaType) {\n    return obj;\n  }\n\n  // If this schema has an associated Mongoose object, use the Mongoose object's\n  // copy of SchemaTypes re: gh-7158 gh-6933\n  const MongooseTypes = this.base != null ? this.base.Schema.Types : Schema.Types;\n\n  if (obj.constructor) {\n    const constructorName = utils.getFunctionName(obj.constructor);\n    if (constructorName !== 'Object') {\n      const oldObj = obj;\n      obj = {};\n      obj[options.typeKey] = oldObj;\n    }\n  }\n\n  // Get the type making sure to allow keys named \"type\"\n  // and default to mixed if not specified.\n  // { type: { type: String, default: 'freshcut' } }\n  let type = obj[options.typeKey] && (options.typeKey !== 'type' || !obj.type.type)\n    ? obj[options.typeKey]\n    : {};\n  let name;\n\n  if (utils.getFunctionName(type.constructor) === 'Object' || type === 'mixed') {\n    return new MongooseTypes.Mixed(path, obj);\n  }\n\n  if (Array.isArray(type) || Array === type || type === 'array') {\n    // if it was specified through { type } look for `cast`\n    let cast = (Array === type || type === 'array')\n      ? obj.cast\n      : type[0];\n\n    if (cast && cast.instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast, obj);\n    }\n    if (cast &&\n        cast[options.typeKey] &&\n        cast[options.typeKey].instanceOfSchema) {\n      return new MongooseTypes.DocumentArray(path, cast[options.typeKey], obj, cast);\n    }\n\n    if (Array.isArray(cast)) {\n      return new MongooseTypes.Array(path, this.interpretAsType(path, cast, options), obj);\n    }\n\n    if (typeof cast === 'string') {\n      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];\n    } else if (cast && (!cast[options.typeKey] || (options.typeKey === 'type' && cast.type.type))\n        && utils.getFunctionName(cast.constructor) === 'Object') {\n      if (Object.keys(cast).length) {\n        // The `minimize` and `typeKey` options propagate to child schemas\n        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.\n        // See gh-3560\n        const childSchemaOptions = {minimize: options.minimize};\n        if (options.typeKey) {\n          childSchemaOptions.typeKey = options.typeKey;\n        }\n        //propagate 'strict' option to child schema\n        if (options.hasOwnProperty('strict')) {\n          childSchemaOptions.strict = options.strict;\n        }\n        const childSchema = new Schema(cast, childSchemaOptions);\n        childSchema.$implicitlyCreated = true;\n        return new MongooseTypes.DocumentArray(path, childSchema, obj);\n      } else {\n        // Special case: empty object becomes mixed\n        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);\n      }\n    }\n\n    if (cast) {\n      type = cast[options.typeKey] && (options.typeKey !== 'type' || !cast.type.type)\n        ? cast[options.typeKey]\n        : cast;\n\n      name = typeof type === 'string'\n        ? type\n        : type.schemaName || utils.getFunctionName(type);\n\n      if (!(name in MongooseTypes)) {\n        throw new TypeError('Undefined type `' + name + '` at array `' + path +\n          '`');\n      }\n    }\n\n    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);\n  }\n\n  if (type && type.instanceOfSchema) {\n    return new MongooseTypes.Embedded(type, path, obj);\n  }\n\n  if (Buffer.isBuffer(type)) {\n    name = 'Buffer';\n  } else {\n    name = typeof type === 'string'\n      ? type\n      // If not string, `type` is a function. Outside of IE, function.name\n      // gives you the function name. In IE, you need to compute it\n      : type.schemaName || utils.getFunctionName(type);\n  }\n\n  if (name) {\n    name = name.charAt(0).toUpperCase() + name.substring(1);\n  }\n  // Special case re: gh-7049 because the bson `ObjectID` class' capitalization\n  // doesn't line up with Mongoose's.\n  if (name === 'ObjectID') {\n    name = 'ObjectId';\n  }\n\n  if (undefined == MongooseTypes[name]) {\n    throw new TypeError('Undefined type `' + name + '` at `' + path +\n        '`\\n  Did you try nesting Schemas? ' +\n        'You can only nest using refs or arrays.');\n  }\n\n  return new MongooseTypes[name](path, obj);\n};\n\n/**\n * Iterates the schemas paths similar to Array#forEach.\n *\n * The callback is passed the pathname and schemaType as arguments on each iteration.\n *\n * @param {Function} fn callback function\n * @return {Schema} this\n * @api public\n */\n\nSchema.prototype.eachPath = function(fn) {\n  const keys = Object.keys(this.paths);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    fn(keys[i], this.paths[keys[i]]);\n  }\n\n  return this;\n};\n\n/**\n * Returns an Array of path strings that are required by this schema.\n *\n * @api public\n * @param {Boolean} invalidate refresh the cache\n * @return {Array}\n */\n\nSchema.prototype.requiredPaths = function requiredPaths(invalidate) {\n  if (this._requiredpaths && !invalidate) {\n    return this._requiredpaths;\n  }\n\n  const paths = Object.keys(this.paths);\n  let i = paths.length;\n  const ret = [];\n\n  while (i--) {\n    const path = paths[i];\n    if (this.paths[path].isRequired) {\n      ret.push(path);\n    }\n  }\n  this._requiredpaths = ret;\n  return this._requiredpaths;\n};\n\n/**\n * Returns indexes from fields and schema-level indexes (cached).\n *\n * @api private\n * @return {Array}\n */\n\nSchema.prototype.indexedPaths = function indexedPaths() {\n  if (this._indexedpaths) {\n    return this._indexedpaths;\n  }\n  this._indexedpaths = this.indexes();\n  return this._indexedpaths;\n};\n\n/**\n * Returns the pathType of `path` for this schema.\n *\n * Given a path, returns whether it is a real, virtual, nested, or ad-hoc/undefined path.\n *\n * @param {String} path\n * @return {String}\n * @api public\n */\n\nSchema.prototype.pathType = function(path) {\n  if (path in this.paths) {\n    return 'real';\n  }\n  if (path in this.virtuals) {\n    return 'virtual';\n  }\n  if (path in this.nested) {\n    return 'nested';\n  }\n  if (path in this.subpaths) {\n    return 'real';\n  }\n  if (path in this.singleNestedPaths) {\n    return 'real';\n  }\n\n  // Look for maps\n  for (const _path of Object.keys(this.paths)) {\n    if (!_path.includes('.$*')) {\n      continue;\n    }\n    const re = new RegExp('^' + _path.replace(/\\.\\$\\*/g, '.[^.]+') + '$');\n    if (re.test(path)) {\n      return this.paths[_path];\n    }\n  }\n\n  if (/\\.\\d+\\.|\\.\\d+$/.test(path)) {\n    return getPositionalPathType(this, path);\n  }\n  return 'adhocOrUndefined';\n};\n\n/**\n * Returns true iff this path is a child of a mixed schema.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nSchema.prototype.hasMixedParent = function(path) {\n  const subpaths = path.split(/\\./g);\n  path = '';\n  for (let i = 0; i < subpaths.length; ++i) {\n    path = i > 0 ? path + '.' + subpaths[i] : subpaths[i];\n    if (path in this.paths &&\n        this.paths[path] instanceof MongooseTypes.Mixed) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/**\n * Setup updatedAt and createdAt timestamps to documents if enabled\n *\n * @param {Boolean|Object} timestamps timestamps options\n * @api private\n */\nSchema.prototype.setupTimestamp = function(timestamps) {\n  const childHasTimestamp = this.childSchemas.find(withTimestamp);\n\n  function withTimestamp(s) {\n    const ts = s.schema.options.timestamps;\n    return ts == true || ts == null;\n  }\n\n  if (!timestamps && !childHasTimestamp) {\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  const schemaAdditions = {};\n\n  this.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };\n\n  if (updatedAt && !this.paths[updatedAt]) {\n    schemaAdditions[updatedAt] = Date;\n  }\n\n  if (createdAt && !this.paths[createdAt]) {\n    schemaAdditions[createdAt] = Date;\n  }\n\n  this.add(schemaAdditions);\n\n  this.pre('save', function(next) {\n    const defaultTimestamp = (this.ownerDocument ? this.ownerDocument() : this).\n      constructor.base.now();\n    const auto_id = this._id && this._id.auto;\n\n    if (createdAt && !this.get(createdAt) && this.isSelected(createdAt)) {\n      this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);\n    }\n\n    if (updatedAt && (this.isNew || this.isModified())) {\n      let ts = defaultTimestamp;\n      if (this.isNew) {\n        if (createdAt != null) {\n          ts = this.get(createdAt);\n        } else if (auto_id) {\n          ts = this._id.getTimestamp();\n        }\n      }\n      this.set(updatedAt, ts);\n    }\n\n    next();\n  });\n\n  this.methods.initializeTimestamps = function() {\n    if (createdAt && !this.get(createdAt)) {\n      this.set(createdAt, new Date());\n    }\n    if (updatedAt && !this.get(updatedAt)) {\n      this.set(updatedAt, new Date());\n    }\n    return this;\n  };\n\n  this.pre('findOneAndUpdate', _setTimestampsOnUpdate);\n  this.pre('replaceOne', _setTimestampsOnUpdate);\n  this.pre('update', _setTimestampsOnUpdate);\n  this.pre('updateOne', _setTimestampsOnUpdate);\n  this.pre('updateMany', _setTimestampsOnUpdate);\n\n  function _setTimestampsOnUpdate(next) {\n    const now = this.model.base.now();\n    applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(),\n      this.options, this.schema);\n    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);\n    next();\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction getPositionalPathType(self, path) {\n  const subpaths = path.split(/\\.(\\d+)\\.|\\.(\\d+)$/).filter(Boolean);\n  if (subpaths.length < 2) {\n    return self.paths[subpaths[0]];\n  }\n\n  let val = self.path(subpaths[0]);\n  let isNested = false;\n  if (!val) {\n    return val;\n  }\n\n  const last = subpaths.length - 1;\n  let subpath;\n  let i = 1;\n\n  for (; i < subpaths.length; ++i) {\n    isNested = false;\n    subpath = subpaths[i];\n\n    if (i === last && val && !/\\D/.test(subpath)) {\n      if (val.$isMongooseDocumentArray) {\n        const oldVal = val;\n        val = new SchemaType(subpath, {\n          required: get(val, 'schemaOptions.required', false)\n        });\n        val.cast = function(value, doc, init) {\n          return oldVal.cast(value, doc, init)[0];\n        };\n        val.$isMongooseDocumentArrayElement = true;\n        val.caster = oldVal.caster;\n        val.schema = oldVal.schema;\n      } else if (val instanceof MongooseTypes.Array) {\n        // StringSchema, NumberSchema, etc\n        val = val.caster;\n      } else {\n        val = undefined;\n      }\n      break;\n    }\n\n    // ignore if its just a position segment: path.0.subpath\n    if (!/\\D/.test(subpath)) {\n      continue;\n    }\n\n    if (!(val && val.schema)) {\n      val = undefined;\n      break;\n    }\n\n    const type = val.schema.pathType(subpath);\n    isNested = (type === 'nested');\n    val = val.schema.path(subpath);\n  }\n\n  self.subpaths[path] = val;\n  if (val) {\n    return 'real';\n  }\n  if (isNested) {\n    return 'nested';\n  }\n  return 'adhocOrUndefined';\n}\n\n\n/*!\n * ignore\n */\n\nfunction getPositionalPath(self, path) {\n  getPositionalPathType(self, path);\n  return self.subpaths[path];\n}\n\n/**\n * Adds a method call to the queue.\n *\n * @param {String} name name of the document method to call later\n * @param {Array} args arguments to pass to the method\n * @api public\n */\n\nSchema.prototype.queue = function(name, args) {\n  this.callQueue.push([name, args]);\n  return this;\n};\n\n/**\n * Defines a pre hook for the document.\n *\n * ####Example\n *\n *     var toySchema = new Schema({ name: String, created: Date });\n *\n *     toySchema.pre('save', function(next) {\n *       if (!this.created) this.created = new Date;\n *       next();\n *     });\n *\n *     toySchema.pre('validate', function(next) {\n *       if (this.name !== 'Woody') this.name = 'Woody';\n *       next();\n *     });\n *\n *     // Equivalent to calling `pre()` on `find`, `findOne`, `findOneAndUpdate`.\n *     toySchema.pre(/^find/, function(next) {\n *       console.log(this.getQuery());\n *     });\n *\n * @param {String|RegExp} method or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} callback\n * @see hooks.js https://github.com/bnoguchi/hooks-js/tree/31ec571cef0332e21121ee7157e0cf9728572cc3\n * @api public\n */\n\nSchema.prototype.pre = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of allMiddleware) {\n      if (name.test(fn)) {\n        this.pre.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  this.s.hooks.pre.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Defines a post hook for the document\n *\n *     var schema = new Schema(..);\n *     schema.post('save', function (doc) {\n *       console.log('this fired after a document was saved');\n *     });\n *\n *     schema.post('find', function(docs) {\n *       console.log('this fired after you ran a find query');\n *     });\n *\n *     schema.post(/Many$/, function(res) {\n *       console.log('this fired after you ran `updateMany()` or `deleteMany()`);\n *     });\n *\n *     var Model = mongoose.model('Model', schema);\n *\n *     var m = new Model(..);\n *     m.save(function(err) {\n *       console.log('this fires after the `post` hook');\n *     });\n *\n *     m.find(function(err, docs) {\n *       console.log('this fires after the post find hook');\n *     });\n *\n * @param {String|RegExp} method or regular expression to match method name\n * @param {Object} [options]\n * @param {Boolean} [options.document] If `name` is a hook for both document and query middleware, set to `true` to run on document middleware.\n * @param {Boolean} [options.query] If `name` is a hook for both document and query middleware, set to `true` to run on query middleware.\n * @param {Function} fn callback\n * @see middleware http://mongoosejs.com/docs/middleware.html\n * @see kareem http://npmjs.org/package/kareem\n * @api public\n */\n\nSchema.prototype.post = function(name) {\n  if (name instanceof RegExp) {\n    const remainingArgs = Array.prototype.slice.call(arguments, 1);\n    for (const fn of allMiddleware) {\n      if (name.test(fn)) {\n        this.post.apply(this, [fn].concat(remainingArgs));\n      }\n    }\n    return this;\n  }\n  this.s.hooks.post.apply(this.s.hooks, arguments);\n  return this;\n};\n\n/**\n * Registers a plugin for this schema.\n *\n * @param {Function} plugin callback\n * @param {Object} [opts]\n * @see plugins\n * @api public\n */\n\nSchema.prototype.plugin = function(fn, opts) {\n  if (typeof fn !== 'function') {\n    throw new Error('First param to `schema.plugin()` must be a function, ' +\n      'got \"' + (typeof fn) + '\"');\n  }\n\n  if (opts &&\n      opts.deduplicate) {\n    for (let i = 0; i < this.plugins.length; ++i) {\n      if (this.plugins[i].fn === fn) {\n        return this;\n      }\n    }\n  }\n  this.plugins.push({ fn: fn, opts: opts });\n\n  fn(this, opts);\n  return this;\n};\n\n/**\n * Adds an instance method to documents constructed from Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = kittySchema = new Schema(..);\n *\n *     schema.method('meow', function () {\n *       console.log('meeeeeoooooooooooow');\n *     })\n *\n *     var Kitty = mongoose.model('Kitty', schema);\n *\n *     var fizz = new Kitty;\n *     fizz.meow(); // meeeeeooooooooooooow\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as methods.\n *\n *     schema.method({\n *         purr: function () {}\n *       , scratch: function () {}\n *     });\n *\n *     // later\n *     fizz.purr();\n *     fizz.scratch();\n *\n * NOTE: `Schema.method()` adds instance methods to the `Schema.methods` object. You can also add instance methods directly to the `Schema.methods` object as seen in the [guide](./guide.html#methods)\n *\n * @param {String|Object} method name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.method = function(name, fn, options) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.methods[i] = name[i];\n      this.methodOptions[i] = utils.clone(options);\n    }\n  } else {\n    this.methods[name] = fn;\n    this.methodOptions[name] = utils.clone(options);\n  }\n  return this;\n};\n\n/**\n * Adds static \"class\" methods to Models compiled from this schema.\n *\n * ####Example\n *\n *     var schema = new Schema(..);\n *     schema.static('findByName', function (name, callback) {\n *       return this.find({ name: name }, callback);\n *     });\n *\n *     var Drink = mongoose.model('Drink', schema);\n *     Drink.findByName('sanpellegrino', function (err, drinks) {\n *       //\n *     });\n *\n * If a hash of name/fn pairs is passed as the only argument, each name/fn pair will be added as statics.\n *\n * @param {String|Object} name\n * @param {Function} [fn]\n * @api public\n */\n\nSchema.prototype.static = function(name, fn) {\n  if (typeof name !== 'string') {\n    for (const i in name) {\n      this.statics[i] = name[i];\n    }\n  } else {\n    this.statics[name] = fn;\n  }\n  return this;\n};\n\n/**\n * Defines an index (most likely compound) for this schema.\n *\n * ####Example\n *\n *     schema.index({ first: 1, last: -1 })\n *\n * @param {Object} fields\n * @param {Object} [options] Options to pass to [MongoDB driver's `createIndex()` function](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#createIndex)\n * @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert `expires` option into seconds for the `expireAfterSeconds` in the above link.\n * @api public\n */\n\nSchema.prototype.index = function(fields, options) {\n  fields || (fields = {});\n  options || (options = {});\n\n  if (options.expires) {\n    utils.expires(options);\n  }\n\n  this._indexes.push([fields, options]);\n  return this;\n};\n\n/**\n * Sets/gets a schema option.\n *\n * ####Example\n *\n *     schema.set('strict'); // 'true' by default\n *     schema.set('strict', false); // Sets 'strict' to false\n *     schema.set('strict'); // 'false'\n *\n * @param {String} key option name\n * @param {Object} [value] if not passed, the current option value is returned\n * @see Schema ./\n * @api public\n */\n\nSchema.prototype.set = function(key, value, _tags) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  switch (key) {\n    case 'read':\n      this.options[key] = readPref(value, _tags);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'safe':\n      setSafe(this.options, value);\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    case 'timestamps':\n      this.setupTimestamp(value);\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n    default:\n      this.options[key] = value;\n      this._userProvidedOptions[key] = this.options[key];\n      break;\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nconst safeDeprecationWarning = 'Mongoose: The `safe` option for schemas is ' +\n  'deprecated. Use the `writeConcern` option instead: ' +\n  'http://bit.ly/mongoose-write-concern';\n\nconst setSafe = util.deprecate(function setSafe(options, value) {\n  options.safe = value === false ?\n    {w: 0} :\n    value;\n}, safeDeprecationWarning);\n\n/**\n * Gets a schema option.\n *\n * @param {String} key option name\n * @api public\n */\n\nSchema.prototype.get = function(key) {\n  return this.options[key];\n};\n\n/**\n * The allowed index types\n *\n * @receiver Schema\n * @static indexTypes\n * @api public\n */\n\nconst indexTypes = '2d 2dsphere hashed text'.split(' ');\n\nObject.defineProperty(Schema, 'indexTypes', {\n  get: function() {\n    return indexTypes;\n  },\n  set: function() {\n    throw new Error('Cannot overwrite Schema.indexTypes');\n  }\n});\n\n/**\n * Returns a list of indexes that this schema declares, via `schema.index()`\n * or by `index: true` in a path's options.\n *\n * @api public\n */\n\nSchema.prototype.indexes = function() {\n  return getIndexes(this);\n};\n\n/**\n * Creates a virtual type with the given name.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {VirtualType}\n */\n\nSchema.prototype.virtual = function(name, options) {\n  if (options && options.ref) {\n    if (!options.localField) {\n      throw new Error('Reference virtuals require `localField` option');\n    }\n\n    if (!options.foreignField) {\n      throw new Error('Reference virtuals require `foreignField` option');\n    }\n\n    this.pre('init', function(obj) {\n      if (mpath.has(name, obj)) {\n        const _v = mpath.get(name, obj);\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n        }\n\n        mpath.unset(name, obj);\n      }\n    });\n\n    const virtual = this.virtual(name);\n    virtual.options = options;\n    return virtual.\n      get(function() {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n        if (name in this.$$populatedVirtuals) {\n          return this.$$populatedVirtuals[name];\n        }\n        return null;\n      }).\n      set(function(_v) {\n        if (!this.$$populatedVirtuals) {\n          this.$$populatedVirtuals = {};\n        }\n\n        if (options.justOne) {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v[0] :\n            _v;\n\n          if (typeof this.$$populatedVirtuals[name] !== 'object') {\n            this.$$populatedVirtuals[name] = null;\n          }\n        } else {\n          this.$$populatedVirtuals[name] = Array.isArray(_v) ?\n            _v :\n            _v == null ? [] : [_v];\n\n          this.$$populatedVirtuals[name] = this.$$populatedVirtuals[name].filter(function(doc) {\n            return doc && typeof doc === 'object';\n          });\n        }\n      });\n  }\n\n  const virtuals = this.virtuals;\n  const parts = name.split('.');\n\n  if (this.pathType(name) === 'real') {\n    throw new Error('Virtual path \"' + name + '\"' +\n      ' conflicts with a real path in the schema');\n  }\n\n  virtuals[name] = parts.reduce(function(mem, part, i) {\n    mem[part] || (mem[part] = (i === parts.length - 1)\n      ? new VirtualType(options, name)\n      : {});\n    return mem[part];\n  }, this.tree);\n\n  return virtuals[name];\n};\n\n/**\n * Returns the virtual type with the given `name`.\n *\n * @param {String} name\n * @return {VirtualType}\n */\n\nSchema.prototype.virtualpath = function(name) {\n  return this.virtuals[name];\n};\n\n/**\n * Removes the given `path` (or [`paths`]).\n *\n * @param {String|Array} path\n * @return {Schema} the Schema instance\n * @api public\n */\nSchema.prototype.remove = function(path) {\n  if (typeof path === 'string') {\n    path = [path];\n  }\n  if (Array.isArray(path)) {\n    path.forEach(function(name) {\n      if (this.path(name)) {\n        delete this.paths[name];\n\n        const pieces = name.split('.');\n        const last = pieces.pop();\n        let branch = this.tree;\n        for (let i = 0; i < pieces.length; ++i) {\n          branch = branch[pieces[i]];\n        }\n        delete branch[last];\n      }\n    }, this);\n  }\n  return this;\n};\n\n/**\n * Loads an ES6 class into a schema. Maps [setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) + [getters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get), [static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static),\n * and [instance methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Class_body_and_method_definitions)\n * to schema [virtuals](http://mongoosejs.com/docs/guide.html#virtuals),\n * [statics](http://mongoosejs.com/docs/guide.html#statics), and\n * [methods](http://mongoosejs.com/docs/guide.html#methods).\n *\n * ####Example:\n *\n * ```javascript\n * const md5 = require('md5');\n * const userSchema = new Schema({ email: String });\n * class UserClass {\n *   // `gravatarImage` becomes a virtual\n *   get gravatarImage() {\n *     const hash = md5(this.email.toLowerCase());\n *     return `https://www.gravatar.com/avatar/${hash}`;\n *   }\n *\n *   // `getProfileUrl()` becomes a document method\n *   getProfileUrl() {\n *     return `https://mysite.com/${this.email}`;\n *   }\n *\n *   // `findByEmail()` becomes a static\n *   static findByEmail(email) {\n *     return this.findOne({ email });\n *   }\n * }\n *\n * // `schema` will now have a `gravatarImage` virtual, a `getProfileUrl()` method,\n * // and a `findByEmail()` static\n * userSchema.loadClass(UserClass);\n * ```\n *\n * @param {Function} model\n * @param {Boolean} [virtualsOnly] if truthy, only pulls virtuals from the class, not methods or statics\n */\nSchema.prototype.loadClass = function(model, virtualsOnly) {\n  if (model === Object.prototype ||\n      model === Function.prototype ||\n      model.prototype.hasOwnProperty('$isMongooseModelPrototype')) {\n    return this;\n  }\n\n  this.loadClass(Object.getPrototypeOf(model));\n\n  // Add static methods\n  if (!virtualsOnly) {\n    Object.getOwnPropertyNames(model).forEach(function(name) {\n      if (name.match(/^(length|name|prototype)$/)) {\n        return;\n      }\n      const method = Object.getOwnPropertyDescriptor(model, name);\n      if (typeof method.value === 'function') {\n        this.static(name, method.value);\n      }\n    }, this);\n  }\n\n  // Add methods and virtuals\n  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {\n    if (name.match(/^(constructor)$/)) {\n      return;\n    }\n    const method = Object.getOwnPropertyDescriptor(model.prototype, name);\n    if (!virtualsOnly) {\n      if (typeof method.value === 'function') {\n        this.method(name, method.value);\n      }\n    }\n    if (typeof method.get === 'function') {\n      this.virtual(name).get(method.get);\n    }\n    if (typeof method.set === 'function') {\n      this.virtual(name).set(method.set);\n    }\n  }, this);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getSchema = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n  const resultPath = [];\n\n  if (pathschema) {\n    pathschema.$fullPath = path;\n    return pathschema;\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        resultPath.push(trypath);\n\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            foundschema.caster.$fullPath = resultPath.join('.');\n            return foundschema.caster;\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            let ret;\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p + 1 === parts.length) {\n                // comments.$\n                return foundschema;\n              }\n              // comments.$.comments.$.title\n              ret = search(parts.slice(p + 1), foundschema.schema);\n              if (ret) {\n                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n              }\n              return ret;\n            }\n            // this is the last path of the selector\n            ret = search(parts.slice(p), foundschema.schema);\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n        }\n\n        foundschema.$fullPath = resultPath.join('.');\n\n        return foundschema;\n      }\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$' || isArrayFilter(parts[i])) {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, _this);\n};\n\n/*!\n * ignore\n */\n\nSchema.prototype._getPathType = function(path) {\n  const _this = this;\n  const pathschema = _this.path(path);\n\n  if (pathschema) {\n    return 'real';\n  }\n\n  function search(parts, schema) {\n    let p = parts.length + 1,\n        foundschema,\n        trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema) {\n        if (foundschema.caster) {\n          // array of Mixed?\n          if (foundschema.caster instanceof MongooseTypes.Mixed) {\n            return { schema: foundschema, pathType: 'mixed' };\n          }\n\n          // Now that we found the array, we need to check if there\n          // are remaining document paths to look up for casting.\n          // Also we need to handle array.$.path since schema.path\n          // doesn't work for that.\n          // If there is no foundschema.schema we are dealing with\n          // a path like array.$\n          if (p !== parts.length && foundschema.schema) {\n            if (parts[p] === '$' || isArrayFilter(parts[p])) {\n              if (p === parts.length - 1) {\n                return { schema: foundschema, pathType: 'nested' };\n              }\n              // comments.$.comments.$.title\n              return search(parts.slice(p + 1), foundschema.schema);\n            }\n            // this is the last path of the selector\n            return search(parts.slice(p), foundschema.schema);\n          }\n          return {\n            schema: foundschema,\n            pathType: foundschema.$isSingleNested ? 'nested' : 'array'\n          };\n        }\n        return { schema: foundschema, pathType: 'real' };\n      } else if (p === parts.length && schema.nested[trypath]) {\n        return { schema: schema, pathType: 'nested' };\n      }\n    }\n    return { schema: foundschema || schema, pathType: 'undefined' };\n  }\n\n  // look for arrays\n  return search(path.split('.'), _this);\n};\n\n/*!\n * ignore\n */\n\nfunction isArrayFilter(piece) {\n  return piece.indexOf('$[') === 0 &&\n    piece.lastIndexOf(']') === piece.length - 1;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Schema;\n\n// require down here because of reference issues\n\n/**\n * The various built-in Mongoose Schema Types.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var ObjectId = mongoose.Schema.Types.ObjectId;\n *\n * ####Types:\n *\n * - [String](#schema-string-js)\n * - [Number](#schema-number-js)\n * - [Boolean](#schema-boolean-js) | Bool\n * - [Array](#schema-array-js)\n * - [Buffer](#schema-buffer-js)\n * - [Date](#schema-date-js)\n * - [ObjectId](#schema-objectid-js) | Oid\n * - [Mixed](#schema-mixed-js)\n *\n * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.\n *\n *     var Mixed = mongoose.Schema.Types.Mixed;\n *     new mongoose.Schema({ _user: Mixed })\n *\n * @api public\n */\n\nSchema.Types = MongooseTypes = require('./schema/index');\n\n/*!\n * ignore\n */\n\nexports.ObjectId = MongooseTypes.ObjectId;\n","'use strict';\n\n/*!\n * Module requirements.\n */\n\nconst Types = {\n  Number: require('../number')\n};\n\n/*!\n * @ignore\n */\n\nexports.castToNumber = castToNumber;\nexports.castArraysOfNumbers = castArraysOfNumbers;\n\n/*!\n * @ignore\n */\n\nfunction castToNumber(val) {\n  return Types.Number.prototype.cast.call(this, val);\n}\n\nfunction castArraysOfNumbers(arr, self) {\n  arr.forEach(function(v, i) {\n    if (Array.isArray(v)) {\n      castArraysOfNumbers(v, self);\n    } else {\n      arr[i] = castToNumber.call(self, v);\n    }\n  });\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\nmodule.exports = require('./lib/express');\n","/*!\n * methods\n * Copyright(c) 2013-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar http = require('http');\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getCurrentNodeMethods() || getBasicNodeMethods();\n\n/**\n * Get the current Node.js methods.\n * @private\n */\n\nfunction getCurrentNodeMethods() {\n  return http.METHODS && http.METHODS.map(function lowerCaseMethod(method) {\n    return method.toLowerCase();\n  });\n}\n\n/**\n * Get the \"basic\" Node.js methods, a snapshot from Node.js 0.10.\n * @private\n */\n\nfunction getBasicNodeMethods() {\n  return [\n    'get',\n    'post',\n    'put',\n    'head',\n    'delete',\n    'options',\n    'trace',\n    'copy',\n    'lock',\n    'mkcol',\n    'move',\n    'purge',\n    'propfind',\n    'proppatch',\n    'unlock',\n    'report',\n    'mkactivity',\n    'checkout',\n    'merge',\n    'm-search',\n    'notify',\n    'subscribe',\n    'unsubscribe',\n    'patch',\n    'search',\n    'connect'\n  ];\n}\n","/*!\n * send\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar createError = require('http-errors')\nvar debug = require('debug')('send')\nvar deprecate = require('depd')('send')\nvar destroy = require('destroy')\nvar encodeUrl = require('encodeurl')\nvar escapeHtml = require('escape-html')\nvar etag = require('etag')\nvar fresh = require('fresh')\nvar fs = require('fs')\nvar mime = require('mime')\nvar ms = require('ms')\nvar onFinished = require('on-finished')\nvar parseRange = require('range-parser')\nvar path = require('path')\nvar statuses = require('statuses')\nvar Stream = require('stream')\nvar util = require('util')\n\n/**\n * Path function references.\n * @private\n */\n\nvar extname = path.extname\nvar join = path.join\nvar normalize = path.normalize\nvar resolve = path.resolve\nvar sep = path.sep\n\n/**\n * Regular expression for identifying a bytes Range header.\n * @private\n */\n\nvar BYTES_RANGE_REGEXP = /^ *bytes=/\n\n/**\n * Maximum value allowed for the max age.\n * @private\n */\n\nvar MAX_MAXAGE = 60 * 60 * 24 * 365 * 1000 // 1 year\n\n/**\n * Regular expression to match a path with a directory up component.\n * @private\n */\n\nvar UP_PATH_REGEXP = /(?:^|[\\\\/])\\.\\.(?:[\\\\/]|$)/\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = send\nmodule.exports.mime = mime\n\n/**\n * Return a `SendStream` for `req` and `path`.\n *\n * @param {object} req\n * @param {string} path\n * @param {object} [options]\n * @return {SendStream}\n * @public\n */\n\nfunction send (req, path, options) {\n  return new SendStream(req, path, options)\n}\n\n/**\n * Initialize a `SendStream` with the given `path`.\n *\n * @param {Request} req\n * @param {String} path\n * @param {object} [options]\n * @private\n */\n\nfunction SendStream (req, path, options) {\n  Stream.call(this)\n\n  var opts = options || {}\n\n  this.options = opts\n  this.path = path\n  this.req = req\n\n  this._acceptRanges = opts.acceptRanges !== undefined\n    ? Boolean(opts.acceptRanges)\n    : true\n\n  this._cacheControl = opts.cacheControl !== undefined\n    ? Boolean(opts.cacheControl)\n    : true\n\n  this._etag = opts.etag !== undefined\n    ? Boolean(opts.etag)\n    : true\n\n  this._dotfiles = opts.dotfiles !== undefined\n    ? opts.dotfiles\n    : 'ignore'\n\n  if (this._dotfiles !== 'ignore' && this._dotfiles !== 'allow' && this._dotfiles !== 'deny') {\n    throw new TypeError('dotfiles option must be \"allow\", \"deny\", or \"ignore\"')\n  }\n\n  this._hidden = Boolean(opts.hidden)\n\n  if (opts.hidden !== undefined) {\n    deprecate('hidden: use dotfiles: \\'' + (this._hidden ? 'allow' : 'ignore') + '\\' instead')\n  }\n\n  // legacy support\n  if (opts.dotfiles === undefined) {\n    this._dotfiles = undefined\n  }\n\n  this._extensions = opts.extensions !== undefined\n    ? normalizeList(opts.extensions, 'extensions option')\n    : []\n\n  this._immutable = opts.immutable !== undefined\n    ? Boolean(opts.immutable)\n    : false\n\n  this._index = opts.index !== undefined\n    ? normalizeList(opts.index, 'index option')\n    : ['index.html']\n\n  this._lastModified = opts.lastModified !== undefined\n    ? Boolean(opts.lastModified)\n    : true\n\n  this._maxage = opts.maxAge || opts.maxage\n  this._maxage = typeof this._maxage === 'string'\n    ? ms(this._maxage)\n    : Number(this._maxage)\n  this._maxage = !isNaN(this._maxage)\n    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)\n    : 0\n\n  this._root = opts.root\n    ? resolve(opts.root)\n    : null\n\n  if (!this._root && opts.from) {\n    this.from(opts.from)\n  }\n}\n\n/**\n * Inherits from `Stream`.\n */\n\nutil.inherits(SendStream, Stream)\n\n/**\n * Enable or disable etag generation.\n *\n * @param {Boolean} val\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.etag = deprecate.function(function etag (val) {\n  this._etag = Boolean(val)\n  debug('etag %s', this._etag)\n  return this\n}, 'send.etag: pass etag as option')\n\n/**\n * Enable or disable \"hidden\" (dot) files.\n *\n * @param {Boolean} path\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.hidden = deprecate.function(function hidden (val) {\n  this._hidden = Boolean(val)\n  this._dotfiles = undefined\n  debug('hidden %s', this._hidden)\n  return this\n}, 'send.hidden: use dotfiles option')\n\n/**\n * Set index `paths`, set to a falsy\n * value to disable index support.\n *\n * @param {String|Boolean|Array} paths\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.index = deprecate.function(function index (paths) {\n  var index = !paths ? [] : normalizeList(paths, 'paths argument')\n  debug('index %o', paths)\n  this._index = index\n  return this\n}, 'send.index: pass index as option')\n\n/**\n * Set root `path`.\n *\n * @param {String} path\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.root = function root (path) {\n  this._root = resolve(String(path))\n  debug('root %s', this._root)\n  return this\n}\n\nSendStream.prototype.from = deprecate.function(SendStream.prototype.root,\n  'send.from: pass root as option')\n\nSendStream.prototype.root = deprecate.function(SendStream.prototype.root,\n  'send.root: pass root as option')\n\n/**\n * Set max-age to `maxAge`.\n *\n * @param {Number} maxAge\n * @return {SendStream}\n * @api public\n */\n\nSendStream.prototype.maxage = deprecate.function(function maxage (maxAge) {\n  this._maxage = typeof maxAge === 'string'\n    ? ms(maxAge)\n    : Number(maxAge)\n  this._maxage = !isNaN(this._maxage)\n    ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE)\n    : 0\n  debug('max-age %d', this._maxage)\n  return this\n}, 'send.maxage: pass maxAge as option')\n\n/**\n * Emit error with `status`.\n *\n * @param {number} status\n * @param {Error} [err]\n * @private\n */\n\nSendStream.prototype.error = function error (status, err) {\n  // emit if listeners instead of responding\n  if (hasListeners(this, 'error')) {\n    return this.emit('error', createError(status, err, {\n      expose: false\n    }))\n  }\n\n  var res = this.res\n  var msg = statuses[status] || String(status)\n  var doc = createHtmlDocument('Error', escapeHtml(msg))\n\n  // clear existing headers\n  clearHeaders(res)\n\n  // add error headers\n  if (err && err.headers) {\n    setHeaders(res, err.headers)\n  }\n\n  // send basic response\n  res.statusCode = status\n  res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n  res.setHeader('Content-Length', Buffer.byteLength(doc))\n  res.setHeader('Content-Security-Policy', \"default-src 'self'\")\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.end(doc)\n}\n\n/**\n * Check if the pathname ends with \"/\".\n *\n * @return {boolean}\n * @private\n */\n\nSendStream.prototype.hasTrailingSlash = function hasTrailingSlash () {\n  return this.path[this.path.length - 1] === '/'\n}\n\n/**\n * Check if this is a conditional GET request.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isConditionalGET = function isConditionalGET () {\n  return this.req.headers['if-match'] ||\n    this.req.headers['if-unmodified-since'] ||\n    this.req.headers['if-none-match'] ||\n    this.req.headers['if-modified-since']\n}\n\n/**\n * Check if the request preconditions failed.\n *\n * @return {boolean}\n * @private\n */\n\nSendStream.prototype.isPreconditionFailure = function isPreconditionFailure () {\n  var req = this.req\n  var res = this.res\n\n  // if-match\n  var match = req.headers['if-match']\n  if (match) {\n    var etag = res.getHeader('ETag')\n    return !etag || (match !== '*' && parseTokenList(match).every(function (match) {\n      return match !== etag && match !== 'W/' + etag && 'W/' + match !== etag\n    }))\n  }\n\n  // if-unmodified-since\n  var unmodifiedSince = parseHttpDate(req.headers['if-unmodified-since'])\n  if (!isNaN(unmodifiedSince)) {\n    var lastModified = parseHttpDate(res.getHeader('Last-Modified'))\n    return isNaN(lastModified) || lastModified > unmodifiedSince\n  }\n\n  return false\n}\n\n/**\n * Strip content-* header fields.\n *\n * @private\n */\n\nSendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields () {\n  var res = this.res\n  var headers = getHeaderNames(res)\n\n  for (var i = 0; i < headers.length; i++) {\n    var header = headers[i]\n    if (header.substr(0, 8) === 'content-' && header !== 'content-location') {\n      res.removeHeader(header)\n    }\n  }\n}\n\n/**\n * Respond with 304 not modified.\n *\n * @api private\n */\n\nSendStream.prototype.notModified = function notModified () {\n  var res = this.res\n  debug('not modified')\n  this.removeContentHeaderFields()\n  res.statusCode = 304\n  res.end()\n}\n\n/**\n * Raise error that headers already sent.\n *\n * @api private\n */\n\nSendStream.prototype.headersAlreadySent = function headersAlreadySent () {\n  var err = new Error('Can\\'t set headers after they are sent.')\n  debug('headers already sent')\n  this.error(500, err)\n}\n\n/**\n * Check if the request is cacheable, aka\n * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isCachable = function isCachable () {\n  var statusCode = this.res.statusCode\n  return (statusCode >= 200 && statusCode < 300) ||\n    statusCode === 304\n}\n\n/**\n * Handle stat() error.\n *\n * @param {Error} error\n * @private\n */\n\nSendStream.prototype.onStatError = function onStatError (error) {\n  switch (error.code) {\n    case 'ENAMETOOLONG':\n    case 'ENOENT':\n    case 'ENOTDIR':\n      this.error(404, error)\n      break\n    default:\n      this.error(500, error)\n      break\n  }\n}\n\n/**\n * Check if the cache is fresh.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isFresh = function isFresh () {\n  return fresh(this.req.headers, {\n    'etag': this.res.getHeader('ETag'),\n    'last-modified': this.res.getHeader('Last-Modified')\n  })\n}\n\n/**\n * Check if the range is fresh.\n *\n * @return {Boolean}\n * @api private\n */\n\nSendStream.prototype.isRangeFresh = function isRangeFresh () {\n  var ifRange = this.req.headers['if-range']\n\n  if (!ifRange) {\n    return true\n  }\n\n  // if-range as etag\n  if (ifRange.indexOf('\"') !== -1) {\n    var etag = this.res.getHeader('ETag')\n    return Boolean(etag && ifRange.indexOf(etag) !== -1)\n  }\n\n  // if-range as modified date\n  var lastModified = this.res.getHeader('Last-Modified')\n  return parseHttpDate(lastModified) <= parseHttpDate(ifRange)\n}\n\n/**\n * Redirect to path.\n *\n * @param {string} path\n * @private\n */\n\nSendStream.prototype.redirect = function redirect (path) {\n  var res = this.res\n\n  if (hasListeners(this, 'directory')) {\n    this.emit('directory', res, path)\n    return\n  }\n\n  if (this.hasTrailingSlash()) {\n    this.error(403)\n    return\n  }\n\n  var loc = encodeUrl(collapseLeadingSlashes(this.path + '/'))\n  var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href=\"' + escapeHtml(loc) + '\">' +\n    escapeHtml(loc) + '</a>')\n\n  // redirect\n  res.statusCode = 301\n  res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n  res.setHeader('Content-Length', Buffer.byteLength(doc))\n  res.setHeader('Content-Security-Policy', \"default-src 'self'\")\n  res.setHeader('X-Content-Type-Options', 'nosniff')\n  res.setHeader('Location', loc)\n  res.end(doc)\n}\n\n/**\n * Pipe to `res.\n *\n * @param {Stream} res\n * @return {Stream} res\n * @api public\n */\n\nSendStream.prototype.pipe = function pipe (res) {\n  // root path\n  var root = this._root\n\n  // references\n  this.res = res\n\n  // decode the path\n  var path = decode(this.path)\n  if (path === -1) {\n    this.error(400)\n    return res\n  }\n\n  // null byte(s)\n  if (~path.indexOf('\\0')) {\n    this.error(400)\n    return res\n  }\n\n  var parts\n  if (root !== null) {\n    // normalize\n    if (path) {\n      path = normalize('.' + sep + path)\n    }\n\n    // malicious path\n    if (UP_PATH_REGEXP.test(path)) {\n      debug('malicious path \"%s\"', path)\n      this.error(403)\n      return res\n    }\n\n    // explode path parts\n    parts = path.split(sep)\n\n    // join / normalize from optional root dir\n    path = normalize(join(root, path))\n    root = normalize(root + sep)\n  } else {\n    // \"..\" is malicious without \"root\"\n    if (UP_PATH_REGEXP.test(path)) {\n      debug('malicious path \"%s\"', path)\n      this.error(403)\n      return res\n    }\n\n    // explode path parts\n    parts = normalize(path).split(sep)\n\n    // resolve the path\n    path = resolve(path)\n  }\n\n  // dotfile handling\n  if (containsDotFile(parts)) {\n    var access = this._dotfiles\n\n    // legacy support\n    if (access === undefined) {\n      access = parts[parts.length - 1][0] === '.'\n        ? (this._hidden ? 'allow' : 'ignore')\n        : 'allow'\n    }\n\n    debug('%s dotfile \"%s\"', access, path)\n    switch (access) {\n      case 'allow':\n        break\n      case 'deny':\n        this.error(403)\n        return res\n      case 'ignore':\n      default:\n        this.error(404)\n        return res\n    }\n  }\n\n  // index file support\n  if (this._index.length && this.hasTrailingSlash()) {\n    this.sendIndex(path)\n    return res\n  }\n\n  this.sendFile(path)\n  return res\n}\n\n/**\n * Transfer `path`.\n *\n * @param {String} path\n * @api public\n */\n\nSendStream.prototype.send = function send (path, stat) {\n  var len = stat.size\n  var options = this.options\n  var opts = {}\n  var res = this.res\n  var req = this.req\n  var ranges = req.headers.range\n  var offset = options.start || 0\n\n  if (headersSent(res)) {\n    // impossible to send now\n    this.headersAlreadySent()\n    return\n  }\n\n  debug('pipe \"%s\"', path)\n\n  // set header fields\n  this.setHeader(path, stat)\n\n  // set content-type\n  this.type(path)\n\n  // conditional GET support\n  if (this.isConditionalGET()) {\n    if (this.isPreconditionFailure()) {\n      this.error(412)\n      return\n    }\n\n    if (this.isCachable() && this.isFresh()) {\n      this.notModified()\n      return\n    }\n  }\n\n  // adjust len to start/end options\n  len = Math.max(0, len - offset)\n  if (options.end !== undefined) {\n    var bytes = options.end - offset + 1\n    if (len > bytes) len = bytes\n  }\n\n  // Range support\n  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {\n    // parse\n    ranges = parseRange(len, ranges, {\n      combine: true\n    })\n\n    // If-Range support\n    if (!this.isRangeFresh()) {\n      debug('range stale')\n      ranges = -2\n    }\n\n    // unsatisfiable\n    if (ranges === -1) {\n      debug('range unsatisfiable')\n\n      // Content-Range\n      res.setHeader('Content-Range', contentRange('bytes', len))\n\n      // 416 Requested Range Not Satisfiable\n      return this.error(416, {\n        headers: {'Content-Range': res.getHeader('Content-Range')}\n      })\n    }\n\n    // valid (syntactically invalid/multiple ranges are treated as a regular response)\n    if (ranges !== -2 && ranges.length === 1) {\n      debug('range %j', ranges)\n\n      // Content-Range\n      res.statusCode = 206\n      res.setHeader('Content-Range', contentRange('bytes', len, ranges[0]))\n\n      // adjust for requested range\n      offset += ranges[0].start\n      len = ranges[0].end - ranges[0].start + 1\n    }\n  }\n\n  // clone options\n  for (var prop in options) {\n    opts[prop] = options[prop]\n  }\n\n  // set read options\n  opts.start = offset\n  opts.end = Math.max(offset, offset + len - 1)\n\n  // content-length\n  res.setHeader('Content-Length', len)\n\n  // HEAD support\n  if (req.method === 'HEAD') {\n    res.end()\n    return\n  }\n\n  this.stream(path, opts)\n}\n\n/**\n * Transfer file for `path`.\n *\n * @param {String} path\n * @api private\n */\nSendStream.prototype.sendFile = function sendFile (path) {\n  var i = 0\n  var self = this\n\n  debug('stat \"%s\"', path)\n  fs.stat(path, function onstat (err, stat) {\n    if (err && err.code === 'ENOENT' && !extname(path) && path[path.length - 1] !== sep) {\n      // not found, check extensions\n      return next(err)\n    }\n    if (err) return self.onStatError(err)\n    if (stat.isDirectory()) return self.redirect(path)\n    self.emit('file', path, stat)\n    self.send(path, stat)\n  })\n\n  function next (err) {\n    if (self._extensions.length <= i) {\n      return err\n        ? self.onStatError(err)\n        : self.error(404)\n    }\n\n    var p = path + '.' + self._extensions[i++]\n\n    debug('stat \"%s\"', p)\n    fs.stat(p, function (err, stat) {\n      if (err) return next(err)\n      if (stat.isDirectory()) return next()\n      self.emit('file', p, stat)\n      self.send(p, stat)\n    })\n  }\n}\n\n/**\n * Transfer index for `path`.\n *\n * @param {String} path\n * @api private\n */\nSendStream.prototype.sendIndex = function sendIndex (path) {\n  var i = -1\n  var self = this\n\n  function next (err) {\n    if (++i >= self._index.length) {\n      if (err) return self.onStatError(err)\n      return self.error(404)\n    }\n\n    var p = join(path, self._index[i])\n\n    debug('stat \"%s\"', p)\n    fs.stat(p, function (err, stat) {\n      if (err) return next(err)\n      if (stat.isDirectory()) return next()\n      self.emit('file', p, stat)\n      self.send(p, stat)\n    })\n  }\n\n  next()\n}\n\n/**\n * Stream `path` to the response.\n *\n * @param {String} path\n * @param {Object} options\n * @api private\n */\n\nSendStream.prototype.stream = function stream (path, options) {\n  // TODO: this is all lame, refactor meeee\n  var finished = false\n  var self = this\n  var res = this.res\n\n  // pipe\n  var stream = fs.createReadStream(path, options)\n  this.emit('stream', stream)\n  stream.pipe(res)\n\n  // response finished, done with the fd\n  onFinished(res, function onfinished () {\n    finished = true\n    destroy(stream)\n  })\n\n  // error handling code-smell\n  stream.on('error', function onerror (err) {\n    // request already finished\n    if (finished) return\n\n    // clean up stream\n    finished = true\n    destroy(stream)\n\n    // error\n    self.onStatError(err)\n  })\n\n  // end\n  stream.on('end', function onend () {\n    self.emit('end')\n  })\n}\n\n/**\n * Set content-type based on `path`\n * if it hasn't been explicitly set.\n *\n * @param {String} path\n * @api private\n */\n\nSendStream.prototype.type = function type (path) {\n  var res = this.res\n\n  if (res.getHeader('Content-Type')) return\n\n  var type = mime.lookup(path)\n\n  if (!type) {\n    debug('no content-type')\n    return\n  }\n\n  var charset = mime.charsets.lookup(type)\n\n  debug('content-type %s', type)\n  res.setHeader('Content-Type', type + (charset ? '; charset=' + charset : ''))\n}\n\n/**\n * Set response header fields, most\n * fields may be pre-defined.\n *\n * @param {String} path\n * @param {Object} stat\n * @api private\n */\n\nSendStream.prototype.setHeader = function setHeader (path, stat) {\n  var res = this.res\n\n  this.emit('headers', res, path, stat)\n\n  if (this._acceptRanges && !res.getHeader('Accept-Ranges')) {\n    debug('accept ranges')\n    res.setHeader('Accept-Ranges', 'bytes')\n  }\n\n  if (this._cacheControl && !res.getHeader('Cache-Control')) {\n    var cacheControl = 'public, max-age=' + Math.floor(this._maxage / 1000)\n\n    if (this._immutable) {\n      cacheControl += ', immutable'\n    }\n\n    debug('cache-control %s', cacheControl)\n    res.setHeader('Cache-Control', cacheControl)\n  }\n\n  if (this._lastModified && !res.getHeader('Last-Modified')) {\n    var modified = stat.mtime.toUTCString()\n    debug('modified %s', modified)\n    res.setHeader('Last-Modified', modified)\n  }\n\n  if (this._etag && !res.getHeader('ETag')) {\n    var val = etag(stat)\n    debug('etag %s', val)\n    res.setHeader('ETag', val)\n  }\n}\n\n/**\n * Clear all headers from a response.\n *\n * @param {object} res\n * @private\n */\n\nfunction clearHeaders (res) {\n  var headers = getHeaderNames(res)\n\n  for (var i = 0; i < headers.length; i++) {\n    res.removeHeader(headers[i])\n  }\n}\n\n/**\n * Collapse all leading slashes into a single slash\n *\n * @param {string} str\n * @private\n */\nfunction collapseLeadingSlashes (str) {\n  for (var i = 0; i < str.length; i++) {\n    if (str[i] !== '/') {\n      break\n    }\n  }\n\n  return i > 1\n    ? '/' + str.substr(i)\n    : str\n}\n\n/**\n * Determine if path parts contain a dotfile.\n *\n * @api private\n */\n\nfunction containsDotFile (parts) {\n  for (var i = 0; i < parts.length; i++) {\n    var part = parts[i]\n    if (part.length > 1 && part[0] === '.') {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Create a Content-Range header.\n *\n * @param {string} type\n * @param {number} size\n * @param {array} [range]\n */\n\nfunction contentRange (type, size, range) {\n  return type + ' ' + (range ? range.start + '-' + range.end : '*') + '/' + size\n}\n\n/**\n * Create a minimal HTML document.\n *\n * @param {string} title\n * @param {string} body\n * @private\n */\n\nfunction createHtmlDocument (title, body) {\n  return '<!DOCTYPE html>\\n' +\n    '<html lang=\"en\">\\n' +\n    '<head>\\n' +\n    '<meta charset=\"utf-8\">\\n' +\n    '<title>' + title + '</title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '<pre>' + body + '</pre>\\n' +\n    '</body>\\n' +\n    '</html>\\n'\n}\n\n/**\n * decodeURIComponent.\n *\n * Allows V8 to only deoptimize this fn instead of all\n * of send().\n *\n * @param {String} path\n * @api private\n */\n\nfunction decode (path) {\n  try {\n    return decodeURIComponent(path)\n  } catch (err) {\n    return -1\n  }\n}\n\n/**\n * Get the header names on a respnse.\n *\n * @param {object} res\n * @returns {array[string]}\n * @private\n */\n\nfunction getHeaderNames (res) {\n  return typeof res.getHeaderNames !== 'function'\n    ? Object.keys(res._headers || {})\n    : res.getHeaderNames()\n}\n\n/**\n * Determine if emitter has listeners of a given type.\n *\n * The way to do this check is done three different ways in Node.js >= 0.8\n * so this consolidates them into a minimal set using instance methods.\n *\n * @param {EventEmitter} emitter\n * @param {string} type\n * @returns {boolean}\n * @private\n */\n\nfunction hasListeners (emitter, type) {\n  var count = typeof emitter.listenerCount !== 'function'\n    ? emitter.listeners(type).length\n    : emitter.listenerCount(type)\n\n  return count > 0\n}\n\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\nfunction headersSent (res) {\n  return typeof res.headersSent !== 'boolean'\n    ? Boolean(res._header)\n    : res.headersSent\n}\n\n/**\n * Normalize the index option into an array.\n *\n * @param {boolean|string|array} val\n * @param {string} name\n * @private\n */\n\nfunction normalizeList (val, name) {\n  var list = [].concat(val || [])\n\n  for (var i = 0; i < list.length; i++) {\n    if (typeof list[i] !== 'string') {\n      throw new TypeError(name + ' must be array of strings or false')\n    }\n  }\n\n  return list\n}\n\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */\n\nfunction parseHttpDate (date) {\n  var timestamp = date && Date.parse(date)\n\n  return typeof timestamp === 'number'\n    ? timestamp\n    : NaN\n}\n\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(str.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(str.substring(start, end))\n\n  return list\n}\n\n/**\n * Set an object of headers on a response.\n *\n * @param {object} res\n * @param {object} headers\n * @private\n */\n\nfunction setHeaders (res, headers) {\n  var keys = Object.keys(headers)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    res.setHeader(key, headers[key])\n  }\n}\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar slice = require('sliced');\nvar assert = require('assert');\nvar util = require('util');\nvar utils = require('./utils');\nvar debug = require('debug')('mquery');\n\n/* global Map */\n\n/**\n * Query constructor used for building queries.\n *\n * ####Example:\n *\n *     var query = new Query({ name: 'mquery' });\n *     query.setOptions({ collection: moduleCollection })\n *     query.where('age').gte(21).exec(callback);\n *\n * @param {Object} [criteria]\n * @param {Object} [options]\n * @api public\n */\n\nfunction Query(criteria, options) {\n  if (!(this instanceof Query))\n    return new Query(criteria, options);\n\n  var proto = this.constructor.prototype;\n\n  this.op = proto.op || undefined;\n\n  this.options = {};\n  this.setOptions(proto.options);\n\n  this._conditions = proto._conditions\n    ? utils.clone(proto._conditions)\n    : {};\n\n  this._fields = proto._fields\n    ? utils.clone(proto._fields)\n    : undefined;\n\n  this._update = proto._update\n    ? utils.clone(proto._update)\n    : undefined;\n\n  this._path = proto._path || undefined;\n  this._distinct = proto._distinct || undefined;\n  this._collection = proto._collection || undefined;\n  this._traceFunction = proto._traceFunction || undefined;\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (criteria) {\n    if (criteria.find && criteria.remove && criteria.update) {\n      // quack quack!\n      this.collection(criteria);\n    } else {\n      this.find(criteria);\n    }\n  }\n}\n\n/**\n * This is a parameter that the user can set which determines if mquery\n * uses $within or $geoWithin for queries. It defaults to true which\n * means $geoWithin will be used. If using MongoDB < 2.4 you should\n * set this to false.\n *\n * @api public\n * @property use$geoWithin\n */\n\nvar $withinCmd = '$geoWithin';\nObject.defineProperty(Query, 'use$geoWithin', {\n  get: function( ) { return $withinCmd == '$geoWithin'; },\n  set: function(v) {\n    if (true === v) {\n      // mongodb >= 2.4\n      $withinCmd = '$geoWithin';\n    } else {\n      $withinCmd = '$within';\n    }\n  }\n});\n\n/**\n * Converts this query to a constructor function with all arguments and options retained.\n *\n * ####Example\n *\n *     // Create a query that will read documents with a \"video\" category from\n *     // `aCollection` on the primary node in the replica-set unless it is down,\n *     // in which case we'll read from a secondary node.\n *     var query = mquery({ category: 'video' })\n *     query.setOptions({ collection: aCollection, read: 'primaryPreferred' });\n *\n *     // create a constructor based off these settings\n *     var Video = query.toConstructor();\n *\n *     // Video is now a subclass of mquery() and works the same way but with the\n *     // default query parameters and options set.\n *\n *     // run a query with the previous settings but filter for movies with names\n *     // that start with \"Life\".\n *     Video().where({ name: /^Life/ }).exec(cb);\n *\n * @return {Query} new Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  function CustomQuery(criteria, options) {\n    if (!(this instanceof CustomQuery))\n      return new CustomQuery(criteria, options);\n    Query.call(this, criteria, options);\n  }\n\n  utils.inherits(CustomQuery, Query);\n\n  // set inherited defaults\n  var p = CustomQuery.prototype;\n\n  p.options = {};\n  p.setOptions(this.options);\n\n  p.op = this.op;\n  p._conditions = utils.clone(this._conditions);\n  p._fields = utils.clone(this._fields);\n  p._update = utils.clone(this._update);\n  p._path = this._path;\n  p._distinct = this._distinct;\n  p._collection = this._collection;\n  p._traceFunction = this._traceFunction;\n\n  return CustomQuery;\n};\n\n/**\n * Sets query options.\n *\n * ####Options:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors) *\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D) *\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D) *\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D) *\n * - [maxScan](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan) *\n * - [maxTime](http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS) *\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D) *\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment) *\n * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D) *\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint) *\n * - [slaveOk](http://docs.mongodb.org/manual/applications/replication/#read-preference) *\n * - [safe](http://www.mongodb.org/display/DOCS/getLastError+Command)\n * - collection the collection to query against\n *\n * _* denotes a query helper method is also available_\n *\n * @param {Object} options\n * @api public\n */\n\nQuery.prototype.setOptions = function(options) {\n  if (!(options && utils.isObject(options)))\n    return this;\n\n  // set arbitrary options\n  var methods = utils.keys(options),\n      method;\n\n  for (var i = 0; i < methods.length; ++i) {\n    method = methods[i];\n\n    // use methods if exist (safer option manipulation)\n    if ('function' == typeof this[method]) {\n      var args = utils.isArray(options[method])\n        ? options[method]\n        : [options[method]];\n      this[method].apply(this, args);\n    } else {\n      this.options[method] = options[method];\n    }\n  }\n\n  return this;\n};\n\n/**\n * Sets this Querys collection.\n *\n * @param {Collection} coll\n * @return {Query} this\n */\n\nQuery.prototype.collection = function collection(coll) {\n  this._collection = new Query.Collection(coll);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * ####Example\n *\n *     query.find().collation({ locale: \"en_US\", strength: 1 })\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Specifies a `$where` condition\n *\n * Use `$where` when you need to select documents using a JavaScript expression.\n *\n * ####Example\n *\n *     query.$where('this.comments.length > 10 || this.name.length > 5')\n *\n *     query.$where(function () {\n *       return this.comments.length > 10 || this.name.length > 5;\n *     })\n *\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @method $where\n * @api public\n */\n\nQuery.prototype.$where = function(js) {\n  this._conditions.$where = js;\n  return this;\n};\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * ####Example\n *\n *     // instead of writing:\n *     User.find({age: {$gte: 21, $lte: 65}}, callback);\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^vonderful/i)\n *     .where('friends').slice(10)\n *     .exec(callback)\n *\n * @param {String} [path]\n * @param {Object} [val]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.where = function() {\n  if (!arguments.length) return this;\n  if (!this.op) this.op = 'find';\n\n  var type = typeof arguments[0];\n\n  if ('string' == type) {\n    this._path = arguments[0];\n\n    if (2 === arguments.length) {\n      this._conditions[this._path] = arguments[1];\n    }\n\n    return this;\n  }\n\n  if ('object' == type && !Array.isArray(arguments[0])) {\n    return this.merge(arguments[0]);\n  }\n\n  throw new TypeError('path must be a string or object');\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * ####Example\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.equals = function equals(val) {\n  this._ensurePath('equals');\n  var path = this._path;\n  this._conditions[path] = val;\n  return this;\n};\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n * This is alias of `equals`\n *\n * ####Example\n *\n *     User.where('age').eq(49);\n *\n *     // is the same as\n *\n *     User.shere('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.eq = function eq(val) {\n  this._ensurePath('eq');\n  var path = this._path;\n  this._conditions[path] = val;\n  return this;\n};\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * ####Example\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.or = function or(array) {\n  var or = this._conditions.$or || (this._conditions.$or = []);\n  if (!utils.isArray(array)) array = [array];\n  or.push.apply(or, array);\n  return this;\n};\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * ####Example\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.nor = function nor(array) {\n  var nor = this._conditions.$nor || (this._conditions.$nor = []);\n  if (!utils.isArray(array)) array = [array];\n  nor.push.apply(nor, array);\n  return this;\n};\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * ####Example\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.and = function and(array) {\n  var and = this._conditions.$and || (this._conditions.$and = []);\n  if (!Array.isArray(array)) array = [array];\n  and.push.apply(and, array);\n  return this;\n};\n\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * ####Example\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method ne\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method in\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method nin\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method all\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method size\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method regex\n * @memberOf Query\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method maxDistance\n * @memberOf Query\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/*!\n * gt, gte, lt, lte, ne, in, nin, all, regex, size, maxDistance\n *\n *     Thing.where('type').nin(array)\n */\n\n'gt gte lt lte ne in nin all regex size maxDistance minDistance'.split(' ').forEach(function($conditional) {\n  Query.prototype[$conditional] = function() {\n    var path, val;\n\n    if (1 === arguments.length) {\n      this._ensurePath($conditional);\n      val = arguments[0];\n      path = this._path;\n    } else {\n      val = arguments[1];\n      path = arguments[0];\n    }\n\n    var conds = this._conditions[path] === null || typeof this._conditions[path] === 'object' ?\n      this._conditions[path] :\n      (this._conditions[path] = {});\n    conds['$' + $conditional] = val;\n    return this;\n  };\n});\n\n/**\n * Specifies a `$mod` condition\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  var val, path;\n\n  if (1 === arguments.length) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (2 === arguments.length && !utils.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = slice(arguments);\n    path = this._path;\n  } else if (3 === arguments.length) {\n    val = slice(arguments, 1);\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * ####Example\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.exists = function() {\n  var path, val;\n\n  if (0 === arguments.length) {\n    this._ensurePath('exists');\n    path = this._path;\n    val = true;\n  } else if (1 === arguments.length) {\n    if ('boolean' === typeof arguments[0]) {\n      this._ensurePath('exists');\n      path = this._path;\n      val = arguments[0];\n    } else {\n      path = arguments[0];\n      val = true;\n    }\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  }\n\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$exists = val;\n  return this;\n};\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * ####Example\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.elemMatch = function() {\n  if (null == arguments[0])\n    throw new TypeError('Invalid argument');\n\n  var fn, path, criteria;\n\n  if ('function' === typeof arguments[0]) {\n    this._ensurePath('elemMatch');\n    path = this._path;\n    fn = arguments[0];\n  } else if (utils.isObject(arguments[0])) {\n    this._ensurePath('elemMatch');\n    path = this._path;\n    criteria = arguments[0];\n  } else if ('function' === typeof arguments[1]) {\n    path = arguments[0];\n    fn = arguments[1];\n  } else if (arguments[1] && utils.isObject(arguments[1])) {\n    path = arguments[0];\n    criteria = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (fn) {\n    criteria = new Query;\n    fn(criteria);\n    criteria = criteria._conditions;\n  }\n\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$elemMatch = criteria;\n  return this;\n};\n\n// Spatial queries\n\n/**\n * Sugar for geo-spatial queries.\n *\n * ####Example\n *\n *     query.within().box()\n *     query.within().circle()\n *     query.within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * ####NOTE:\n *\n * Must be used after `where()`.\n *\n * @memberOf Query\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.within = function within() {\n  // opinionated, must be used after where\n  this._ensurePath('within');\n  this._geoComparison = $withinCmd;\n\n  if (0 === arguments.length) {\n    return this;\n  }\n\n  if (2 === arguments.length) {\n    return this.box.apply(this, arguments);\n  } else if (2 < arguments.length) {\n    return this.polygon.apply(this, arguments);\n  }\n\n  var area = arguments[0];\n\n  if (!area)\n    throw new TypeError('Invalid argument');\n\n  if (area.center)\n    return this.circle(area);\n\n  if (area.box)\n    return this.box.apply(this, area.box);\n\n  if (area.polygon)\n    return this.polygon.apply(this, area.polygon);\n\n  if (area.type && area.coordinates)\n    return this.geometry(area);\n\n  throw new TypeError('Invalid argument');\n};\n\n/**\n * Specifies a $box condition\n *\n * ####Example\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box('loc', lowerLeft, upperRight )\n *\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see Query#within #query_Query-within\n * @param {String} path\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.box = function() {\n  var path, box;\n\n  if (3 === arguments.length) {\n    // box('loc', [], [])\n    path = arguments[0];\n    box = [arguments[1], arguments[2]];\n  } else if (2 === arguments.length) {\n    // box([], [])\n    this._ensurePath('box');\n    path = this._path;\n    box = [arguments[0], arguments[1]];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison || $withinCmd] = { '$box': box };\n  return this;\n};\n\n/**\n * Specifies a $polygon condition\n *\n * ####Example\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @param {String|Array} [path]\n * @param {Array|Object} [val]\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.polygon = function() {\n  var val, path;\n\n  if ('string' == typeof arguments[0]) {\n    // polygon('loc', [],[],[])\n    path = arguments[0];\n    val = slice(arguments, 1);\n  } else {\n    // polygon([],[],[])\n    this._ensurePath('polygon');\n    path = this._path;\n    val = slice(arguments);\n  }\n\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison || $withinCmd] = { '$polygon': val };\n  return this;\n};\n\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * ####Example\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n *     // for spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     query.center('loc', area);\n *\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.circle = function() {\n  var path, val;\n\n  if (1 === arguments.length) {\n    this._ensurePath('circle');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!('radius' in val && val.center))\n    throw new Error('center and radius are required');\n\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n\n  var type = val.spherical\n    ? '$centerSphere'\n    : '$center';\n\n  var wKey = this._geoComparison || $withinCmd;\n  conds[wKey] = {};\n  conds[wKey][type] = [val.center, val.radius];\n\n  if ('unique' in val)\n    conds[wKey].$uniqueDocs = !!val.unique;\n\n  return this;\n};\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * ####Example\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *     query.near({ center: { type: 'Point', coordinates: [..] }})\n *     query.near().geometry({ type: 'Point', coordinates: [..] })\n *\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\nQuery.prototype.near = function near() {\n  var path, val;\n\n  this._geoComparison = '$near';\n\n  if (0 === arguments.length) {\n    return this;\n  } else if (1 === arguments.length) {\n    this._ensurePath('near');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    path = arguments[0];\n    val = arguments[1];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!val.center) {\n    throw new Error('center is required');\n  }\n\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n\n  var type = val.spherical\n    ? '$nearSphere'\n    : '$near';\n\n  // center could be a GeoJSON object or an Array\n  if (Array.isArray(val.center)) {\n    conds[type] = val.center;\n\n    var radius = 'maxDistance' in val\n      ? val.maxDistance\n      : null;\n\n    if (null != radius) {\n      conds.$maxDistance = radius;\n    }\n    if (null != val.minDistance) {\n      conds.$minDistance = val.minDistance;\n    }\n  } else {\n    // GeoJSON?\n    if (val.center.type != 'Point' || !Array.isArray(val.center.coordinates)) {\n      throw new Error(util.format('Invalid GeoJSON specified for %s', type));\n    }\n    conds[type] = { $geometry : val.center };\n\n    // MongoDB 2.6 insists on maxDistance being in $near / $nearSphere\n    if ('maxDistance' in val) {\n      conds[type]['$maxDistance'] = val.maxDistance;\n    }\n    if ('minDistance' in val) {\n      conds[type]['$minDistance'] = val.minDistance;\n    }\n  }\n\n  return this;\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * ####Example\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * @param {Object} [arg]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.intersects = function intersects() {\n  // opinionated, must be used after where\n  this._ensurePath('intersects');\n\n  this._geoComparison = '$geoIntersects';\n\n  if (0 === arguments.length) {\n    return this;\n  }\n\n  var area = arguments[0];\n\n  if (null != area && area.type && area.coordinates)\n    return this.geometry(area);\n\n  throw new TypeError('Invalid argument');\n};\n\n/**\n * Specifies a `$geometry` condition\n *\n * ####Example\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * ####NOTE:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * The most recent path passed to `where()` is used.\n *\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @api public\n */\n\nQuery.prototype.geometry = function geometry() {\n  if (!('$within' == this._geoComparison ||\n        '$geoWithin' == this._geoComparison ||\n        '$near' == this._geoComparison ||\n        '$geoIntersects' == this._geoComparison)) {\n    throw new Error('geometry() must come after `within()`, `intersects()`, or `near()');\n  }\n\n  var val, path;\n\n  if (1 === arguments.length) {\n    this._ensurePath('geometry');\n    path = this._path;\n    val = arguments[0];\n  } else {\n    throw new TypeError('Invalid argument');\n  }\n\n  if (!(val.type && Array.isArray(val.coordinates))) {\n    throw new TypeError('Invalid argument');\n  }\n\n  var conds = this._conditions[path] || (this._conditions[path] = {});\n  conds[this._geoComparison] = { $geometry: val };\n\n  return this;\n};\n\n// end spatial\n\n/**\n * Specifies which document fields to include or exclude\n *\n * ####String syntax\n *\n * When passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\n *\n * ####Example\n *\n *     // include a and b, exclude c\n *     query.select('a b -c');\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({a: 1, b: 1, c: 0});\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  var arg = arguments[0];\n  if (!arg) return this;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  var fields = this._fields || (this._fields = {});\n  var type = typeof arg;\n  var i, len;\n\n  if (('string' == type || utils.isArgumentsObject(arg)) &&\n    'number' == typeof arg.length || Array.isArray(arg)) {\n    if ('string' == type)\n      arg = arg.split(/\\s+/);\n\n    for (i = 0, len = arg.length; i < len; ++i) {\n      var field = arg[i];\n      if (!field) continue;\n      var include = '-' == field[0] ? 0 : 1;\n      if (include === 0) field = field.substring(1);\n      fields[field] = include;\n    }\n\n    return this;\n  }\n\n  if (utils.isObject(arg)) {\n    var keys = utils.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      fields[keys[i]] = arg[keys[i]];\n    }\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * Specifies a $slice condition for a `path`\n *\n * ####Example\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (0 === arguments.length)\n    return this;\n\n  this._validate('slice');\n\n  var path, val;\n\n  if (1 === arguments.length) {\n    var arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      var keys = Object.keys(arg);\n      var numKeys = keys.length;\n      for (var i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (2 === arguments.length) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = slice(arguments);\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (3 === arguments.length) {\n    path = arguments[0];\n    val = slice(arguments, 1);\n  }\n\n  var myFields = this._fields || (this._fields = {});\n  myFields[path] = { '$slice': val };\n  return this;\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are 'asc', 'desc', 'ascending', 'descending', 1, and -1.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * ####Example\n *\n *     // these are equivalent\n *     query.sort({ field: 'asc', test: -1 });\n *     query.sort('field -test');\n *     query.sort([['field', 1], ['test', -1]]);\n *\n * ####Note\n *\n *  - The array syntax `.sort([['field', 1], ['test', -1]])` can only be used with [mongodb driver >= 2.0.46](https://github.com/mongodb/node-mongodb-native/blob/2.1/HISTORY.md#2046-2015-10-15).\n *  - Cannot be used with `distinct()`\n *\n * @param {Object|String|Array} arg\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (!arg) return this;\n  var i, len, field;\n\n  this._validate('sort');\n\n  var type = typeof arg;\n\n  // .sort([['field', 1], ['test', -1]])\n  if (Array.isArray(arg)) {\n    len = arg.length;\n    for (i = 0; i < arg.length; ++i) {\n      if (!Array.isArray(arg[i])) {\n        throw new Error('Invalid sort() argument, must be array of arrays');\n      }\n      _pushArr(this.options, arg[i][0], arg[i][1]);\n    }\n    return this;\n  }\n\n  // .sort('field -test')\n  if (1 === arguments.length && 'string' == type) {\n    arg = arg.split(/\\s+/);\n    len = arg.length;\n    for (i = 0; i < len; ++i) {\n      field = arg[i];\n      if (!field) continue;\n      var ascend = '-' == field[0] ? -1 : 1;\n      if (ascend === -1) field = field.substring(1);\n      push(this.options, field, ascend);\n    }\n\n    return this;\n  }\n\n  // .sort({ field: 1, test: -1 })\n  if (utils.isObject(arg)) {\n    var keys = utils.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      field = keys[i];\n      push(this.options, field, arg[field]);\n    }\n\n    return this;\n  }\n\n  if (typeof Map !== 'undefined' && arg instanceof Map) {\n    _pushMap(this.options, arg);\n    return this;\n  }\n  throw new TypeError('Invalid sort() argument. Must be a string, object, or array.');\n};\n\n/*!\n * @ignore\n */\n\nvar _validSortValue = {\n  '1': 1,\n  '-1': -1,\n  'asc': 1,\n  'ascending': 1,\n  'desc': -1,\n  'descending': -1\n};\n\nfunction push(opts, field, value) {\n  if (Array.isArray(opts.sort)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or object:' +\n      '\\n- `.sort([[\\'field\\', 1], [\\'test\\', -1]])`' +\n      '\\n- `.sort({ field: 1, test: -1 })`');\n  }\n\n  var s;\n  if (value && value.$meta) {\n    s = opts.sort || (opts.sort = {});\n    s[field] = { $meta : value.$meta };\n    return;\n  }\n\n  s = opts.sort || (opts.sort = {});\n  var val = String(value || 1).toLowerCase();\n  val = _validSortValue[val];\n  if (!val) throw new TypeError('Invalid sort value: { ' + field + ': ' + value + ' }');\n\n  s[field] = val;\n}\n\nfunction _pushArr(opts, field, value) {\n  opts.sort = opts.sort || [];\n  if (!Array.isArray(opts.sort)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or object:' +\n      '\\n- `.sort([[\\'field\\', 1], [\\'test\\', -1]])`' +\n      '\\n- `.sort({ field: 1, test: -1 })`');\n  }\n\n  var val = String(value || 1).toLowerCase();\n  val = _validSortValue[val];\n  if (!val) throw new TypeError('Invalid sort value: [ ' + field + ', ' + value + ' ]');\n\n  opts.sort.push([field, val]);\n}\n\nfunction _pushMap(opts, map) {\n  opts.sort = opts.sort || new Map();\n  if (!(opts.sort instanceof Map)) {\n    throw new TypeError('Can\\'t mix sort syntaxes. Use either array or ' +\n      'object or map consistently');\n  }\n  map.forEach(function(value, key) {\n    var val = String(value || 1).toLowerCase();\n    val = _validSortValue[val];\n    if (!val) throw new TypeError('Invalid sort value: < ' + key + ': ' + value + ' >');\n\n    opts.sort.set(key, val);\n  });\n}\n\n\n\n/**\n * Specifies the limit option.\n *\n * ####Example\n *\n *     query.limit(20)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the skip option.\n *\n * ####Example\n *\n *     query.skip(100).limit(20)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the maxScan option.\n *\n * ####Example\n *\n *     query.maxScan(100)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method maxScan\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24maxScan\n * @api public\n */\n/**\n * Specifies the batchSize option.\n *\n * ####Example\n *\n *     query.batchSize(100)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D\n * @api public\n */\n/**\n * Specifies the `comment` option.\n *\n * ####Example\n *\n *     query.comment('login query')\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @param {Number} val\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment\n * @api public\n */\n\n/*!\n * limit, skip, maxScan, batchSize, comment\n *\n * Sets these associated options.\n *\n *     query.comment('feed query');\n */\n\n['limit', 'skip', 'maxScan', 'batchSize', 'comment'].forEach(function(method) {\n  Query.prototype[method] = function(v) {\n    this._validate(method);\n    this.options[method] = v;\n    return this;\n  };\n});\n\n/**\n * Specifies the maxTimeMS option.\n *\n * ####Example\n *\n *     query.maxTime(100)\n *     query.maxTimeMS(100)\n *\n * @method maxTime\n * @memberOf Query\n * @param {Number} ms\n * @see mongodb http://docs.mongodb.org/manual/reference/operator/meta/maxTimeMS/#op._S_maxTimeMS\n * @api public\n */\n\nQuery.prototype.maxTime = Query.prototype.maxTimeMS = function(ms) {\n  this._validate('maxTime');\n  this.options.maxTimeMS = ms;\n  return this;\n};\n\n/**\n * Specifies this query as a `snapshot` query.\n *\n * ####Example\n *\n *     mquery().snapshot() // true\n *     mquery().snapshot(true)\n *     mquery().snapshot(false)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.snapshot = function() {\n  this._validate('snapshot');\n\n  this.options.snapshot = arguments.length\n    ? !!arguments[0]\n    : true;\n\n  return this;\n};\n\n/**\n * Sets query hints.\n *\n * ####Example\n *\n *     query.hint({ indexA: 1, indexB: -1});\n *     query.hint('indexA_1_indexB_1');\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|string} val a hint object or the index name\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint\n * @api public\n */\n\nQuery.prototype.hint = function() {\n  if (0 === arguments.length) return this;\n\n  this._validate('hint');\n\n  var arg = arguments[0];\n  if (utils.isObject(arg)) {\n    var hint = this.options.hint || (this.options.hint = {});\n\n    // must keep object keys in order so don't use Object.keys()\n    for (var k in arg) {\n      hint[k] = arg[k];\n    }\n\n    return this;\n  }\n  if (typeof arg === 'string') {\n    this.options.hint = arg;\n    return this;\n  }\n\n  throw new TypeError('Invalid hint. ' + arg);\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `remove()`\n * - `update()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `j` value if it is specified in writeConcern options\n *\n * ####Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  this.options.j = val;\n  return this;\n};\n\n/**\n * Sets the slaveOk option. _Deprecated_ in MongoDB 2.2 in favor of read preferences.\n *\n * ####Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see read()\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.slaveOk = function(v) {\n  this.options.slaveOk = arguments.length ? !!v : true;\n  return this;\n};\n\n/**\n * Sets the readPreference option for the query.\n *\n * ####Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // you can also use mongodb.ReadPreference class to also specify tags\n *     new Query().read(mongodb.ReadPreference('secondary', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }]))\n *\n *     new Query().setReadPreference('primary') // alias of .read()\n *\n * ####Preferences:\n *\n *     primary - (default)  Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * Read more about how to use read preferences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @param {String|ReadPreference} pref one of the listed preference options or their aliases\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = Query.prototype.setReadPreference = function(pref) {\n  if (arguments.length > 1 && !Query.prototype.read.deprecationWarningIssued) {\n    console.error('Deprecation warning: \\'tags\\' argument is not supported anymore in Query.read() method. Please use mongodb.ReadPreference object instead.');\n    Query.prototype.read.deprecationWarningIssued = true;\n  }\n  this.options.readPreference = utils.readPref(pref);\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * ####Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *     new Query().r('s') // r is alias of readConcern\n *\n *\n * ####Read Concern Level:\n *\n *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n\n\n *\n *\n * Aliases\n *\n *     l   local\n *     a   available\n *     m   majority\n *     lz  linearizable\n *     s   snapshot\n *\n * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.readConcern = Query.prototype.r = function(level) {\n  this.options.readConcern = utils.readConcern(level);\n  return this;\n};\n\n/**\n * Sets tailable option.\n *\n * ####Example\n *\n *     query.tailable() <== true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} v defaults to true\n * @see mongodb http://www.mongodb.org/display/DOCS/Tailable+Cursors\n * @api public\n */\n\nQuery.prototype.tailable = function() {\n  this._validate('tailable');\n\n  this.options.tailable = arguments.length\n    ? !!arguments[0]\n    : true;\n\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `remove()`\n * - `update()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the `w` value if it is specified in writeConcern options\n *\n * ####Example:\n *\n * mquery().writeConcern(0)\n * mquery().writeConcern(1)\n * mquery().writeConcern({ w: 1, j: true, wtimeout: 2000 })\n * mquery().writeConcern('majority')\n * mquery().writeConcern('m') // same as majority\n * mquery().writeConcern('tagSetName') // if the tag set is 'm', use .writeConcern({ w: 'm' }) instead\n * mquery().w(1) // w is alias of writeConcern\n *\n * @method writeConcern\n * @memberOf Query\n * @instance\n * @param {String|number|object} concern 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.writeConcern = Query.prototype.w = function writeConcern(concern) {\n  if ('object' === typeof concern) {\n    if ('undefined' !== typeof concern.j) this.options.j = concern.j;\n    if ('undefined' !== typeof concern.w) this.options.w = concern.w;\n    if ('undefined' !== typeof concern.wtimeout) this.options.wtimeout = concern.wtimeout;\n  } else {\n    this.options.w = 'm' === concern ? 'majority' : concern;\n  }\n  return this;\n};\n\n/**\n * Specifies a time limit, in milliseconds, for the write concern.\n * If `ms > 1`, it is maximum amount of time to wait for this write\n * to propagate through the replica set before this operation fails.\n * The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `remove()`\n * - `update()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to `wtimeout` value if it is specified in writeConcern\n *\n * ####Example:\n *\n *     mquery().w(2).j(true).wtimeout(2000)\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = Query.prototype.wTimeout = function wtimeout(ms) {\n  this.options.wtimeout = ms;\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source)\n    return this;\n\n  if (!Query.canMerge(source))\n    throw new TypeError('Invalid argument. Expected instanceof mquery or plain object');\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      utils.merge(this._conditions, source._conditions);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options);\n    }\n\n    if (source._update) {\n      this._update || (this._update = {});\n      utils.mergeClone(this._update, source._update);\n    }\n\n    if (source._distinct) {\n      this._distinct = source._distinct;\n    }\n\n    return this;\n  }\n\n  // plain object\n  utils.merge(this._conditions, source);\n\n  return this;\n};\n\n/**\n * Finds documents.\n *\n * Passing a `callback` executes the query.\n *\n * ####Example\n *\n *     query.find()\n *     query.find(callback)\n *     query.find({ name: 'Burning Lights' }, callback)\n *\n * @param {Object} [criteria] mongodb selector\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(criteria, callback) {\n  this.op = 'find';\n\n  if ('function' === typeof criteria) {\n    callback = criteria;\n    criteria = undefined;\n  } else if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  if (!callback) return this;\n\n  var conds = this._conditions;\n  var options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('find', this._collection.collectionName, conds, options);\n  callback = this._wrapCallback('find', callback, {\n    conditions: conds,\n    options: options\n  });\n\n  this._collection.find(conds, options, utils.tick(callback));\n  return this;\n};\n\n/**\n * Returns the query cursor\n *\n * ####Examples\n *\n *     query.find().cursor();\n *     query.cursor({ name: 'Burning Lights' });\n *\n * @param {Object} [criteria] mongodb selector\n * @return {Object} cursor\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(criteria) {\n  if (this.op) {\n    if (this.op !== 'find') {\n      throw new TypeError('.cursor only support .find method');\n    }\n  } else {\n    this.find(criteria);\n  }\n\n  var conds = this._conditions;\n  var options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('findCursor', this._collection.collectionName, conds, options);\n  return this._collection.findCursor(conds, options);\n};\n\n/**\n * Executes the query as a findOne() operation.\n *\n * Passing a `callback` executes the query.\n *\n * ####Example\n *\n *     query.findOne().where('name', /^Burning/);\n *\n *     query.findOne({ name: /^Burning/ })\n *\n *     query.findOne({ name: /^Burning/ }, callback); // executes\n *\n *     query.findOne(function (err, doc) {\n *       if (err) return handleError(err);\n *       if (doc) {\n *         // doc may be null if no document matched\n *\n *       }\n *     });\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOne = function(criteria, callback) {\n  this.op = 'findOne';\n\n  if ('function' === typeof criteria) {\n    callback = criteria;\n    criteria = undefined;\n  } else if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  if (!callback) return this;\n\n  var conds = this._conditions;\n  var options = this._optionsForExec();\n\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('findOne', this._collection.collectionName, conds, options);\n  callback = this._wrapCallback('findOne', callback, {\n    conditions: conds,\n    options: options\n  });\n\n  this._collection.findOne(conds, options, utils.tick(callback));\n\n  return this;\n};\n\n/**\n * Exectues the query as a count() operation.\n *\n * Passing a `callback` executes the query.\n *\n * ####Example\n *\n *     query.count().where('color', 'black').exec(callback);\n *\n *     query.count({ color: 'black' }).count(callback)\n *\n *     query.count({ color: 'black' }, callback)\n *\n *     query.where('color', 'black').count(function (err, count) {\n *       if (err) return handleError(err);\n *       console.log('there are %d kittens', count);\n *     })\n *\n * @param {Object} [criteria] mongodb selector\n * @param {Function} [callback]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Count\n * @api public\n */\n\nQuery.prototype.count = function(criteria, callback) {\n  this.op = 'count';\n  this._validate();\n\n  if ('function' === typeof criteria) {\n    callback = criteria;\n    criteria = undefined;\n  } else if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  if (!callback) return this;\n\n  var conds = this._conditions,\n      options = this._optionsForExec();\n\n  debug('count', this._collection.collectionName, conds, options);\n  callback = this._wrapCallback('count', callback, {\n    conditions: conds,\n    options: options\n  });\n\n  this._collection.count(conds, options, utils.tick(callback));\n  return this;\n};\n\n/**\n * Declares or executes a distinct() operation.\n *\n * Passing a `callback` executes the query.\n *\n * ####Example\n *\n *     distinct(criteria, field, fn)\n *     distinct(criteria, field)\n *     distinct(field, fn)\n *     distinct(field)\n *     distinct(fn)\n *     distinct()\n *\n * @param {Object|Query} [criteria]\n * @param {String} [field]\n * @param {Function} [callback]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Aggregation#Aggregation-Distinct\n * @api public\n */\n\nQuery.prototype.distinct = function(criteria, field, callback) {\n  this.op = 'distinct';\n  this._validate();\n\n  if (!callback) {\n    switch (typeof field) {\n      case 'function':\n        callback = field;\n        if ('string' == typeof criteria) {\n          field = criteria;\n          criteria = undefined;\n        }\n        break;\n      case 'undefined':\n      case 'string':\n        break;\n      default:\n        throw new TypeError('Invalid `field` argument. Must be string or function');\n    }\n\n    switch (typeof criteria) {\n      case 'function':\n        callback = criteria;\n        criteria = field = undefined;\n        break;\n      case 'string':\n        field = criteria;\n        criteria = undefined;\n        break;\n    }\n  }\n\n  if ('string' == typeof field) {\n    this._distinct = field;\n  }\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  if (!callback) {\n    return this;\n  }\n\n  if (!this._distinct) {\n    throw new Error('No value for `distinct` has been declared');\n  }\n\n  var conds = this._conditions,\n      options = this._optionsForExec();\n\n  debug('distinct', this._collection.collectionName, conds, options);\n  callback = this._wrapCallback('distinct', callback, {\n    conditions: conds,\n    options: options\n  });\n\n  this._collection.distinct(this._distinct, conds, options, utils.tick(callback));\n\n  return this;\n};\n\n/**\n * Declare and/or execute this query as an update() operation. By default,\n * `update()` only modifies the _first_ document that matches `criteria`.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * ####Example\n *\n *     mquery({ _id: id }).update({ title: 'words' }, ...)\n *\n * becomes\n *\n *     collection.update({ _id: id }, { $set: { title: 'words' }}, ...)\n *\n * ####Note\n *\n * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.\n *\n * ####Note\n *\n * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call update() and then execute it by using the `exec()` method.\n *\n *     var q = mquery(collection).where({ _id: id });\n *     q.update({ $set: { name: 'bob' }}).update(); // not executed\n *\n *     var q = mquery(collection).where({ _id: id });\n *     q.update({ $set: { name: 'bob' }}).exec(); // executed as unsafe\n *\n *     // keys that are not $atomic ops become $set.\n *     // this executes the same command as the previous example.\n *     q.update({ name: 'bob' }).where({ _id: id }).exec();\n *\n *     var q = mquery(collection).update(); // not executed\n *\n *     // overwriting with empty docs\n *     var q.where({ _id: id }).setOptions({ overwrite: true })\n *     q.update({ }, callback); // executes\n *\n *     // multi update with overwrite to empty doc\n *     var q = mquery(collection).where({ _id: id });\n *     q.setOptions({ multi: true, overwrite: true })\n *     q.update({ });\n *     q.update(callback); // executed\n *\n *     // multi updates\n *     mquery()\n *       .collection(coll)\n *       .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)\n *     // more multi updates\n *     mquery({ })\n *       .collection(coll)\n *       .setOptions({ multi: true })\n *       .update({ $set: { arr: [] }}, callback)\n *\n *     // single update by default\n *     mquery({ email: 'address@example.com' })\n *      .collection(coll)\n *      .update({ $inc: { counter: 1 }}, callback)\n *\n *     // summary\n *     update(criteria, doc, opts, cb) // executes\n *     update(criteria, doc, opts)\n *     update(criteria, doc, cb) // executes\n *     update(criteria, doc)\n *     update(doc, cb) // executes\n *     update(doc)\n *     update(cb) // executes\n *     update(true) // executes (unsafe write)\n *     update()\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.update = function update(criteria, doc, options, callback) {\n  var force;\n\n  switch (arguments.length) {\n    case 3:\n      if ('function' == typeof options) {\n        callback = options;\n        options = undefined;\n      }\n      break;\n    case 2:\n      if ('function' == typeof doc) {\n        callback = doc;\n        doc = criteria;\n        criteria = undefined;\n      }\n      break;\n    case 1:\n      switch (typeof criteria) {\n        case 'function':\n          callback = criteria;\n          criteria = options = doc = undefined;\n          break;\n        case 'boolean':\n          // execution with no callback (unsafe write)\n          force = criteria;\n          criteria = undefined;\n          break;\n        default:\n          doc = criteria;\n          criteria = options = undefined;\n          break;\n      }\n  }\n\n  return _update(this, 'update', criteria, doc, options, force, callback);\n};\n\n/**\n * Declare and/or execute this query as an `updateMany()` operation. Identical\n * to `update()` except `updateMany()` will update _all_ documents that match\n * `criteria`, rather than just the first one.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * ####Example\n *\n *     // Update every document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.updateMany = function updateMany(criteria, doc, options, callback) {\n  var force;\n\n  switch (arguments.length) {\n    case 3:\n      if ('function' == typeof options) {\n        callback = options;\n        options = undefined;\n      }\n      break;\n    case 2:\n      if ('function' == typeof doc) {\n        callback = doc;\n        doc = criteria;\n        criteria = undefined;\n      }\n      break;\n    case 1:\n      switch (typeof criteria) {\n        case 'function':\n          callback = criteria;\n          criteria = options = doc = undefined;\n          break;\n        case 'boolean':\n          // execution with no callback (unsafe write)\n          force = criteria;\n          criteria = undefined;\n          break;\n        default:\n          doc = criteria;\n          criteria = options = undefined;\n          break;\n      }\n  }\n\n  return _update(this, 'updateMany', criteria, doc, options, force, callback);\n};\n\n/**\n * Declare and/or execute this query as an `updateOne()` operation. Identical\n * to `update()` except `updateOne()` will _always_ update just one document,\n * regardless of the `multi` option.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * ####Example\n *\n *     // Update the first document whose `title` contains 'test'\n *     mquery().updateMany({ title: /test/ }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.updateOne = function updateOne(criteria, doc, options, callback) {\n  var force;\n\n  switch (arguments.length) {\n    case 3:\n      if ('function' == typeof options) {\n        callback = options;\n        options = undefined;\n      }\n      break;\n    case 2:\n      if ('function' == typeof doc) {\n        callback = doc;\n        doc = criteria;\n        criteria = undefined;\n      }\n      break;\n    case 1:\n      switch (typeof criteria) {\n        case 'function':\n          callback = criteria;\n          criteria = options = doc = undefined;\n          break;\n        case 'boolean':\n          // execution with no callback (unsafe write)\n          force = criteria;\n          criteria = undefined;\n          break;\n        default:\n          doc = criteria;\n          criteria = options = undefined;\n          break;\n      }\n  }\n\n  return _update(this, 'updateOne', criteria, doc, options, force, callback);\n};\n\n/**\n * Declare and/or execute this query as an `replaceOne()` operation. Similar\n * to `updateOne()`, except `replaceOne()` is not allowed to use atomic\n * modifiers (`$set`, `$push`, etc.). Calling `replaceOne()` will always\n * replace the existing doc.\n *\n * ####Example\n *\n *     // Replace the document with `_id` 1 with `{ _id: 1, year: 2017 }`\n *     mquery().replaceOne({ _id: 1 }, { year: 2017 })\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.replaceOne = function replaceOne(criteria, doc, options, callback) {\n  var force;\n\n  switch (arguments.length) {\n    case 3:\n      if ('function' == typeof options) {\n        callback = options;\n        options = undefined;\n      }\n      break;\n    case 2:\n      if ('function' == typeof doc) {\n        callback = doc;\n        doc = criteria;\n        criteria = undefined;\n      }\n      break;\n    case 1:\n      switch (typeof criteria) {\n        case 'function':\n          callback = criteria;\n          criteria = options = doc = undefined;\n          break;\n        case 'boolean':\n          // execution with no callback (unsafe write)\n          force = criteria;\n          criteria = undefined;\n          break;\n        default:\n          doc = criteria;\n          criteria = options = undefined;\n          break;\n      }\n  }\n\n  this.setOptions({ overwrite: true });\n  return _update(this, 'replaceOne', criteria, doc, options, force, callback);\n};\n\n\n/*!\n * Internal helper for update, updateMany, updateOne\n */\n\nfunction _update(query, op, criteria, doc, options, force, callback) {\n  query.op = op;\n\n  if (Query.canMerge(criteria)) {\n    query.merge(criteria);\n  }\n\n  if (doc) {\n    query._mergeUpdate(doc);\n  }\n\n  if (utils.isObject(options)) {\n    // { overwrite: true }\n    query.setOptions(options);\n  }\n\n  // we are done if we don't have callback and they are\n  // not forcing an unsafe write.\n  if (!(force || callback)) {\n    return query;\n  }\n\n  if (!query._update ||\n      !query.options.overwrite && 0 === utils.keys(query._update).length) {\n    callback && utils.soon(callback.bind(null, null, 0));\n    return query;\n  }\n\n  options = query._optionsForExec();\n  if (!callback) options.safe = false;\n\n  criteria = query._conditions;\n  doc = query._updateForExec();\n\n  debug('update', query._collection.collectionName, criteria, doc, options);\n  callback = query._wrapCallback(op, callback, {\n    conditions: criteria,\n    doc: doc,\n    options: options\n  });\n\n  query._collection[op](criteria, doc, options, utils.tick(callback));\n\n  return query;\n}\n\n/**\n * Declare and/or execute this query as a remove() operation.\n *\n * ####Example\n *\n *     mquery(collection).remove({ artist: 'Anne Murray' }, callback)\n *\n * ####Note\n *\n * The operation is only executed when a callback is passed. To force execution without a callback (which would be an unsafe write), we must first call remove() and then execute it by using the `exec()` method.\n *\n *     // not executed\n *     var query = mquery(collection).remove({ name: 'Anne Murray' })\n *\n *     // executed\n *     mquery(collection).remove({ name: 'Anne Murray' }, callback)\n *     mquery(collection).remove({ name: 'Anne Murray' }).remove(callback)\n *\n *     // executed without a callback (unsafe write)\n *     query.exec()\n *\n *     // summary\n *     query.remove(conds, fn); // executes\n *     query.remove(conds)\n *     query.remove(fn) // executes\n *     query.remove()\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.remove = function(criteria, callback) {\n  this.op = 'remove';\n  var force;\n\n  if ('function' === typeof criteria) {\n    callback = criteria;\n    criteria = undefined;\n  } else if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  } else if (true === criteria) {\n    force = criteria;\n    criteria = undefined;\n  }\n\n  if (!(force || callback))\n    return this;\n\n  var options = this._optionsForExec();\n  if (!callback) options.safe = false;\n\n  var conds = this._conditions;\n\n  debug('remove', this._collection.collectionName, conds, options);\n  callback = this._wrapCallback('remove', callback, {\n    conditions: conds,\n    options: options\n  });\n\n  this._collection.remove(conds, options, utils.tick(callback));\n\n  return this;\n};\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation. Behaves like\n * `remove()`, except for ignores the `justOne` option and always deletes at\n * most one document.\n *\n * ####Example\n *\n *     mquery(collection).deleteOne({ artist: 'Anne Murray' }, callback)\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.deleteOne = function(criteria, callback) {\n  this.op = 'deleteOne';\n  var force;\n\n  if ('function' === typeof criteria) {\n    callback = criteria;\n    criteria = undefined;\n  } else if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  } else if (true === criteria) {\n    force = criteria;\n    criteria = undefined;\n  }\n\n  if (!(force || callback))\n    return this;\n\n  var options = this._optionsForExec();\n  if (!callback) options.safe = false;\n  delete options.justOne;\n\n  var conds = this._conditions;\n\n  debug('deleteOne', this._collection.collectionName, conds, options);\n  callback = this._wrapCallback('deleteOne', callback, {\n    conditions: conds,\n    options: options\n  });\n\n  this._collection.deleteOne(conds, options, utils.tick(callback));\n\n  return this;\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Behaves like\n * `remove()`, except for ignores the `justOne` option and always deletes\n * _every_ document that matches `criteria`.\n *\n * ####Example\n *\n *     mquery(collection).deleteMany({ artist: 'Anne Murray' }, callback)\n *\n * @param {Object|Query} [criteria] mongodb selector\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.deleteMany = function(criteria, callback) {\n  this.op = 'deleteMany';\n  var force;\n\n  if ('function' === typeof criteria) {\n    callback = criteria;\n    criteria = undefined;\n  } else if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  } else if (true === criteria) {\n    force = criteria;\n    criteria = undefined;\n  }\n\n  if (!(force || callback))\n    return this;\n\n  var options = this._optionsForExec();\n  if (!callback) options.safe = false;\n  delete options.justOne;\n\n  var conds = this._conditions;\n\n  debug('deleteOne', this._collection.collectionName, conds, options);\n  callback = this._wrapCallback('deleteOne', callback, {\n    conditions: conds,\n    options: options\n  });\n\n  this._collection.deleteMany(conds, options, utils.tick(callback));\n\n  return this;\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.\n *\n * ####Available options\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to true\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * ####Examples\n *\n *     query.findOneAndUpdate(conditions, update, options, callback) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     query.findOneAndUpdate(conditions, update, callback) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     query.findOneAndUpdate(update, callback)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     query.findOneAndUpdate(callback)                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {\n  this.op = 'findOneAndUpdate';\n  this._validate();\n\n  switch (arguments.length) {\n    case 3:\n      if ('function' == typeof options) {\n        callback = options;\n        options = {};\n      }\n      break;\n    case 2:\n      if ('function' == typeof doc) {\n        callback = doc;\n        doc = criteria;\n        criteria = undefined;\n      }\n      options = undefined;\n      break;\n    case 1:\n      if ('function' == typeof criteria) {\n        callback = criteria;\n        criteria = options = doc = undefined;\n      } else {\n        doc = criteria;\n        criteria = options = undefined;\n      }\n  }\n\n  if (Query.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  options && this.setOptions(options);\n\n  if (!callback) return this;\n  return this._findAndModify('update', callback);\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.\n *\n * ####Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n *\n * ####Examples\n *\n *     A.where().findOneAndRemove(conditions, options, callback) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     A.where().findOneAndRemove(conditions, callback) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     A.where().findOneAndRemove(callback)   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *     A.where().findOneAndDelete()           // alias of .findOneAndRemove()\n *\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nQuery.prototype.findOneAndRemove = Query.prototype.findOneAndDelete = function(conditions, options, callback) {\n  this.op = 'findOneAndRemove';\n  this._validate();\n\n  if ('function' == typeof options) {\n    callback = options;\n    options = undefined;\n  } else if ('function' == typeof conditions) {\n    callback = conditions;\n    conditions = undefined;\n  }\n\n  // apply conditions\n  if (Query.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  // apply options\n  options && this.setOptions(options);\n\n  if (!callback) return this;\n\n  return this._findAndModify('remove', callback);\n};\n\n/**\n * _findAndModify\n *\n * @param {String} type - either \"remove\" or \"update\"\n * @param {Function} callback\n * @api private\n */\n\nQuery.prototype._findAndModify = function(type, callback) {\n  assert.equal('function', typeof callback);\n\n  var options = this._optionsForExec();\n  var fields;\n  var doc;\n\n  if ('remove' == type) {\n    options.remove = true;\n  } else {\n    if (!('new' in options)) options.new = true;\n    if (!('upsert' in options)) options.upsert = false;\n\n    doc = this._updateForExec();\n    if (!doc) {\n      if (options.upsert) {\n        // still need to do the upsert to empty doc\n        doc = { $set: {} };\n      } else {\n        return this.findOne(callback);\n      }\n    }\n  }\n\n  fields = this._fieldsForExec();\n  if (fields != null) {\n    if (this.$useProjection) {\n      options.projection = this._fieldsForExec();\n    } else {\n      options.fields = this._fieldsForExec();\n    }\n  }\n\n  var conds = this._conditions;\n\n  debug('findAndModify', this._collection.collectionName, conds, doc, options);\n  callback = this._wrapCallback('findAndModify', callback, {\n    conditions: conds,\n    doc: doc,\n    options: options\n  });\n\n  this._collection.findAndModify(conds, doc, options, utils.tick(callback));\n\n  return this;\n};\n\n/**\n * Wrap callback to add tracing\n *\n * @param {Function} callback\n * @param {Object} [queryInfo]\n * @api private\n */\nQuery.prototype._wrapCallback = function(method, callback, queryInfo) {\n  var traceFunction = this._traceFunction || Query.traceFunction;\n\n  if (traceFunction) {\n    queryInfo.collectionName = this._collection.collectionName;\n\n    var traceCallback = traceFunction &&\n      traceFunction.call(null, method, queryInfo, this);\n\n    var startTime = new Date().getTime();\n\n    return function wrapperCallback(err, result) {\n      if (traceCallback) {\n        var millis = new Date().getTime() - startTime;\n        traceCallback.call(null, err, result, millis);\n      }\n\n      if (callback) {\n        callback.apply(null, arguments);\n      }\n    };\n  }\n\n  return callback;\n};\n\n/**\n * Add trace function that gets called when the query is executed.\n * The function will be called with (method, queryInfo, query) and\n * should return a callback function which will be called\n * with (err, result, millis) when the query is complete.\n *\n * queryInfo is an object containing: {\n *   collectionName: <name of the collection>,\n *   conditions: <query criteria>,\n *   options: <comment, fields, readPreference, etc>,\n *   doc: [document to update, if applicable]\n * }\n *\n * NOTE: Does not trace stream queries.\n *\n * @param {Function} traceFunction\n * @return {Query} this\n * @api public\n */\nQuery.prototype.setTraceFunction = function(traceFunction) {\n  this._traceFunction = traceFunction;\n  return this;\n};\n\n/**\n * Executes the query\n *\n * ####Examples\n *\n *     query.exec();\n *     query.exec(callback);\n *     query.exec('update');\n *     query.exec('find', callback);\n *\n * @param {String|Function} [operation]\n * @param {Function} [callback]\n * @api public\n */\n\nQuery.prototype.exec = function exec(op, callback) {\n  switch (typeof op) {\n    case 'function':\n      callback = op;\n      op = null;\n      break;\n    case 'string':\n      this.op = op;\n      break;\n  }\n\n  assert.ok(this.op, 'Missing query type: (find, update, etc)');\n\n  if ('update' == this.op || 'remove' == this.op) {\n    callback || (callback = true);\n  }\n\n  var _this = this;\n\n  if ('function' == typeof callback) {\n    this[this.op](callback);\n  } else {\n    return new Query.Promise(function(success, error) {\n      _this[_this.op](function(err, val) {\n        if (err) error(err);\n        else success(val);\n        success = error = null;\n      });\n    });\n  }\n};\n\n/**\n * Returns a thunk which when called runs this.exec()\n *\n * The thunk receives a callback function which will be\n * passed to `this.exec()`\n *\n * @return {Function}\n * @api public\n */\n\nQuery.prototype.thunk = function() {\n  var _this = this;\n  return function(cb) {\n    _this.exec(cb);\n  };\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = function(resolve, reject) {\n  var _this = this;\n  var promise = new Query.Promise(function(success, error) {\n    _this.exec(function(err, val) {\n      if (err) error(err);\n      else success(val);\n      success = error = null;\n    });\n  });\n  return promise.then(resolve, reject);\n};\n\n/**\n * Returns a stream for the given find query.\n *\n * @throws Error if operation is not a find\n * @returns {Stream} Node 0.8 style\n */\n\nQuery.prototype.stream = function(streamOptions) {\n  if ('find' != this.op)\n    throw new Error('stream() is only available for find');\n\n  var conds = this._conditions;\n\n  var options = this._optionsForExec();\n  if (this.$useProjection) {\n    options.projection = this._fieldsForExec();\n  } else {\n    options.fields = this._fieldsForExec();\n  }\n\n  debug('stream', this._collection.collectionName, conds, options, streamOptions);\n\n  return this._collection.findStream(conds, options, streamOptions);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selected = function selected() {\n  return !!(this._fields && Object.keys(this._fields).length > 0);\n};\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *     query.selectedExlusively() // false\n *\n * @returns {Boolean}\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  if (!this._fields) return false;\n\n  var keys = Object.keys(this._fields);\n  if (0 === keys.length) return false;\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    if (0 === this._fields[key]) return false;\n    if (this._fields[key] &&\n        typeof this._fields[key] === 'object' &&\n        this._fields[key].$meta) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExlusively() // false\n *     query.select('-name')\n *     query.selectedExlusively() // true\n *     query.selectedInclusively() // false\n *\n * @returns {Boolean}\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  if (!this._fields) return false;\n\n  var keys = Object.keys(this._fields);\n  if (0 === keys.length) return false;\n\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    if (0 === this._fields[key]) return true;\n  }\n\n  return false;\n};\n\n/**\n * Merges `doc` with the current update object.\n *\n * @param {Object} doc\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._update) this._update = {};\n  if (doc instanceof Query) {\n    if (doc._update) {\n      utils.mergeClone(this._update, doc._update);\n    }\n  } else {\n    utils.mergeClone(this._update, doc);\n  }\n};\n\n/**\n * Returns default options.\n *\n * @return {Object}\n * @api private\n */\n\nQuery.prototype._optionsForExec = function() {\n  var options = utils.clone(this.options);\n  return options;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @return {Object}\n * @api private\n */\n\nQuery.prototype._fieldsForExec = function() {\n  return utils.clone(this._fields);\n};\n\n/**\n * Return an update document with corrected $set operations.\n *\n * @api private\n */\n\nQuery.prototype._updateForExec = function() {\n  var update = utils.clone(this._update),\n      ops = utils.keys(update),\n      i = ops.length,\n      ret = {};\n\n  while (i--) {\n    var op = ops[i];\n\n    if (this.options.overwrite) {\n      ret[op] = update[op];\n      continue;\n    }\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  this._compiledUpdate = ret;\n  return ret;\n};\n\n/**\n * Make sure _path is set.\n *\n * @parmam {String} method\n */\n\nQuery.prototype._ensurePath = function(method) {\n  if (!this._path) {\n    var msg = method + '() must be used after where() '\n                     + 'when called with these arguments';\n    throw new Error(msg);\n  }\n};\n\n/*!\n * Permissions\n */\n\nQuery.permissions = require('./permissions');\n\nQuery._isPermitted = function(a, b) {\n  var denied = Query.permissions[b];\n  if (!denied) return true;\n  return true !== denied[a];\n};\n\nQuery.prototype._validate = function(action) {\n  var fail;\n  var validator;\n\n  if (undefined === action) {\n\n    validator = Query.permissions[this.op];\n    if ('function' != typeof validator) return true;\n\n    fail = validator(this);\n\n  } else if (!Query._isPermitted(action, this.op)) {\n    fail = action;\n  }\n\n  if (fail) {\n    throw new Error(fail + ' cannot be used with ' + this.op);\n  }\n};\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @param {Object} conds\n * @return {Boolean}\n */\n\nQuery.canMerge = function(conds) {\n  return conds instanceof Query || utils.isObject(conds);\n};\n\n/**\n * Set a trace function that will get called whenever a\n * query is executed.\n *\n * See `setTraceFunction()` for details.\n *\n * @param {Object} conds\n * @return {Boolean}\n */\nQuery.setGlobalTraceFunction = function(traceFunction) {\n  Query.traceFunction = traceFunction;\n};\n\n/*!\n * Exports.\n */\n\nQuery.utils = utils;\nQuery.env = require('./env');\nQuery.Collection = require('./collection');\nQuery.BaseCollection = require('./collection/collection');\nQuery.Promise = require('bluebird');\nmodule.exports = exports = Query;\n\n// TODO\n// test utils\n","/*!\n * Module requirements\n */\n\n'use strict';\n\nconst MongooseError = require('./');\nconst util = require('util');\n\n/**\n * Document Validation Error\n *\n * @api private\n * @param {Document} instance\n * @inherits MongooseError\n */\n\nfunction ValidationError(instance) {\n  this.errors = {};\n  this._message = '';\n  if (instance && instance.constructor.name === 'model') {\n    this._message = instance.constructor.modelName + ' validation failed';\n    MongooseError.call(this, this._message);\n  } else {\n    this._message = 'Validation failed';\n    MongooseError.call(this, this._message);\n  }\n  this.name = 'ValidationError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  if (instance) {\n    instance.errors = this.errors;\n  }\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nValidationError.prototype = Object.create(MongooseError.prototype);\nValidationError.prototype.constructor = MongooseError;\n\n/**\n * Console.log helper\n */\n\nValidationError.prototype.toString = function() {\n  return this.name + ': ' + _generateMessage(this);\n};\n\n/*!\n * inspect helper\n */\n\nValidationError.prototype.inspect = function() {\n  return Object.assign(new Error(this.message), this);\n};\n\nif (util.inspect.custom) {\n  /*!\n  * Avoid Node deprecation warning DEP0079\n  */\n\n  ValidationError.prototype[util.inspect.custom] = ValidationError.prototype.inspect;\n}\n\n/*!\n * Helper for JSON.stringify\n */\n\nValidationError.prototype.toJSON = function() {\n  return Object.assign({}, this, { message: this.message });\n};\n\n/*!\n * add message\n */\n\nValidationError.prototype.addError = function(path, error) {\n  this.errors[path] = error;\n  this.message = this._message + ': ' + _generateMessage(this);\n};\n\n/*!\n * ignore\n */\n\nfunction _generateMessage(err) {\n  const keys = Object.keys(err.errors || {});\n  const len = keys.length;\n  const msgs = [];\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (err === err.errors[key]) {\n      continue;\n    }\n    msgs.push(key + ': ' + err.errors[key].message);\n  }\n\n  return msgs.join(', ');\n}\n\n/*!\n * Module exports\n */\n\nmodule.exports = exports = ValidationError;\n","'use strict';\n\nconst castBoolean = require('../../cast/boolean');\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  const path = this != null ? this.path : null;\n  return castBoolean(val, path);\n};\n","'use strict';\n\nconst CastError = require('../error/cast');\n\n/*!\n * Given a value, cast it to a boolean, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {Boolean|null|undefined}\n * @throws {CastError} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castBoolean(value, path) {\n  if (value == null) {\n    return value;\n  }\n\n  if (module.exports.convertToTrue.has(value)) {\n    return true;\n  }\n  if (module.exports.convertToFalse.has(value)) {\n    return false;\n  }\n  throw new CastError('boolean', value, path);\n};\n\nmodule.exports.convertToTrue = new Set([true, 'true', 1, '1', 'yes']);\nmodule.exports.convertToFalse = new Set([false, 'false', 0, '0', 'no']);\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('./');\n\n/**\n * Strict mode error constructor\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nfunction StrictModeError(path, msg) {\n  msg = msg || 'Field `' + path + '` is not in schema and strict ' +\n    'mode is set to throw.';\n  MongooseError.call(this, msg);\n  this.name = 'StrictModeError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.path = path;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nStrictModeError.prototype = Object.create(MongooseError.prototype);\nStrictModeError.prototype.constructor = MongooseError;\n\nmodule.exports = StrictModeError;\n","'use strict';\n\n/**\n * VirtualType constructor\n *\n * This is what mongoose uses to define virtual attributes via `Schema.prototype.virtual`.\n *\n * ####Example:\n *\n *     const fullname = schema.virtual('fullname');\n *     fullname instanceof mongoose.VirtualType // true\n *\n * @param {Object} options\n * @param {string|function} [options.ref] if `ref` is not nullish, this becomes a [populated virtual](/docs/populate.html#populate-virtuals)\n * @param {string|function} [options.localField] the local field to populate on if this is a populated virtual.\n * @param {string|function} [options.foreignField] the foreign field to populate on if this is a populated virtual.\n * @param {boolean} [options.justOne=false] by default, a populated virtual is an array. If you set `justOne`, the populated virtual will be a single doc or `null`.\n * @param {boolean} [options.getters=false] if you set this to `true`, Mongoose will call any custom getters you defined on this virtual\n * @api public\n */\n\nfunction VirtualType(options, name) {\n  this.path = name;\n  this.getters = [];\n  this.setters = [];\n  this.options = Object.assign({}, options);\n}\n\n/**\n * If no getters/getters, add a default\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype._applyDefaultGetters = function() {\n  if (this.getters.length > 0 || this.setters.length > 0) {\n    return;\n  }\n\n  const path = this.path;\n  const internalProperty = '$' + path;\n  this.getters.push(function() {\n    return this[internalProperty];\n  });\n  this.setters.push(function(v) {\n    this[internalProperty] = v;\n  });\n};\n\n/*!\n * ignore\n */\n\nVirtualType.prototype.clone = function() {\n  const clone = new VirtualType(this.name, this.options);\n  clone.getters = [].concat(this.getters);\n  clone.setters = [].concat(this.setters);\n  return clone;\n};\n\n/**\n * Defines a getter.\n *\n * ####Example:\n *\n *     var virtual = schema.virtual('fullname');\n *     virtual.get(function () {\n *       return this.name.first + ' ' + this.name.last;\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.get = function(fn) {\n  this.getters.push(fn);\n  return this;\n};\n\n/**\n * Defines a setter.\n *\n * ####Example:\n *\n *     var virtual = schema.virtual('fullname');\n *     virtual.set(function (v) {\n *       var parts = v.split(' ');\n *       this.name.first = parts[0];\n *       this.name.last = parts[1];\n *     });\n *\n * @param {Function} fn\n * @return {VirtualType} this\n * @api public\n */\n\nVirtualType.prototype.set = function(fn) {\n  this.setters.push(fn);\n  return this;\n};\n\n/**\n * Applies getters to `value` using optional `scope`.\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {any} the value after applying all getters\n * @api public\n */\n\nVirtualType.prototype.applyGetters = function(value, scope) {\n  let v = value;\n  for (let l = this.getters.length - 1; l >= 0; l--) {\n    v = this.getters[l].call(scope, v, this);\n  }\n  return v;\n};\n\n/**\n * Applies setters to `value` using optional `scope`.\n *\n * @param {Object} value\n * @param {Object} scope\n * @return {any} the value after applying all setters\n * @api public\n */\n\nVirtualType.prototype.applySetters = function(value, scope) {\n  let v = value;\n  for (let l = this.setters.length - 1; l >= 0; l--) {\n    v = this.setters[l].call(scope, v, this);\n  }\n  return v;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = VirtualType;\n","'use strict';\n\nlet Document;\nconst get = require('lodash.get');\nconst utils = require('../../utils');\n\n/*!\n * exports\n */\n\nexports.compile = compile;\nexports.defineKey = defineKey;\n\n/*!\n * Compiles schemas.\n */\n\nfunction compile(tree, proto, prefix, options) {\n  Document = Document || require('../../document');\n  const keys = Object.keys(tree);\n  const len = keys.length;\n  let limb;\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    limb = tree[key];\n\n    const hasSubprops = utils.getFunctionName(limb.constructor) === 'Object' &&\n      Object.keys(limb).length &&\n      (!limb[options.typeKey] || (options.typeKey === 'type' && limb.type.type));\n    const subprops = hasSubprops ? limb : null;\n\n    defineKey(key, subprops, proto, prefix, keys, options);\n  }\n}\n\n/*!\n * Defines the accessor named prop on the incoming prototype.\n */\n\nfunction defineKey(prop, subprops, prototype, prefix, keys, options) {\n  Document = Document || require('../../document');\n  const path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        const _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__.scope = this;\n          }\n          nested.$__.nestedPath = path;\n\n          Object.defineProperty(nested, 'schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return utils.clone(_this.get(path, null, {\n                virtuals: get(this, 'schema.options.toObject.virtuals', null)\n              }));\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: get(_this, 'schema.options.toJSON.virtuals', null)\n              });\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v instanceof Document) {\n          v = v.toObject({ transform: false });\n        }\n        const doc = this.$__.scope || this;\n        return doc.$set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this.get.call(this.$__.scope || this, path);\n      },\n      set: function(v) {\n        return this.$set.call(this.$__.scope || this, path, v);\n      }\n    });\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  const result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    // Assume these are schema paths, ignore them re: #5470\n    if (result[key].get) {\n      delete result[key];\n      return;\n    }\n    result[key].enumerable = ['isNew', '$__', 'errors', '_doc'].indexOf(key) === -1;\n  });\n\n  return result;\n}\n","'use strict';\n\nconst utils = require('../../utils');\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'save',\n  'validate',\n  'remove',\n  'init'\n];\n\n/*!\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n\n  model.$appliedHooks = true;\n  for (let i = 0; i < schema.childSchemas.length; ++i) {\n    const childModel = schema.childSchemas[i].model;\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n    applyHooks(childModel, schema.childSchemas[i].schema, options);\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (let j = 0; j < keys.length; ++j) {\n        applyHooks(childModel.discriminators[keys[j]],\n          childModel.discriminators[keys[j]].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.filter(hook => {\n    if (hook.name !== 'remove') {\n      return true;\n    }\n    return hook['document'] == null || !!hook['document'];\n  });\n\n  objToDecorate.$__save = middleware.\n    createWrapper('save', objToDecorate.$__save, null, kareemOptions);\n  objToDecorate.$__validate = middleware.\n    createWrapper('validate', objToDecorate.$__validate, null, kareemOptions);\n  objToDecorate.$__remove = middleware.\n    createWrapper('remove', objToDecorate.$__remove, null, kareemOptions);\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = utils.last(args);\n      const argsWithoutCallback = cb == null ? args :\n        args.slice(0, args.length - 1);\n      return utils.promiseOrCallback(cb, callback => {\n        this[`$__${method}`].apply(this,\n          argsWithoutCallback.concat([callback]));\n      });\n    };\n    objToDecorate[`$__${method}`] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n","\n/*!\n * Module exports.\n */\n\n'use strict';\n\nexports.String = require('./string');\n\nexports.Number = require('./number');\n\nexports.Boolean = require('./boolean');\n\nexports.DocumentArray = require('./documentarray');\n\nexports.Embedded = require('./embedded');\n\nexports.Array = require('./array');\n\nexports.Buffer = require('./buffer');\n\nexports.Date = require('./date');\n\nexports.ObjectId = require('./objectid');\n\nexports.Mixed = require('./mixed');\n\nexports.Decimal128 = exports.Decimal = require('./decimal128');\n\nexports.Map = require('./map');\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;\n","'use strict';\n\n/*!\n * Module requirements.\n */\n\nconst MongooseError = require('../error');\nconst SchemaType = require('../schematype');\nconst castNumber = require('../cast/number');\nconst handleBitwiseOperator = require('./operators/bitwise');\nconst utils = require('../utils');\n\nconst CastError = SchemaType.CastError;\nlet Document;\n\n/**\n * Number SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaNumber(key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaNumber.schemaName = 'Number';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaNumber.prototype = Object.create(SchemaType.prototype);\nSchemaNumber.prototype.constructor = SchemaNumber;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return typeof value === 'number' || value instanceof Number;\n};\n\n/**\n * Sets a minimum number validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ n: { type: Number, min: 10 })\n *     var M = db.model('M', s)\n *     var m = new M({ n: 9 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ n: { type: Number, min: min })\n *     var M = mongoose.model('Measurement', schema);\n *     var s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n *     })\n *\n * @param {Number} value minimum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaNumber.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push({\n      validator: this.minValidator = function(v) {\n        return v == null || v >= value;\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum number validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ n: { type: Number, max: 10 })\n *     var M = db.model('M', s)\n *     var m = new M({ n: 11 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ n: { type: Number, max: max })\n *     var M = mongoose.model('Measurement', schema);\n *     var s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n *     })\n *\n * @param {Number} maximum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaNumber.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push({\n      validator: this.maxValidator = function(v) {\n        return v == null || v <= value;\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to number\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaNumber.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (typeof value === 'number') {\n      return value;\n    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n      throw new CastError('number', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    const path = doc.$__fullPath(this.path);\n    const owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    const pop = owner.populated(path, true);\n    const ret = new pop.options.model(value);\n    ret.$__.wasPopulated = true;\n    return ret;\n  }\n\n  const val = value && typeof value._id !== 'undefined' ?\n    value._id : // documents\n    value;\n\n  return castNumber(val, this.path);\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nfunction handleArray(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.cast(val)];\n  }\n  return val.map(function(m) {\n    return _this.cast(m);\n  });\n}\n\nSchemaNumber.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $bitsAllClear: handleBitwiseOperator,\n      $bitsAnyClear: handleBitwiseOperator,\n      $bitsAllSet: handleBitwiseOperator,\n      $bitsAnySet: handleBitwiseOperator,\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle,\n      $mod: handleArray\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaNumber.prototype.castForQuery = function($conditional, val) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new CastError('Can\\'t use ' + $conditional + ' with Number.');\n    }\n    return handler.call(this, val);\n  }\n  val = this._castForQuery($conditional);\n  return val;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaNumber;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Types = {\n  Array: SchemaArray,\n  Boolean: require('./boolean'),\n  Date: require('./date'),\n  Number: require('./number'),\n  String: require('./string'),\n  ObjectId: require('./objectid'),\n  Buffer: require('./buffer'),\n  Map: require('./map')\n};\nconst Mixed = require('./mixed');\nconst cast = require('../cast');\nconst get = require('lodash.get');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../queryhelpers').getDiscriminatorByValue;\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.getFunctionName(cast.constructor) === 'Object') {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = utils.clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const caster = name in Types\n      ? Types[name]\n      : cast;\n\n    this.casterConstructor = caster;\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      this.caster = new caster(null, castOptions);\n    } else {\n      this.caster = caster;\n    }\n\n    if (!(this.caster instanceof EmbeddedDoc)) {\n      this.caster.path = key;\n    }\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue !== void 0) {\n    const defaultFn = function() {\n      let arr = [];\n      if (fn) {\n        arr = defaultArr.call(this);\n      } else if (defaultArr != null) {\n        arr = arr.concat(defaultArr);\n      }\n      // Leave it up to `cast()` to convert the array\n      return arr;\n    };\n    defaultFn.$runBeforeSetters = true;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\n\n/**\n * Adds an enum validator if this is an array of strings. Equivalent to\n * `SchemaString.prototype.enum()`\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaType} this\n */\n\nSchemaArray.prototype.enum = function() {\n  const instance = get(this, 'caster.instance');\n  if (instance !== 'String') {\n    throw new Error('`enum` can only be set on an array of strings, not ' + instance);\n  }\n  this.caster.enum.apply(this.caster, arguments);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (this.caster.options && this.caster.options.ref) {\n    // means the object id was populated\n    return value;\n  }\n\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    if (!value.length && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][this.path];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n    }\n\n    if (!(value && value.isMongooseArray)) {\n      value = new MongooseArray(value, this.path, doc);\n    } else if (value && value.isMongooseArray) {\n      // We need to create a new array, otherwise change tracking will\n      // update the old doc (gh-4449)\n      value = new MongooseArray(value, this.path, doc);\n    }\n\n    if (this.caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0, l = value.length; i < l; i++) {\n          value[i] = this.caster.cast(value[i], doc, init);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path, e);\n      }\n    }\n\n    return value;\n  }\n  // gh-2442: if we're loading this from the db and its not an array, mark\n  // the whole array as modified.\n  if (!!doc && !!init) {\n    doc.markModified(this.path);\n  }\n  return this.cast([value], doc, init);\n};\n\n/*!\n * Ignore\n */\n\nSchemaArray.prototype.discriminator = function(name, schema) {\n  let arr = this; // eslint-disable-line consistent-this\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(name, schema);\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, value) {\n  let handler;\n  let val;\n\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    val = handler.call(this, value);\n  } else {\n    val = $conditional;\n    let Constructor = this.casterConstructor;\n\n    if (val &&\n        Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        Constructor.schema.options.discriminatorKey) {\n      if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n          Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, val[Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    const proto = this.casterConstructor.prototype;\n    let method = proto && (proto.castForQuery || proto.cast);\n    if (!method && Constructor.castForQuery) {\n      method = Constructor.castForQuery;\n    }\n    const caster = this.caster;\n\n    if (Array.isArray(val)) {\n      this.setters.reverse().forEach(setter => {\n        val = setter.call(this, val, this);\n      });\n      val = val.map(function(v) {\n        if (utils.isObject(v) && v.$elemMatch) {\n          return v;\n        }\n        if (method) {\n          v = method.call(caster, v);\n          return v;\n        }\n        if (v != null) {\n          v = new Constructor(v);\n          return v;\n        }\n        return v;\n      });\n    } else if (method) {\n      val = method.call(caster, val);\n    } else if (val != null) {\n      val = new Constructor(val);\n    }\n  }\n\n  return val;\n};\n\nfunction cast$all(val) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map(function(v) {\n    if (utils.isObject(v)) {\n      const o = {};\n      o[this.path] = v;\n      return cast(this.casterConstructor.schema, o)[this.path];\n    }\n    return v;\n  }, this);\n\n  return this.castForQuery(val);\n}\n\nfunction cast$elemMatch(val) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  let key;\n  let value;\n  for (let i = 0; i < numKeys; ++i) {\n    key = keys[i];\n    value = val[key];\n    if (key.indexOf('$') === 0 && value) {\n      val[key] = this.castForQuery(key, value);\n    }\n  }\n\n  return cast(this.casterConstructor.schema, val);\n}\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = handle.$and = function(val) {\n  if (!Array.isArray(val)) {\n    throw new TypeError('conditional $or/$and require array');\n  }\n\n  const ret = [];\n  for (let i = 0; i < val.length; ++i) {\n    ret.push(cast(this.casterConstructor.schema, val[i]));\n  }\n\n  return ret;\n};\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$ne =\nhandle.$nin =\nhandle.$regex = SchemaArray.prototype.castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst SchemaType = require('../schematype');\nconst oid = require('../types/objectid');\nconst utils = require('../utils');\n\nconst CastError = SchemaType.CastError;\nlet Document;\n\n/**\n * ObjectId SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction ObjectId(key, options) {\n  const isKeyHexStr = typeof key === 'string' && key.length === 24 && /^[a-f0-9]+$/i.test(key);\n  const suppressWarning = options && options.suppressWarning;\n  if ((isKeyHexStr || typeof key === 'undefined') && !suppressWarning) {\n    console.warn('mongoose: To create a new ObjectId please try ' +\n      '`Mongoose.Types.ObjectId` instead of using ' +\n      '`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if ' +\n      'you\\'re trying to create a hex char path in your schema.');\n    console.trace();\n  }\n  SchemaType.call(this, key, options, 'ObjectID');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nObjectId.schemaName = 'ObjectId';\n\n/*!\n * Inherits from SchemaType.\n */\nObjectId.prototype = Object.create(SchemaType.prototype);\nObjectId.prototype.constructor = ObjectId;\n\n/**\n * Adds an auto-generated ObjectId default if turnOn is true.\n * @param {Boolean} turnOn auto generated ObjectId defaults\n * @api public\n * @return {SchemaType} this\n */\n\nObjectId.prototype.auto = function(turnOn) {\n  if (turnOn) {\n    this.default(defaultId);\n    this.set(resetId);\n  }\n\n  return this;\n};\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nObjectId.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return value instanceof oid;\n};\n\n/**\n * Casts to ObjectId\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nObjectId.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (value instanceof oid) {\n      return value;\n    } else if ((value.constructor.name || '').toLowerCase() === 'objectid') {\n      return new oid(value.toHexString());\n    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n      throw new CastError('ObjectId', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    const path = doc.$__fullPath(this.path);\n    const owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    const pop = owner.populated(path, true);\n    let ret = value;\n    if (!doc.$__.populated ||\n        !doc.$__.populated[path] ||\n        !doc.$__.populated[path].options ||\n        !doc.$__.populated[path].options.options ||\n        !doc.$__.populated[path].options.options.lean) {\n      ret = new pop.options.model(value);\n      ret.$__.wasPopulated = true;\n    }\n\n    return ret;\n  }\n\n  if (value === null || value === undefined) {\n    return value;\n  }\n\n  if (value instanceof oid) {\n    return value;\n  }\n\n  if (value._id) {\n    if (value._id instanceof oid) {\n      return value._id;\n    }\n    if (value._id.toString instanceof Function) {\n      return new oid(value._id.toString());\n    }\n  }\n\n  if (value.toString instanceof Function) {\n    try {\n      return new oid(value.toString());\n    } catch (err) {\n      throw new CastError('ObjectId', value, this.path);\n    }\n  }\n\n  throw new CastError('ObjectId', value, this.path);\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nObjectId.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/*!\n * ignore\n */\n\nfunction defaultId() {\n  return new oid();\n}\n\ndefaultId.$runBeforeSetters = true;\n\nfunction resetId(v) {\n  Document || (Document = require('./../document'));\n\n  if (this instanceof Document) {\n    if (v === void 0) {\n      const _v = new oid;\n      this.$__._id = _v;\n      return _v;\n    }\n\n    this.$__._id = v;\n  }\n\n  return v;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = ObjectId;\n","'use strict';\n\nconst Mixed = require('../schema/mixed');\nconst util = require('util');\n\n/*!\n * ignore\n */\n\nclass MongooseMap extends Map {\n  constructor(v, path, doc, schemaType) {\n    if (v != null && v.constructor.name === 'Object') {\n      v = Object.keys(v).reduce((arr, key) => arr.concat([[key, v[key]]]), []);\n    }\n    super(v);\n\n    this.$__parent = doc != null && doc.$__ != null ? doc : null;\n    this.$__path = path;\n    this.$__schemaType = schemaType == null ? new Mixed(path) : schemaType;\n\n    this.$__runDeferred();\n  }\n\n  $init(key, value) {\n    checkValidKey(key);\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n  }\n\n  set(key, value) {\n    checkValidKey(key);\n\n    // Weird, but because you can't assign to `this` before calling `super()`\n    // you can't get access to `$__schemaType` to cast in the initial call to\n    // `set()` from the `super()` constructor.\n\n    if (this.$__schemaType == null) {\n      this.$__deferred = this.$__deferred || [];\n      this.$__deferred.push({ key: key, value: value });\n      return;\n    }\n\n    const fullPath = this.$__path + '.' + key;\n    const populated = this.$__parent != null && this.$__parent.$__ ?\n      this.$__parent.populated(fullPath) || this.$__parent.populated(this.$__path) :\n      null;\n\n    if (populated != null) {\n      if (value.$__ == null) {\n        value = new populated.options.model(value);\n      }\n      value.$__.wasPopulated = true;\n    } else {\n      try {\n        value = this.$__schemaType.\n          applySetters(value, this.$__parent, false, this.get(key));\n      } catch (error) {\n        if (this.$__parent != null && this.$__parent.$__ != null) {\n          this.$__parent.invalidate(fullPath, error);\n          return;\n        }\n        throw error;\n      }\n    }\n\n    super.set(key, value);\n\n    if (value != null && value.$isSingleNested) {\n      value.$basePath = this.$__path + '.' + key;\n    }\n\n    if (this.$__parent != null && this.$__parent.$__) {\n      this.$__parent.markModified(this.$__path + '.' + key);\n    }\n  }\n\n  toBSON() {\n    return new Map(this);\n  }\n\n  toObject() {\n    return new Map(this);\n  }\n\n  toJSON() {\n    const ret = {};\n    const keys = this.keys();\n    for (const key of keys) {\n      ret[key] = this.get(key);\n    }\n    return ret;\n  }\n\n  inspect() {\n    return new Map(this);\n  }\n\n  $__runDeferred() {\n    if (!this.$__deferred) {\n      return;\n    }\n    for (let i = 0; i < this.$__deferred.length; ++i) {\n      this.set(this.$__deferred[i].key, this.$__deferred[i].value);\n    }\n    this.$__deferred = null;\n  }\n}\n\nif (util.inspect.custom) {\n  Object.defineProperty(MongooseMap.prototype, util.inspect.custom, {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: MongooseMap.prototype.inspect\n  });\n}\n\nObject.defineProperty(MongooseMap.prototype, '$__parent', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__path', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__schemaType', {\n  enumerable: false,\n  writable: true,\n  configurable: false\n});\n\nObject.defineProperty(MongooseMap.prototype, '$isMongooseMap', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\nObject.defineProperty(MongooseMap.prototype, '$__deferredCalls', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: true\n});\n\n/*!\n * Since maps are stored as objects under the hood, keys must be strings\n * and can't contain any invalid characters\n */\n\nfunction checkValidKey(key) {\n  const keyType = typeof key;\n  if (keyType !== 'string') {\n    throw new TypeError(`Mongoose maps only support string keys, got ${keyType}`);\n  }\n  if (key.startsWith('$')) {\n    throw new Error(`Mongoose maps do not support keys that start with \"$\", got \"${key}\"`);\n  }\n  if (key.includes('.')) {\n    throw new Error(`Mongoose maps do not support keys that contain \".\", got \"${key}\"`);\n  }\n}\n\nmodule.exports = MongooseMap;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('lodash.get');\nconst util = require('util');\nconst utils = require('./utils');\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} options the query options\n * @param {Query} context passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      let k = val.length;\n\n      while (k--) {\n        val[k] = cast(schema, val[k], options, context);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = get(_schematype, 'schema.options.discriminatorKey');\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n              get(_schematype, 'schema.discriminators') != null &&\n              discriminatorKey != null &&\n              pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            if (discriminatorVal) {\n              schematype = _schematype.schema.discriminators[discriminatorVal].\n                path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQueryWrapper({\n                val: val.$maxDistance,\n                context: context\n              });\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQueryWrapper({\n                val: val.$minDistance,\n                context: context\n              });\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQueryWrapper({\n                  val: value.$maxDistance,\n                  context: context\n                });\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQueryWrapper({\n                  val: value.$minDistance,\n                  context: context\n                });\n              }\n              if (utils.isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (utils.isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (utils.isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n        if (options.upsert && options.strict) {\n          if (options.strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } else if (options.strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is true.');\n        } else if (options.strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (val.constructor.name === 'Object') {\n        any$conditionals = Object.keys(val).some(function(k) {\n          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQueryWrapper({\n            val: val,\n            context: context\n          });\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ($cond === '$not') {\n              if (nested && schematype && !schematype.caster) {\n                _keys = Object.keys(nested);\n                if (_keys.length && _keys[0].charAt(0) === '$') {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQueryWrapper({\n                      $conditional: key,\n                      val: nested[key],\n                      context: context\n                    });\n                  }\n                } else {\n                  val[$cond] = schematype.castForQueryWrapper({\n                    $conditional: $cond,\n                    val: nested,\n                    context: context\n                  });\n                }\n                continue;\n              }\n              cast(schematype.caster ? schematype.caster.schema : schema, nested, options, context);\n            } else {\n              val[$cond] = schematype.castForQueryWrapper({\n                $conditional: $cond,\n                val: nested,\n                context: context\n              });\n            }\n          }\n        }\n      } else if (val.constructor.name === 'Array' && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        for (let valIndex = 0; valIndex < val.length; valIndex++) {\n          casted.push(schematype.castForQueryWrapper({\n            val: val[valIndex],\n            context: context\n          }));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQueryWrapper({\n          val: val,\n          context: context\n        });\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || utils.isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQueryWrapper({ val: item, context: context });\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || utils.isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst EmbeddedDocument = require('./embedded');\nconst Document = require('../document');\nconst ObjectId = require('./objectid');\nconst cleanModifiedSubpaths = require('../helpers/document/cleanModifiedSubpaths');\nconst get = require('lodash.get');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst utils = require('../utils');\nconst util = require('util');\n\nconst isMongooseObject = utils.isMongooseObject;\n\n/**\n * Mongoose Array constructor.\n *\n * ####NOTE:\n *\n * _Values always have to be passed to the constructor to initialize, otherwise `MongooseArray#push` will mark the array as modified._\n *\n * @param {Array} values\n * @param {String} path\n * @param {Document} doc parent document\n * @api private\n * @inherits Array\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseArray(values, path, doc) {\n  const arr = [].concat(values);\n\n  const keysMA = Object.keys(MongooseArray.mixin);\n  const numKeys = keysMA.length;\n  for (let i = 0; i < numKeys; ++i) {\n    arr[keysMA[i]] = MongooseArray.mixin[keysMA[i]];\n  }\n\n  arr._path = path;\n  arr.isMongooseArray = true;\n  arr.validators = [];\n  arr._atomics = {};\n  arr._schema = void 0;\n  if (util.inspect.custom) {\n    arr[util.inspect.custom] = arr.inspect;\n  }\n\n  // Because doc comes from the context of another function, doc === global\n  // can happen if there was a null somewhere up the chain (see #3020)\n  // RB Jun 17, 2015 updated to check for presence of expected paths instead\n  // to make more proof against unusual node environments\n  if (doc && doc instanceof Document) {\n    arr._parent = doc;\n    arr._schema = doc.schema.path(path);\n  }\n\n  return arr;\n}\n\nMongooseArray.mixin = {\n  /*!\n   * ignore\n   */\n  toBSON: function() {\n    return this.toObject(internalToObjectOptions);\n  },\n\n  /**\n   * Stores a queue of atomic operations to perform\n   *\n   * @property _atomics\n   * @api private\n   */\n\n  _atomics: undefined,\n\n  /**\n   * Parent owner document\n   *\n   * @property _parent\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _parent: undefined,\n\n  /**\n   * Casts a member based on this arrays schema.\n   *\n   * @param {any} value\n   * @return value the casted value\n   * @method _cast\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _cast: function(value) {\n    let populated = false;\n    let Model;\n\n    if (this._parent) {\n      populated = this._parent.populated(this._path, true);\n    }\n\n    if (populated && value !== null && value !== undefined) {\n      // cast to the populated Models schema\n      Model = populated.options.model || populated.options.Model;\n\n      // only objects are permitted so we can safely assume that\n      // non-objects are to be interpreted as _id\n      if (Buffer.isBuffer(value) ||\n          value instanceof ObjectId || !utils.isObject(value)) {\n        value = {_id: value};\n      }\n\n      // gh-2399\n      // we should cast model only when it's not a discriminator\n      const isDisc = value.schema && value.schema.discriminatorMapping &&\n          value.schema.discriminatorMapping.key !== undefined;\n      if (!isDisc) {\n        value = new Model(value);\n      }\n      return this._schema.caster.applySetters(value, this._parent, true);\n    }\n\n    return this._schema.caster.applySetters(value, this._parent, false);\n  },\n\n  /**\n   * Marks this array as modified.\n   *\n   * If it bubbles up from an embedded document change, then it takes the following arguments (otherwise, takes 0 arguments)\n   *\n   * @param {EmbeddedDocument} embeddedDoc the embedded doc that invoked this method on the Array\n   * @param {String} embeddedPath the path which changed in the embeddedDoc\n   * @method _markModified\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _markModified: function(elem, embeddedPath) {\n    const parent = this._parent;\n    let dirtyPath;\n\n    if (parent) {\n      dirtyPath = this._path;\n\n      if (arguments.length) {\n        if (embeddedPath != null) {\n          // an embedded doc bubbled up the change\n          dirtyPath = dirtyPath + '.' + this.indexOf(elem) + '.' + embeddedPath;\n        } else {\n          // directly set an index\n          dirtyPath = dirtyPath + '.' + elem;\n        }\n      }\n\n      parent.markModified(dirtyPath, arguments.length > 0 ? elem : parent);\n    }\n\n    return this;\n  },\n\n  /**\n   * Register an atomic operation with the parent.\n   *\n   * @param {Array} op operation\n   * @param {any} val\n   * @method _registerAtomic\n   * @api private\n   * @memberOf MongooseArray\n   */\n\n  _registerAtomic: function(op, val) {\n    if (op === '$set') {\n      // $set takes precedence over all other ops.\n      // mark entire array modified.\n      this._atomics = {$set: val};\n      return this;\n    }\n\n    const atomics = this._atomics;\n\n    // reset pop/shift after save\n    if (op === '$pop' && !('$pop' in atomics)) {\n      const _this = this;\n      this._parent.once('save', function() {\n        _this._popped = _this._shifted = null;\n      });\n    }\n\n    // check for impossible $atomic combos (Mongo denies more than one\n    // $atomic op on a single path\n    if (this._atomics.$set ||\n        Object.keys(atomics).length && !(op in atomics)) {\n      // a different op was previously registered.\n      // save the entire thing.\n      this._atomics = {$set: this};\n      return this;\n    }\n\n    let selector;\n\n    if (op === '$pullAll' || op === '$addToSet') {\n      atomics[op] || (atomics[op] = []);\n      atomics[op] = atomics[op].concat(val);\n    } else if (op === '$pullDocs') {\n      const pullOp = atomics['$pull'] || (atomics['$pull'] = {});\n      if (val[0] instanceof EmbeddedDocument) {\n        selector = pullOp['$or'] || (pullOp['$or'] = []);\n        Array.prototype.push.apply(selector, val.map(function(v) {\n          return v.toObject({transform: false, virtuals: false});\n        }));\n      } else {\n        selector = pullOp['_id'] || (pullOp['_id'] = {$in: []});\n        selector['$in'] = selector['$in'].concat(val);\n      }\n    } else if (op === '$push') {\n      atomics.$push = atomics.$push || { $each: [] };\n      atomics.$push.$each = atomics.$push.$each.concat(val);\n    } else {\n      atomics[op] = val;\n    }\n\n    return this;\n  },\n\n  /**\n   * Depopulates stored atomic operation values as necessary for direct insertion to MongoDB.\n   *\n   * If no atomics exist, we return all array values after conversion.\n   *\n   * @return {Array}\n   * @method $__getAtomics\n   * @memberOf MongooseArray\n   * @instance\n   * @api private\n   */\n\n  $__getAtomics: function() {\n    const ret = [];\n    const keys = Object.keys(this._atomics);\n    let i = keys.length;\n\n    const opts = Object.assign({}, internalToObjectOptions, { _isNested: true });\n\n    if (i === 0) {\n      ret[0] = ['$set', this.toObject(opts)];\n      return ret;\n    }\n\n    while (i--) {\n      const op = keys[i];\n      let val = this._atomics[op];\n\n      // the atomic values which are arrays are not MongooseArrays. we\n      // need to convert their elements as if they were MongooseArrays\n      // to handle populated arrays versus DocumentArrays properly.\n      if (isMongooseObject(val)) {\n        val = val.toObject(opts);\n      } else if (Array.isArray(val)) {\n        val = this.toObject.call(val, opts);\n      } else if (val != null && Array.isArray(val.$each)) {\n        val.$each = this.toObject.call(val.$each, opts);\n      } else if (val.valueOf) {\n        val = val.valueOf();\n      }\n\n      if (op === '$addToSet') {\n        val = {$each: val};\n      }\n\n      ret.push([op, val]);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Returns the number of pending atomic operations to send to the db for this array.\n   *\n   * @api private\n   * @return {Number}\n   * @method hasAtomics\n   * @memberOf MongooseArray\n   */\n\n  hasAtomics: function hasAtomics() {\n    if (!(this._atomics && this._atomics.constructor.name === 'Object')) {\n      return 0;\n    }\n\n    return Object.keys(this._atomics).length;\n  },\n\n  /**\n   * Internal helper for .map()\n   *\n   * @api private\n   * @return {Number}\n   * @method _mapCast\n   * @memberOf MongooseArray\n   */\n  _mapCast: function(val, index) {\n    return this._cast(val, this.length + index);\n  },\n\n  /**\n   * Wraps [`Array#push`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/push) with proper change tracking.\n   *\n   * @param {Object} [args...]\n   * @api public\n   * @method push\n   * @memberOf MongooseArray\n   */\n\n  push: function() {\n    _checkManualPopulation(this, arguments);\n    let values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent, undefined,\n      undefined, { skipDocumentArrayCast: true });\n    const ret = [].push.apply(this, values);\n\n    this._registerAtomic('$push', values);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pushes items to the array non-atomically.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @param {any} [args...]\n   * @api public\n   * @method nonAtomicPush\n   * @memberOf MongooseArray\n   */\n\n  nonAtomicPush: function() {\n    const values = [].map.call(arguments, this._mapCast, this);\n    const ret = [].push.apply(this, values);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pops the array atomically at most one time per document `save()`.\n   *\n   * #### NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var popped = doc.array.$pop();\n   *      console.log(popped); // 3\n   *      console.log(doc.array); // [1,2]\n   *\n   *      // no affect\n   *      popped = doc.array.$pop();\n   *      console.log(doc.array); // [1,2]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $pop works again\n   *        popped = doc.array.$pop();\n   *        console.log(popped); // 2\n   *        console.log(doc.array); // [1]\n   *      })\n   *\n   * @api public\n   * @method $pop\n   * @memberOf MongooseArray\n   * @instance\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   * @method $pop\n   * @memberOf MongooseArray\n   */\n\n  $pop: function() {\n    this._registerAtomic('$pop', 1);\n    this._markModified();\n\n    // only allow popping once\n    if (this._popped) {\n      return;\n    }\n    this._popped = true;\n\n    return [].pop.call(this);\n  },\n\n  /**\n   * Wraps [`Array#pop`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/pop) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified which will pass the entire thing to $set potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @see MongooseArray#$pop #types_array_MongooseArray-%24pop\n   * @api public\n   * @method pop\n   * @memberOf MongooseArray\n   */\n\n  pop: function() {\n    const ret = [].pop.call(this);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Atomically shifts the array at most one time per document `save()`.\n   *\n   * ####NOTE:\n   *\n   * _Calling this mulitple times on an array before saving sends the same command as calling it once._\n   * _This update is implemented using the MongoDB [$pop](http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop) method which enforces this restriction._\n   *\n   *      doc.array = [1,2,3];\n   *\n   *      var shifted = doc.array.$shift();\n   *      console.log(shifted); // 1\n   *      console.log(doc.array); // [2,3]\n   *\n   *      // no affect\n   *      shifted = doc.array.$shift();\n   *      console.log(doc.array); // [2,3]\n   *\n   *      doc.save(function (err) {\n   *        if (err) return handleError(err);\n   *\n   *        // we saved, now $shift works again\n   *        shifted = doc.array.$shift();\n   *        console.log(shifted ); // 2\n   *        console.log(doc.array); // [3]\n   *      })\n   *\n   * @api public\n   * @memberOf MongooseArray\n   * @instance\n   * @method $shift\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pop\n   */\n\n  $shift: function $shift() {\n    this._registerAtomic('$pop', -1);\n    this._markModified();\n\n    // only allow shifting once\n    if (this._shifted) {\n      return;\n    }\n    this._shifted = true;\n\n    return [].shift.call(this);\n  },\n\n  /**\n   * Wraps [`Array#shift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Example:\n   *\n   *     doc.array = [2,3];\n   *     var res = doc.array.shift();\n   *     console.log(res) // 2\n   *     console.log(doc.array) // [3]\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method shift\n   * @memberOf MongooseArray\n   */\n\n  shift: function() {\n    const ret = [].shift.call(this);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Pulls items from the array atomically. Equality is determined by casting\n   * the provided value to an embedded document and comparing using\n   * [the `Document.equals()` function.](./api.html#document_Document-equals)\n   *\n   * ####Examples:\n   *\n   *     doc.array.pull(ObjectId)\n   *     doc.array.pull({ _id: 'someId' })\n   *     doc.array.pull(36)\n   *     doc.array.pull('tag 1', 'tag 2')\n   *\n   * To remove a document from a subdocument array we may pass an object with a matching `_id`.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull({ _id: 4815162342 }) // removed\n   *\n   * Or we may passing the _id directly and let mongoose take care of it.\n   *\n   *     doc.subdocs.push({ _id: 4815162342 })\n   *     doc.subdocs.pull(4815162342); // works\n   *\n   * The first pull call will result in a atomic operation on the database, if pull is called repeatedly without saving the document, a $set operation is used on the complete array instead, overwriting possible changes that happened on the database in the meantime.\n   *\n   * @param {any} [args...]\n   * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n   * @api public\n   * @method pull\n   * @memberOf MongooseArray\n   */\n\n  pull: function() {\n    const values = [].map.call(arguments, this._cast, this);\n    const cur = this._parent.get(this._path);\n    let i = cur.length;\n    let mem;\n\n    while (i--) {\n      mem = cur[i];\n      if (mem instanceof Document) {\n        const some = values.some(function(v) {\n          return mem.equals(v);\n        });\n        if (some) {\n          [].splice.call(cur, i, 1);\n        }\n      } else if (~cur.indexOf.call(values, mem)) {\n        [].splice.call(cur, i, 1);\n      }\n    }\n\n    if (values[0] instanceof EmbeddedDocument) {\n      this._registerAtomic('$pullDocs', values.map(function(v) {\n        return v._id || v;\n      }));\n    } else {\n      this._registerAtomic('$pullAll', values);\n    }\n\n    this._markModified();\n\n    // Might have modified child paths and then pulled, like\n    // `doc.children[1].name = 'test';` followed by\n    // `doc.children.remove(doc.children[0]);`. In this case we fall back\n    // to a `$set` on the whole array. See #3511\n    if (cleanModifiedSubpaths(this._parent, this._path) > 0) {\n      this._registerAtomic('$set', this);\n    }\n\n    return this;\n  },\n\n  /**\n   * Wraps [`Array#splice`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/splice) with proper change tracking and casting.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method splice\n   * @memberOf MongooseArray\n   */\n\n  splice: function splice() {\n    let ret;\n\n    _checkManualPopulation(this, Array.prototype.slice.call(arguments, 2));\n\n    if (arguments.length) {\n      const vals = [];\n      for (let i = 0; i < arguments.length; ++i) {\n        vals[i] = i < 2 ?\n          arguments[i] :\n          this._cast(arguments[i], arguments[0] + (i - 2));\n      }\n      ret = [].splice.apply(this, vals);\n      this._registerAtomic('$set', this);\n      this._markModified();\n      cleanModifiedSubpaths(this._parent, this._path);\n    }\n\n    return ret;\n  },\n\n  /**\n   * Wraps [`Array#unshift`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/unshift) with proper change tracking.\n   *\n   * ####Note:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method unshift\n   * @memberOf MongooseArray\n   */\n\n  unshift: function() {\n    _checkManualPopulation(this, arguments);\n\n    let values = [].map.call(arguments, this._cast, this);\n    values = this._schema.applySetters(values, this._parent);\n    [].unshift.apply(this, values);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return this.length;\n  },\n\n  /**\n   * Wraps [`Array#sort`](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort) with proper change tracking.\n   *\n   * ####NOTE:\n   *\n   * _marks the entire array as modified, which if saved, will store it as a `$set` operation, potentially overwritting any changes that happen between when you retrieved the object and when you save it._\n   *\n   * @api public\n   * @method sort\n   * @memberOf MongooseArray\n   */\n\n  sort: function() {\n    const ret = [].sort.apply(this, arguments);\n    this._registerAtomic('$set', this);\n    this._markModified();\n    return ret;\n  },\n\n  /**\n   * Adds values to the array if not already present.\n   *\n   * ####Example:\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *     var added = doc.array.addToSet(4,5);\n   *     console.log(doc.array) // [2,3,4,5]\n   *     console.log(added)     // [5]\n   *\n   * @param {any} [args...]\n   * @return {Array} the values that were added\n   * @memberOf MongooseArray\n   * @api public\n   * @method addToSet\n   */\n\n  addToSet: function addToSet() {\n    _checkManualPopulation(this, arguments);\n\n    let values = [].map.call(arguments, this._mapCast, this);\n    values = this._schema.applySetters(values, this._parent);\n    const added = [];\n    let type = '';\n    if (values[0] instanceof EmbeddedDocument) {\n      type = 'doc';\n    } else if (values[0] instanceof Date) {\n      type = 'date';\n    }\n\n    values.forEach(function(v) {\n      let found;\n      const val = +v;\n      switch (type) {\n        case 'doc':\n          found = this.some(function(doc) {\n            return doc.equals(v);\n          });\n          break;\n        case 'date':\n          found = this.some(function(d) {\n            return +d === val;\n          });\n          break;\n        default:\n          found = ~this.indexOf(v);\n      }\n\n      if (!found) {\n        [].push.call(this, v);\n        this._registerAtomic('$addToSet', v);\n        this._markModified();\n        [].push.call(added, v);\n      }\n    }, this);\n\n    return added;\n  },\n\n  /**\n   * Sets the casted `val` at index `i` and marks the array modified.\n   *\n   * ####Example:\n   *\n   *     // given documents based on the following\n   *     var Doc = mongoose.model('Doc', new Schema({ array: [Number] }));\n   *\n   *     var doc = new Doc({ array: [2,3,4] })\n   *\n   *     console.log(doc.array) // [2,3,4]\n   *\n   *     doc.array.set(1,\"5\");\n   *     console.log(doc.array); // [2,5,4] // properly cast to number\n   *     doc.save() // the change is saved\n   *\n   *     // VS not using array#set\n   *     doc.array[1] = \"5\";\n   *     console.log(doc.array); // [2,\"5\",4] // no casting\n   *     doc.save() // change is not saved\n   *\n   * @return {Array} this\n   * @api public\n   * @method set\n   * @memberOf MongooseArray\n   */\n\n  set: function set(i, val) {\n    const value = this._cast(val, i);\n    this[i] = value;\n    this._markModified(i);\n    return this;\n  },\n\n  /**\n   * Returns a native js Array.\n   *\n   * @param {Object} options\n   * @return {Array}\n   * @api public\n   * @method toObject\n   * @memberOf MongooseArray\n   */\n\n  toObject: function(options) {\n    if (options && options.depopulate) {\n      options = utils.clone(options);\n      options._isNested = true;\n      return this.map(function(doc) {\n        return doc instanceof Document\n          ? doc.toObject(options)\n          : doc;\n      });\n    }\n\n    return this.slice();\n  },\n\n  /**\n   * Helper for console.log\n   *\n   * @api public\n   * @method inspect\n   * @memberOf MongooseArray\n   */\n\n  inspect: function() {\n    return JSON.stringify(this);\n  },\n\n  /**\n   * Return the index of `obj` or `-1` if not found.\n   *\n   * @param {Object} obj the item to look for\n   * @return {Number}\n   * @api public\n   * @method indexOf\n   * @memberOf MongooseArray\n   */\n\n  indexOf: function indexOf(obj) {\n    if (obj instanceof ObjectId) {\n      obj = obj.toString();\n    }\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (obj == this[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n};\n\n/**\n * Alias of [pull](#types_array_MongooseArray-pull)\n *\n * @see MongooseArray#pull #types_array_MongooseArray-pull\n * @see mongodb http://www.mongodb.org/display/DOCS/Updating/#Updating-%24pull\n * @api public\n * @memberOf MongooseArray\n * @instance\n * @method remove\n */\n\nMongooseArray.mixin.remove = MongooseArray.mixin.pull;\n\n/*!\n * ignore\n */\n\nfunction _isAllSubdocs(docs, ref) {\n  if (!ref) {\n    return false;\n  }\n  for (let i = 0; i < docs.length; ++i) {\n    const arg = docs[i];\n    if (arg == null) {\n      return false;\n    }\n    const model = arg.constructor;\n    if (!(arg instanceof Document) ||\n      (model.modelName !== ref && model.baseModelName !== ref)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/*!\n * ignore\n */\n\nfunction _checkManualPopulation(arr, docs) {\n  const ref = get(arr, '_schema.caster.options.ref', null);\n  if (arr.length === 0 &&\n      docs.length > 0) {\n    if (_isAllSubdocs(docs, ref)) {\n      arr._parent.populated(arr._path, [], { model: docs[0].constructor });\n    }\n  }\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = MongooseArray;\n","'use strict';\n\nconst defineKey = require('../document/compile').defineKey;\nconst utils = require('../../utils');\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true\n};\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  if (model.base && model.base.options.applyPluginsToDiscriminators) {\n    model.base._applyPlugins(schema);\n  }\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const baseSchemaAddition = {};\n  baseSchemaAddition[key] = {\n    default: void 0,\n    select: true,\n    $skipDiscriminatorCheck: true\n  };\n  baseSchemaAddition[key][model.schema.options.typeKey] = String;\n  model.schema.add(baseSchemaAddition);\n  defineKey(key, null, model.prototype, null, [key], model.schema.options);\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if (typeof tiedValue == 'string' && tiedValue.length) {\n    value = tiedValue;\n  }\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._originalSchema = schema.clone();\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      const originalSchema = schema;\n      utils.merge(schema, originalSchema);\n      delete schema.paths._id;\n      delete schema.tree._id;\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n    for (let i = 0; i < baseSchemaPaths.length; ++i) {\n      if (schema.nested[baseSchemaPaths[i]]) {\n        conflictingPaths.push(baseSchemaPaths[i]);\n      }\n    }\n\n    utils.merge(schema, baseSchema, {\n      omit: { discriminators: true, $parentSchema: true },\n      omitNested: conflictingPaths.reduce((cur, path) => {\n        cur['tree.' + path] = true;\n        return cur;\n      }, {})\n    });\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (let i = 0; i < conflictingPaths.length; ++i) {\n      delete schema.paths[conflictingPaths[i]];\n    }\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = String;\n    schema.add(obj);\n    schema.discriminatorMapping = {key: key, value: value, isRoot: false};\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n\n    for (let i = 0; i < keys.length; ++i) {\n      const _key = keys[i];\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        if (!utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n              ' (can only modify ' +\n              Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n              ')');\n        }\n      }\n    }\n\n    schema.options = utils.clone(baseSchema.options);\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n\n    schema.plugins = Array.prototype.slice(baseSchema.plugins);\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = {key: key, value: null, isRoot: true};\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name]) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('./error/cast');\nconst ObjectParameterError = require('./error/objectParameter');\nconst QueryCursor = require('./cursor/QueryCursor');\nconst ReadPreference = require('./driver').get().ReadPreference;\nconst applyWriteConcern = require('./helpers/schema/applyWriteConcern');\nconst cast = require('./cast');\nconst castUpdate = require('./helpers/query/castUpdate');\nconst completeMany = require('./helpers/query/completeMany');\nconst get = require('lodash.get');\nconst hasDollarKeys = require('./helpers/query/hasDollarKeys');\nconst helpers = require('./queryhelpers');\nconst isInclusive = require('./helpers/projection/isInclusive');\nconst mquery = require('mquery');\nconst selectPopulatedFields = require('./helpers/query/selectPopulatedFields');\nconst setDefaultsOnInsert = require('./helpers/setDefaultsOnInsert');\nconst slice = require('sliced');\nconst updateValidators = require('./helpers/updateValidators');\nconst util = require('util');\nconst utils = require('./utils');\n\n/**\n * Query constructor used for building queries. You do not need\n * to instantiate a `Query` directly. Instead use Model functions like\n * [`Model.find()`](/docs/api.html#find_find).\n *\n * ####Example:\n *\n *     const query = MyModel.find(); // `query` is an instance of `Query`\n *     query.setOptions({ lean : true });\n *     query.collection(MyModel.collection);\n *     query.where('age').gte(21).exec(callback);\n *\n *     // You can instantiate a query directly. There is no need to do\n *     // this unless you're an advanced user with a very good reason to.\n *     const query = new mongoose.Query();\n *\n * @param {Object} [options]\n * @param {Object} [model]\n * @param {Object} [conditions]\n * @param {Object} [collection] Mongoose collection\n * @api public\n */\n\nfunction Query(conditions, options, model, collection) {\n  // this stuff is for dealing with custom queries created by #toConstructor\n  if (!this._mongooseOptions) {\n    this._mongooseOptions = {};\n  }\n  options = options || {};\n\n  this._transforms = [];\n\n  // this is the case where we have a CustomQuery, we need to check if we got\n  // options passed in, and if we did, merge them in\n  const keys = Object.keys(options);\n  for (let i = 0; i < keys.length; ++i) {\n    const k = keys[i];\n    this._mongooseOptions[k] = options[k];\n  }\n\n  if (collection) {\n    this.mongooseCollection = collection;\n  }\n\n  if (model) {\n    this.model = model;\n    this.schema = model.schema;\n  }\n\n  // this is needed because map reduce returns a model that can be queried, but\n  // all of the queries on said model should be lean\n  if (this.model && this.model._mapreduce) {\n    this.lean();\n  }\n\n  // inherit mquery\n  mquery.call(this, this.mongooseCollection, options);\n\n  if (conditions) {\n    this.find(conditions);\n  }\n\n  this.options = this.options || {};\n\n  // For gh-6880. mquery still needs to support `fields` by default for old\n  // versions of MongoDB\n  this.$useProjection = true;\n\n  const collation = get(this, 'schema.options.collation', null);\n  if (collation != null) {\n    this.options.collation = collation;\n  }\n}\n\n/*!\n * inherit mquery\n */\n\nQuery.prototype = new mquery;\nQuery.prototype.constructor = Query;\nQuery.base = mquery.prototype;\n\n/**\n * Flag to opt out of using `$geoWithin`.\n *\n *     mongoose.Query.use$geoWithin = false;\n *\n * MongoDB 2.4 deprecated the use of `$within`, replacing it with `$geoWithin`. Mongoose uses `$geoWithin` by default (which is 100% backward compatible with $within). If you are running an older version of MongoDB, set this flag to `false` so your `within()` queries continue to work.\n *\n * @see http://docs.mongodb.org/manual/reference/operator/geoWithin/\n * @default true\n * @property use$geoWithin\n * @memberOf Query\n * @receiver Query\n * @api public\n */\n\nQuery.use$geoWithin = mquery.use$geoWithin;\n\n/**\n * Converts this query to a customized, reusable query constructor with all arguments and options retained.\n *\n * ####Example\n *\n *     // Create a query for adventure movies and read from the primary\n *     // node in the replica-set unless it is down, in which case we'll\n *     // read from a secondary node.\n *     var query = Movie.find({ tags: 'adventure' }).read('primaryPreferred');\n *\n *     // create a custom Query constructor based off these settings\n *     var Adventure = query.toConstructor();\n *\n *     // Adventure is now a subclass of mongoose.Query and works the same way but with the\n *     // default query parameters and options set.\n *     Adventure().exec(callback)\n *\n *     // further narrow down our query results while still using the previous settings\n *     Adventure().where({ name: /^Life/ }).exec(callback);\n *\n *     // since Adventure is a stand-alone constructor we can also add our own\n *     // helper methods and getters without impacting global queries\n *     Adventure.prototype.startsWith = function (prefix) {\n *       this.where({ name: new RegExp('^' + prefix) })\n *       return this;\n *     }\n *     Object.defineProperty(Adventure.prototype, 'highlyRated', {\n *       get: function () {\n *         this.where({ rating: { $gt: 4.5 }});\n *         return this;\n *       }\n *     })\n *     Adventure().highlyRated.startsWith('Life').exec(callback)\n *\n * New in 3.7.3\n *\n * @return {Query} subclass-of-Query\n * @api public\n */\n\nQuery.prototype.toConstructor = function toConstructor() {\n  const model = this.model;\n  const coll = this.mongooseCollection;\n\n  const CustomQuery = function(criteria, options) {\n    if (!(this instanceof CustomQuery)) {\n      return new CustomQuery(criteria, options);\n    }\n    this._mongooseOptions = utils.clone(p._mongooseOptions);\n    Query.call(this, criteria, options || null, model, coll);\n  };\n\n  util.inherits(CustomQuery, model.Query);\n\n  // set inherited defaults\n  const p = CustomQuery.prototype;\n\n  p.options = {};\n\n  p.setOptions(this.options);\n\n  p.op = this.op;\n  p._conditions = utils.clone(this._conditions);\n  p._fields = utils.clone(this._fields);\n  p._update = utils.clone(this._update, {\n    flattenDecimals: false\n  });\n  p._path = this._path;\n  p._distinct = this._distinct;\n  p._collection = this._collection;\n  p._mongooseOptions = this._mongooseOptions;\n\n  return CustomQuery;\n};\n\n/**\n * Specifies a javascript function or expression to pass to MongoDBs query system.\n *\n * ####Example\n *\n *     query.$where('this.comments.length === 10 || this.name.length === 5')\n *\n *     // or\n *\n *     query.$where(function () {\n *       return this.comments.length === 10 || this.name.length === 5;\n *     })\n *\n * ####NOTE:\n *\n * Only use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`.\n * **Be sure to read about all of [its caveats](http://docs.mongodb.org/manual/reference/operator/where/) before using.**\n *\n * @see $where http://docs.mongodb.org/manual/reference/operator/where/\n * @method $where\n * @param {String|Function} js javascript string or function\n * @return {Query} this\n * @memberOf Query\n * @instance\n * @method $where\n * @api public\n */\n\n/**\n * Specifies a `path` for use with chaining.\n *\n * ####Example\n *\n *     // instead of writing:\n *     User.find({age: {$gte: 21, $lte: 65}}, callback);\n *\n *     // we can instead write:\n *     User.where('age').gte(21).lte(65);\n *\n *     // passing query conditions is permitted\n *     User.find().where({ name: 'vonderful' })\n *\n *     // chaining\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^vonderful/i)\n *     .where('friends').slice(10)\n *     .exec(callback)\n *\n * @method where\n * @memberOf Query\n * @instance\n * @param {String|Object} [path]\n * @param {any} [val]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.slice = function() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  this._validate('slice');\n\n  let path;\n  let val;\n\n  if (arguments.length === 1) {\n    const arg = arguments[0];\n    if (typeof arg === 'object' && !Array.isArray(arg)) {\n      const keys = Object.keys(arg);\n      const numKeys = keys.length;\n      for (let i = 0; i < numKeys; ++i) {\n        this.slice(keys[i], arg[keys[i]]);\n      }\n      return this;\n    }\n    this._ensurePath('slice');\n    path = this._path;\n    val = arguments[0];\n  } else if (arguments.length === 2) {\n    if ('number' === typeof arguments[0]) {\n      this._ensurePath('slice');\n      path = this._path;\n      val = slice(arguments);\n    } else {\n      path = arguments[0];\n      val = arguments[1];\n    }\n  } else if (arguments.length === 3) {\n    path = arguments[0];\n    val = slice(arguments, 1);\n  }\n\n  const p = {};\n  p[path] = { $slice: val };\n  this.select(p);\n\n  return this;\n};\n\n\n/**\n * Specifies the complementary comparison value for paths specified with `where()`\n *\n * ####Example\n *\n *     User.where('age').equals(49);\n *\n *     // is the same as\n *\n *     User.where('age', 49);\n *\n * @method equals\n * @memberOf Query\n * @instance\n * @param {Object} val\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for an `$or` condition.\n *\n * ####Example\n *\n *     query.or([{ color: 'red' }, { status: 'emergency' }])\n *\n * @see $or http://docs.mongodb.org/manual/reference/operator/or/\n * @method or\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$nor` condition.\n *\n * ####Example\n *\n *     query.nor([{ color: 'green' }, { status: 'ok' }])\n *\n * @see $nor http://docs.mongodb.org/manual/reference/operator/nor/\n * @method nor\n * @memberOf Query\n * @instance\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies arguments for a `$and` condition.\n *\n * ####Example\n *\n *     query.and([{ color: 'green' }, { status: 'ok' }])\n *\n * @method and\n * @memberOf Query\n * @instance\n * @see $and http://docs.mongodb.org/manual/reference/operator/and/\n * @param {Array} array array of conditions\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a $gt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * ####Example\n *\n *     Thing.find().where('age').gt(21)\n *\n *     // or\n *     Thing.find().gt('age', 21)\n *\n * @method gt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gt http://docs.mongodb.org/manual/reference/operator/gt/\n * @api public\n */\n\n/**\n * Specifies a $gte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method gte\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $gte http://docs.mongodb.org/manual/reference/operator/gte/\n * @api public\n */\n\n/**\n * Specifies a $lt query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lt\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @see $lt http://docs.mongodb.org/manual/reference/operator/lt/\n * @api public\n */\n\n/**\n * Specifies a $lte query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @method lte\n * @see $lte http://docs.mongodb.org/manual/reference/operator/lte/\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $ne query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $ne http://docs.mongodb.org/manual/reference/operator/ne/\n * @method ne\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $in query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $in http://docs.mongodb.org/manual/reference/operator/in/\n * @method in\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $nin query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $nin http://docs.mongodb.org/manual/reference/operator/nin/\n * @method nin\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies an $all query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $all http://docs.mongodb.org/manual/reference/operator/all/\n * @method all\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $size query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * ####Example\n *\n *     MyModel.where('tags').size(0).exec(function (err, docs) {\n *       if (err) return handleError(err);\n *\n *       assert(Array.isArray(docs));\n *       console.log('documents with 0 tags', docs);\n *     })\n *\n * @see $size http://docs.mongodb.org/manual/reference/operator/size/\n * @method size\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a $regex query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $regex http://docs.mongodb.org/manual/reference/operator/regex/\n * @method regex\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {String|RegExp} val\n * @api public\n */\n\n/**\n * Specifies a $maxDistance query condition.\n *\n * When called with one argument, the most recent path passed to `where()` is used.\n *\n * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/\n * @method maxDistance\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies a `$mod` condition, filters documents for documents whose\n * `path` property is a number that is equal to `remainder` modulo `divisor`.\n *\n * ####Example\n *\n *     // All find products whose inventory is odd\n *     Product.find().mod('inventory', [2, 1]);\n *     Product.find().where('inventory').mod([2, 1]);\n *     // This syntax is a little strange, but supported.\n *     Product.find().where('inventory').mod(2, 1);\n *\n * @method mod\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Array} val must be of length 2, first element is `divisor`, 2nd element is `remainder`.\n * @return {Query} this\n * @see $mod http://docs.mongodb.org/manual/reference/operator/mod/\n * @api public\n */\n\nQuery.prototype.mod = function() {\n  let val;\n  let path;\n\n  if (arguments.length === 1) {\n    this._ensurePath('mod');\n    val = arguments[0];\n    path = this._path;\n  } else if (arguments.length === 2 && !Array.isArray(arguments[1])) {\n    this._ensurePath('mod');\n    val = slice(arguments);\n    path = this._path;\n  } else if (arguments.length === 3) {\n    val = slice(arguments, 1);\n    path = arguments[0];\n  } else {\n    val = arguments[1];\n    path = arguments[0];\n  }\n\n  const conds = this._conditions[path] || (this._conditions[path] = {});\n  conds.$mod = val;\n  return this;\n};\n\n/**\n * Specifies an `$exists` condition\n *\n * ####Example\n *\n *     // { name: { $exists: true }}\n *     Thing.where('name').exists()\n *     Thing.where('name').exists(true)\n *     Thing.find().exists('name')\n *\n *     // { name: { $exists: false }}\n *     Thing.where('name').exists(false);\n *     Thing.find().exists('name', false);\n *\n * @method exists\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val\n * @return {Query} this\n * @see $exists http://docs.mongodb.org/manual/reference/operator/exists/\n * @api public\n */\n\n/**\n * Specifies an `$elemMatch` condition\n *\n * ####Example\n *\n *     query.elemMatch('comment', { author: 'autobot', votes: {$gte: 5}})\n *\n *     query.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\n *\n *     query.elemMatch('comment', function (elem) {\n *       elem.where('author').equals('autobot');\n *       elem.where('votes').gte(5);\n *     })\n *\n *     query.where('comment').elemMatch(function (elem) {\n *       elem.where({ author: 'autobot' });\n *       elem.where('votes').gte(5);\n *     })\n *\n * @method elemMatch\n * @memberOf Query\n * @instance\n * @param {String|Object|Function} path\n * @param {Object|Function} criteria\n * @return {Query} this\n * @see $elemMatch http://docs.mongodb.org/manual/reference/operator/elemMatch/\n * @api public\n */\n\n/**\n * Defines a `$within` or `$geoWithin` argument for geo-spatial queries.\n *\n * ####Example\n *\n *     query.where(path).within().box()\n *     query.where(path).within().circle()\n *     query.where(path).within().geometry()\n *\n *     query.where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\n *     query.where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\n *     query.where('loc').within({ polygon: [[],[],[],[]] });\n *\n *     query.where('loc').within([], [], []) // polygon\n *     query.where('loc').within([], []) // box\n *     query.where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\n *\n * **MUST** be used after `where()`.\n *\n * ####NOTE:\n *\n * As of Mongoose 3.7, `$geoWithin` is always used for queries. To change this behavior, see [Query.use$geoWithin](#query_Query-use%2524geoWithin).\n *\n * ####NOTE:\n *\n * In Mongoose 3.7, `within` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method within\n * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/\n * @see $box http://docs.mongodb.org/manual/reference/operator/box/\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @see $center http://docs.mongodb.org/manual/reference/operator/center/\n * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/\n * @memberOf Query\n * @instance\n * @return {Query} this\n * @api public\n */\n\n/**\n * Specifies a $slice projection for an array.\n *\n * ####Example\n *\n *     query.slice('comments', 5)\n *     query.slice('comments', -5)\n *     query.slice('comments', [10, 5])\n *     query.where('comments').slice(5)\n *     query.where('comments').slice([-10, 5])\n *\n * @method slice\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Number} val number/range of elements to slice\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields#RetrievingaSubsetofFields-RetrievingaSubrangeofArrayElements\n * @see $slice http://docs.mongodb.org/manual/reference/projection/slice/#prj._S_slice\n * @api public\n */\n\n/**\n * Specifies the maximum number of documents the query will return.\n *\n * ####Example\n *\n *     query.limit(20)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method limit\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @api public\n */\n\n/**\n * Specifies the number of documents to skip.\n *\n * ####Example\n *\n *     query.skip(100).limit(20)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method skip\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see cursor.skip http://docs.mongodb.org/manual/reference/method/cursor.skip/\n * @api public\n */\n\n/**\n * Specifies the maxScan option.\n *\n * ####Example\n *\n *     query.maxScan(100)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method maxScan\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see maxScan http://docs.mongodb.org/manual/reference/operator/maxScan/\n * @api public\n */\n\n/**\n * Specifies the batchSize option.\n *\n * ####Example\n *\n *     query.batchSize(100)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method batchSize\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see batchSize http://docs.mongodb.org/manual/reference/method/cursor.batchSize/\n * @api public\n */\n\n/**\n * Specifies the `comment` option.\n *\n * ####Example\n *\n *     query.comment('login query')\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method comment\n * @memberOf Query\n * @instance\n * @param {Number} val\n * @see comment http://docs.mongodb.org/manual/reference/operator/comment/\n * @api public\n */\n\n/**\n * Specifies this query as a `snapshot` query.\n *\n * ####Example\n *\n *     query.snapshot() // true\n *     query.snapshot(true)\n *     query.snapshot(false)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method snapshot\n * @memberOf Query\n * @instance\n * @see snapshot http://docs.mongodb.org/manual/reference/operator/snapshot/\n * @return {Query} this\n * @api public\n */\n\n/**\n * Sets query hints.\n *\n * ####Example\n *\n *     query.hint({ indexA: 1, indexB: -1})\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @method hint\n * @memberOf Query\n * @instance\n * @param {Object} val a hint object\n * @return {Query} this\n * @see $hint http://docs.mongodb.org/manual/reference/operator/hint/\n * @api public\n */\n\n/**\n * Specifies which document fields to include or exclude (also known as the query \"projection\")\n *\n * When using string syntax, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included. Lastly, if a path is prefixed with `+`, it forces inclusion of the path, which is useful for paths excluded at the [schema level](/docs/api.html#schematype_SchemaType-select).\n *\n * A projection _must_ be either inclusive or exclusive. In other words, you must\n * either list the fields to include (which excludes all others), or list the fields\n * to exclude (which implies all other fields are included). The [`_id` field is the only exception because MongoDB includes it by default](https://docs.mongodb.com/manual/tutorial/project-fields-from-query-results/#suppress-id-field).\n *\n * ####Example\n *\n *     // include a and b, exclude other fields\n *     query.select('a b');\n *\n *     // exclude c and d, include other fields\n *     query.select('-c -d');\n *\n *     // Use `+` to override schema-level `select: false` without making the\n *     // projection inclusive.\n *     const schema = new Schema({\n *       foo: { type: String, select: false },\n *       bar: String\n *     });\n *     // ...\n *     query.select('+foo'); // Override foo's `select: false` without excluding `bar`\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     query.select({ a: 1, b: 1 });\n *     query.select({ c: 0, d: 0 });\n *\n *\n * @method select\n * @memberOf Query\n * @instance\n * @param {Object|String} arg\n * @return {Query} this\n * @see SchemaType\n * @api public\n */\n\nQuery.prototype.select = function select() {\n  let arg = arguments[0];\n  if (!arg) return this;\n  let i;\n  let len;\n\n  if (arguments.length !== 1) {\n    throw new Error('Invalid select: select only takes 1 argument');\n  }\n\n  this._validate('select');\n\n  const fields = this._fields || (this._fields = {});\n  const userProvidedFields = this._userProvidedFields || (this._userProvidedFields = {});\n  const type = typeof arg;\n\n  if (('string' == type || Object.prototype.toString.call(arg) === '[object Arguments]') &&\n    'number' == typeof arg.length || Array.isArray(arg)) {\n    if ('string' == type)\n      arg = arg.split(/\\s+/);\n\n    for (i = 0, len = arg.length; i < len; ++i) {\n      let field = arg[i];\n      if (!field) continue;\n      const include = '-' == field[0] ? 0 : 1;\n      if (include === 0) field = field.substring(1);\n      fields[field] = include;\n      userProvidedFields[field] = include;\n    }\n    return this;\n  }\n\n  if (utils.isObject(arg)) {\n    const keys = Object.keys(arg);\n    for (i = 0; i < keys.length; ++i) {\n      fields[keys[i]] = arg[keys[i]];\n      userProvidedFields[keys[i]] = arg[keys[i]];\n    }\n    return this;\n  }\n\n  throw new TypeError('Invalid select() argument. Must be string or object.');\n};\n\n/**\n * _DEPRECATED_ Sets the slaveOk option.\n *\n * **Deprecated** in MongoDB 2.2 in favor of [read preferences](#query_Query-read).\n *\n * ####Example:\n *\n *     query.slaveOk() // true\n *     query.slaveOk(true)\n *     query.slaveOk(false)\n *\n * @method slaveOk\n * @memberOf Query\n * @instance\n * @deprecated use read() preferences instead if on mongodb >= 2.2\n * @param {Boolean} v defaults to true\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see slaveOk http://docs.mongodb.org/manual/reference/method/rs.slaveOk/\n * @see read() #query_Query-read\n * @return {Query} this\n * @api public\n */\n\n/**\n * Determines the MongoDB nodes from which to read.\n *\n * ####Preferences:\n *\n *     primary - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\n *     secondary            Read from secondary if available, otherwise error.\n *     primaryPreferred     Read from primary if available, otherwise a secondary.\n *     secondaryPreferred   Read from a secondary if available, otherwise read from the primary.\n *     nearest              All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\n *\n * Aliases\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * ####Example:\n *\n *     new Query().read('primary')\n *     new Query().read('p')  // same as primary\n *\n *     new Query().read('primaryPreferred')\n *     new Query().read('pp') // same as primaryPreferred\n *\n *     new Query().read('secondary')\n *     new Query().read('s')  // same as secondary\n *\n *     new Query().read('secondaryPreferred')\n *     new Query().read('sp') // same as secondaryPreferred\n *\n *     new Query().read('nearest')\n *     new Query().read('n')  // same as nearest\n *\n *     // read from secondaries with matching tags\n *     new Query().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\n *\n * Read more about how to use read preferrences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\n *\n * @method read\n * @memberOf Query\n * @instance\n * @param {String} pref one of the listed preference options or aliases\n * @param {Array} [tags] optional tags for this query\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.read = function read(pref, tags) {\n  // first cast into a ReadPreference object to support tags\n  const read = new ReadPreference(pref, tags);\n  this.options.readPreference = read;\n  return this;\n};\n\n/**\n * Sets the [MongoDB session](https://docs.mongodb.com/manual/reference/server-sessions/)\n * associated with this query. Sessions are how you mark a query as part of a\n * [transaction](/docs/transactions.html).\n *\n * Calling `session(null)` removes the session from this query.\n *\n * ####Example:\n *\n *     const s = await mongoose.startSession();\n *     await mongoose.model('Person').findOne({ name: 'Axl Rose' }).session(s);\n *\n * @method session\n * @memberOf Query\n * @instance\n * @param {ClientSession} [session] from `await conn.startSession()`\n * @see Connection.prototype.startSession() /docs/api.html#connection_Connection-startSession\n * @see mongoose.startSession() /docs/api.html#mongoose_Mongoose-startSession\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.session = function session(v) {\n  if (v == null) {\n    delete this.options.session;\n  }\n  this.options.session = v;\n  return this;\n};\n\n/**\n * Sets the specified number of `mongod` servers, or tag set of `mongod` servers,\n * that must acknowledge this write before this write is considered successful.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `remove()`\n * - `update()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.w` option](/docs/guide.html#writeConcern)\n *\n * ####Example:\n *\n *     // The 'majority' option means the `deleteOne()` promise won't resolve\n *     // until the `deleteOne()` has propagated to the majority of the replica set\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w('majority');\n *\n * @method w\n * @memberOf Query\n * @instance\n * @param {String|number} val 0 for fire-and-forget, 1 for acknowledged by one server, 'majority' for majority of the replica set, or [any of the more advanced options](https://docs.mongodb.com/manual/reference/write-concern/#w-option).\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#w-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.w = function w(val) {\n  if (val == null) {\n    delete this.options.w;\n  }\n  this.options.w = val;\n  return this;\n};\n\n/**\n * Requests acknowledgement that this operation has been persisted to MongoDB's\n * on-disk journal.\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `remove()`\n * - `update()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.j` option](/docs/guide.html#writeConcern)\n *\n * ####Example:\n *\n *     await mongoose.model('Person').deleteOne({ name: 'Ned Stark' }).j(true);\n *\n * @method j\n * @memberOf Query\n * @instance\n * @param {boolean} val\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#j-option\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.j = function j(val) {\n  if (val == null) {\n    delete this.options.j;\n  }\n  this.options.j = val;\n  return this;\n};\n\n/**\n * If [`w > 1`](/docs/api.html#query_Query-w), the maximum amount of time to\n * wait for this write to propagate through the replica set before this\n * operation fails. The default is `0`, which means no timeout.\n *\n * This option is only valid for operations that write to the database:\n *\n * - `deleteOne()`\n * - `deleteMany()`\n * - `findOneAndDelete()`\n * - `findOneAndUpdate()`\n * - `remove()`\n * - `update()`\n * - `updateOne()`\n * - `updateMany()`\n *\n * Defaults to the schema's [`writeConcern.wtimeout` option](/docs/guide.html#writeConcern)\n *\n * ####Example:\n *\n *     // The `deleteOne()` promise won't resolve until this `deleteOne()` has\n *     // propagated to at least `w = 2` members of the replica set. If it takes\n *     // longer than 1 second, this `deleteOne()` will fail.\n *     await mongoose.model('Person').\n *       deleteOne({ name: 'Ned Stark' }).\n *       w(2).\n *       wtimeout(1000);\n *\n * @method wtimeout\n * @memberOf Query\n * @instance\n * @param {number} ms number of milliseconds to wait\n * @see mongodb https://docs.mongodb.com/manual/reference/write-concern/#wtimeout\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.wtimeout = function wtimeout(ms) {\n  if (ms == null) {\n    delete this.options.wtimeout;\n  }\n  this.options.wtimeout = ms;\n  return this;\n};\n\n/**\n * Sets the readConcern option for the query.\n *\n * ####Example:\n *\n *     new Query().readConcern('local')\n *     new Query().readConcern('l')  // same as local\n *\n *     new Query().readConcern('available')\n *     new Query().readConcern('a')  // same as available\n *\n *     new Query().readConcern('majority')\n *     new Query().readConcern('m')  // same as majority\n *\n *     new Query().readConcern('linearizable')\n *     new Query().readConcern('lz') // same as linearizable\n *\n *     new Query().readConcern('snapshot')\n *     new Query().readConcern('s')  // same as snapshot\n *\n *\n * ####Read Concern Level:\n *\n *     local         MongoDB 3.2+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     available     MongoDB 3.6+ The query returns from the instance with no guarantee guarantee that the data has been written to a majority of the replica set members (i.e. may be rolled back).\n *     majority      MongoDB 3.2+ The query returns the data that has been acknowledged by a majority of the replica set members. The documents returned by the read operation are durable, even in the event of failure.\n *     linearizable  MongoDB 3.4+ The query returns data that reflects all successful majority-acknowledged writes that completed prior to the start of the read operation. The query may wait for concurrently executing writes to propagate to a majority of replica set members before returning results.\n *     snapshot      MongoDB 4.0+ Only available for operations within multi-document transactions. Upon transaction commit with write concern \"majority\", the transaction operations are guaranteed to have read from a snapshot of majority-committed data.\n *\n * Aliases\n *\n *     l   local\n *     a   available\n *     m   majority\n *     lz  linearizable\n *     s   snapshot\n *\n * Read more about how to use read concern [here](https://docs.mongodb.com/manual/reference/read-concern/).\n *\n * @memberOf Query\n * @method readConcern\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Query} this\n * @api public\n */\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * New in 3.7.0\n *\n * @method merge\n * @memberOf Query\n * @instance\n * @param {Query|Object} source\n * @return {Query} this\n */\n\n/**\n * Gets query options.\n *\n * ####Example:\n *\n *     var query = new Query();\n *     query.limit(10);\n *     query.setOptions({ maxTimeMS: 1000 })\n *     query.getOptions(); // { limit: 10, maxTimeMS: 1000 }\n *\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.getOptions = function() {\n  return this.options;\n};\n\n/**\n * Sets query options. Some options only make sense for certain operations.\n *\n * ####Options:\n *\n * The following options are only for `find()`:\n *\n * - [tailable](http://www.mongodb.org/display/DOCS/Tailable+Cursors)\n * - [sort](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsort(\\)%7D%7D)\n * - [limit](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Blimit%28%29%7D%7D)\n * - [skip](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bskip%28%29%7D%7D)\n * - [maxscan](https://docs.mongodb.org/v3.2/reference/operator/meta/maxScan/#metaOp._S_maxScan)\n * - [batchSize](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7BbatchSize%28%29%7D%7D)\n * - [comment](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24comment)\n * - [snapshot](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%7B%7Bsnapshot%28%29%7D%7D)\n * - [readPreference](http://docs.mongodb.org/manual/applications/replication/#read-preference)\n * - [hint](http://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24hint)\n *\n * The following options are only for write operations: `update()`, `updateOne()`, `updateMany()`, `replaceOne()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:\n *\n * - [upsert](https://docs.mongodb.com/manual/reference/method/db.collection.update/)\n * - [writeConcern](https://docs.mongodb.com/manual/reference/method/db.collection.update/)\n * - [timestamps](https://mongoosejs.com/docs/guide.html#timestamps): If `timestamps` is set in the schema, set this option to `false` to skip timestamps for that particular update. Has no effect if `timestamps` is not enabled in the schema options.\n *\n * The following options are only for `find()`, `findOne()`, `findById()`, `findOneAndUpdate()`, and `findByIdAndUpdate()`:\n *\n * - [lean](./api.html#query_Query-lean)\n *\n * The following options are only for all operations **except** `update()`, `updateOne()`, `updateMany()`, `remove()`, `deleteOne()`, and `deleteMany()`:\n *\n * - [maxTimeMS](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)\n *\n * The following options are for all operations:\n *\n * - [collation](https://docs.mongodb.com/manual/reference/collation/)\n * - [session](https://docs.mongodb.com/manual/reference/server-sessions/)\n *\n * @param {Object} options\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.setOptions = function(options, overwrite) {\n  // overwrite is only for internal use\n  if (overwrite) {\n    // ensure that _mongooseOptions & options are two different objects\n    this._mongooseOptions = (options && utils.clone(options)) || {};\n    this.options = options || {};\n\n    if ('populate' in options) {\n      this.populate(this._mongooseOptions);\n    }\n    return this;\n  }\n\n  if (options == null) {\n    return this;\n  }\n\n  if (Array.isArray(options.populate)) {\n    const populate = options.populate;\n    delete options.populate;\n    const _numPopulate = populate.length;\n    for (let i = 0; i < _numPopulate; ++i) {\n      this.populate(populate[i]);\n    }\n  }\n\n  if ('useFindAndModify' in options) {\n    this._mongooseOptions.useFindAndModify = options.useFindAndModify;\n    delete options.useFindAndModify;\n  }\n  if ('omitUndefined' in options) {\n    this._mongooseOptions.omitUndefined = options.omitUndefined;\n    delete options.omitUndefined;\n  }\n\n  return Query.base.setOptions.call(this, options);\n};\n\n/**\n * Sets the [`explain` option](https://docs.mongodb.com/manual/reference/method/cursor.explain/),\n * which makes this query return detailed execution stats instead of the actual\n * query result. This method is useful for determining what index your queries\n * use.\n *\n * Calling `query.explain(v)` is equivalent to `query.setOption({ explain: v })`\n *\n * ####Example:\n *\n *     const query = new Query();\n *     const res = await query.find({ a: 1 }).explain('queryPlanner');\n *     console.log(res);\n *\n * @param {String} [verbose] The verbosity mode. Either 'queryPlanner', 'executionStats', or 'allPlansExecution'. The default is 'queryPlanner'\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.explain = function(verbose) {\n  if (arguments.length === 0) {\n    this.options.explain = true;\n    return this;\n  }\n  this.options.explain = verbose;\n  return this;\n};\n\n/**\n * Returns the current query conditions as a JSON object.\n *\n * ####Example:\n *\n *     var query = new Query();\n *     query.find({ a: 1 }).where('b').gt(2);\n *     query.getQuery(); // { a: 1, b: { $gt: 2 } }\n *\n * @return {Object} current query conditions\n * @api public\n */\n\nQuery.prototype.getQuery = function() {\n  return this._conditions;\n};\n\n/**\n * Sets the query conditions to the provided JSON object.\n *\n * ####Example:\n *\n *     var query = new Query();\n *     query.find({ a: 1 })\n *     query.setQuery({ a: 2 });\n *     query.getQuery(); // { a: 2 }\n *\n * @param {Object} new query conditions\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setQuery = function(val) {\n  this._conditions = val;\n};\n\n/**\n * Returns the current update operations as a JSON object.\n *\n * ####Example:\n *\n *     var query = new Query();\n *     query.update({}, { $set: { a: 5 } });\n *     query.getUpdate(); // { $set: { a: 5 } }\n *\n * @return {Object} current update operations\n * @api public\n */\n\nQuery.prototype.getUpdate = function() {\n  return this._update;\n};\n\n/**\n * Sets the current update operation to new value.\n *\n * ####Example:\n *\n *     var query = new Query();\n *     query.update({}, { $set: { a: 5 } });\n *     query.setUpdate({ $set: { b: 6 } });\n *     query.getUpdate(); // { $set: { b: 6 } }\n *\n * @param {Object} new update operation\n * @return {undefined}\n * @api public\n */\n\nQuery.prototype.setUpdate = function(val) {\n  this._update = val;\n};\n\n/**\n * Returns fields selection for this query.\n *\n * @method _fieldsForExec\n * @return {Object}\n * @api private\n * @receiver Query\n */\n\nQuery.prototype._fieldsForExec = function() {\n  return utils.clone(this._fields);\n};\n\n\n/**\n * Return an update document with corrected $set operations.\n *\n * @method _updateForExec\n * @api private\n * @receiver Query\n */\n\nQuery.prototype._updateForExec = function() {\n  const update = utils.clone(this._update, {\n    transform: false,\n    depopulate: true\n  });\n  const ops = Object.keys(update);\n  let i = ops.length;\n  const ret = {};\n\n  while (i--) {\n    const op = ops[i];\n\n    if (this.options.overwrite) {\n      ret[op] = update[op];\n      continue;\n    }\n\n    if ('$' !== op[0]) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (update.$set) {\n          ret.$set = update.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = update[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if ('$set' === op) {\n      if (!ret.$set) {\n        ret[op] = update[op];\n      }\n    } else {\n      ret[op] = update[op];\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Makes sure _path is set.\n *\n * @method _ensurePath\n * @param {String} method\n * @api private\n * @receiver Query\n */\n\n/**\n * Determines if `conds` can be merged using `mquery().merge()`\n *\n * @method canMerge\n * @memberOf Query\n * @instance\n * @param {Object} conds\n * @return {Boolean}\n * @api private\n */\n\n/**\n * Returns default options for this query.\n *\n * @param {Model} model\n * @api private\n */\n\nQuery.prototype._optionsForExec = function(model) {\n  const options = utils.clone(this.options);\n\n  delete options.populate;\n  model = model || this.model;\n\n  if (!model) {\n    return options;\n  }\n\n  const safe = get(model, 'schema.options.safe', null);\n  if (!('safe' in options) && safe != null) {\n    setSafe(options, safe);\n  }\n\n  // Apply schema-level `writeConcern` option\n  applyWriteConcern(model.schema, options);\n\n  const readPreference = get(model, 'schema.options.read');\n  if (!('readPreference' in options) && readPreference) {\n    options.readPreference = readPreference;\n  }\n\n  if (options.upsert !== void 0) {\n    options.upsert = !!options.upsert;\n  }\n\n  return options;\n};\n\n/*!\n * ignore\n */\n\nconst safeDeprecationWarning = 'Mongoose: the `safe` option is deprecated. ' +\n  'Use write concerns instead: http://bit.ly/mongoose-w';\n\nconst setSafe = util.deprecate(function setSafe(options, safe) {\n  options.safe = safe;\n}, safeDeprecationWarning);\n\n/**\n * Sets the lean option.\n *\n * Documents returned from queries with the `lean` option enabled are plain javascript objects, not [MongooseDocuments](#document-js). They have no `save` method, getters/setters or other Mongoose magic applied.\n *\n * ####Example:\n *\n *     new Query().lean() // true\n *     new Query().lean(true)\n *     new Query().lean(false)\n *\n *     Model.find().lean().exec(function (err, docs) {\n *       docs[0] instanceof mongoose.Document // false\n *     });\n *\n * This is a [great](https://groups.google.com/forum/#!topic/mongoose-orm/u2_DzDydcnA/discussion) option in high-performance read-only scenarios, especially when combined with [stream](#query_Query-stream).\n *\n * @param {Boolean|Object} bool defaults to true\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.lean = function(v) {\n  this._mongooseOptions.lean = arguments.length ? v : true;\n  return this;\n};\n\n/**\n * Adds a `$set` to this query's update without changing the operation.\n * This is useful for query middleware so you can add an update regardless\n * of whether you use `updateOne()`, `updateMany()`, `findOneAndUpdate()`, etc.\n *\n * ####Example:\n *\n *     // Updates `{ $set: { updatedAt: new Date() } }`\n *     new Query().updateOne({}, {}).set('updatedAt', new Date());\n *     new Query().updateMany({}, {}).set({ updatedAt: new Date() });\n *\n * @param {String|Object} path path or object of key/value pairs to set\n * @param {Any} [val] the value to set\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.set = function(path, val) {\n  if (typeof path === 'object') {\n    const keys = Object.keys(path);\n    for (const key of keys) {\n      this.set(key, path[key]);\n    }\n    return this;\n  }\n\n  this._update = this._update || {};\n  this._update.$set = this._update.$set || {};\n  this._update.$set[path] = val;\n  return this;\n};\n\n/**\n * Gets/sets the error flag on this query. If this flag is not null or\n * undefined, the `exec()` promise will reject without executing.\n *\n * ####Example:\n *\n *     Query().error(); // Get current error value\n *     Query().error(null); // Unset the current error\n *     Query().error(new Error('test')); // `exec()` will resolve with test\n *     Schema.pre('find', function() {\n *       if (!this.getQuery().userId) {\n *         this.error(new Error('Not allowed to query without setting userId'));\n *       }\n *     });\n *\n * Note that query casting runs **after** hooks, so cast errors will override\n * custom errors.\n *\n * ####Example:\n *     var TestSchema = new Schema({ num: Number });\n *     var TestModel = db.model('Test', TestSchema);\n *     TestModel.find({ num: 'not a number' }).error(new Error('woops')).exec(function(error) {\n *       // `error` will be a cast error because `num` failed to cast\n *     });\n *\n * @param {Error|null} err if set, `exec()` will fail fast before sending the query to MongoDB\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.error = function error(err) {\n  if (arguments.length === 0) {\n    return this._error;\n  }\n\n  this._error = err;\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQuery.prototype._unsetCastError = function _unsetCastError() {\n  if (this._error != null && !(this._error instanceof CastError)) {\n    return;\n  }\n  return this.error(null);\n};\n\n/**\n * Getter/setter around the current mongoose-specific options for this query\n * Below are the current Mongoose-specific options.\n *\n * - `populate`: an array representing what paths will be populated. Should have one entry for each call to [`Query.prototype.populate()`](/docs/api.html#query_Query-populate)\n * - `lean`: if truthy, Mongoose will not [hydrate](/docs/api.html#model_Model.hydrate) any documents that are returned from this query. See [`Query.prototype.lean()`](/docs/api.html#query_Query-lean) for more information.\n * - `strict`: controls how Mongoose handles keys that aren't in the schema for updates. This option is `true` by default, which means Mongoose will silently strip any paths in the update that aren't in the schema. See the [`strict` mode docs](/docs/guide.html#strict) for more information.\n * - `strictQuery`: controls how Mongoose handles keys that aren't in the schema for the query `filter`. This option is `false` by default for backwards compatibility, which means Mongoose will allow `Model.find({ foo: 'bar' })` even if `foo` is not in the schema. See the [`strictQuery` docs](/docs/guide.html#strictQuery) for more information.\n * - `useFindAndModify`: used to work around the [`findAndModify()` deprecation warning](/docs/deprecations.html#-findandmodify-)\n * - `omitUndefined`: delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.\n * - `nearSphere`: use `$nearSphere` instead of `near()`. See the [`Query.prototype.nearSphere()` docs](/docs/api.html#query_Query-nearSphere)\n *\n * Mongoose maintains a separate object for internal options because\n * Mongoose sends `Query.prototype.options` to the MongoDB server, and the\n * above options are not relevant for the MongoDB server.\n *\n * @param {Object} options if specified, overwrites the current options\n * @return {Object} the options\n * @api public\n */\n\nQuery.prototype.mongooseOptions = function(v) {\n  if (arguments.length > 0) {\n    this._mongooseOptions = v;\n  }\n  return this._mongooseOptions;\n};\n\n/*!\n * ignore\n */\n\nQuery.prototype._castConditions = function() {\n  try {\n    this.cast(this.model);\n    this._unsetCastError();\n  } catch (err) {\n    this.error(err);\n  }\n};\n\n/**\n * Thunk around find()\n *\n * @param {Function} [callback]\n * @return {Query} this\n * @api private\n */\nQuery.prototype._find = function(callback) {\n  this._castConditions();\n\n  if (this.error() != null) {\n    callback(this.error());\n    return null;\n  }\n\n  this._applyPaths();\n  this._fields = this._castFields(this._fields);\n\n  const fields = this._fieldsForExec();\n  const mongooseOptions = this._mongooseOptions;\n  const _this = this;\n  const userProvidedFields = _this._userProvidedFields || {};\n\n  // Separate options to pass down to `completeMany()` in case we need to\n  // set a session on the document\n  const completeManyOptions = Object.assign({}, {\n    session: get(this, 'options.session', null)\n  });\n\n  const cb = (err, docs) => {\n    if (err) {\n      return callback(err);\n    }\n\n    if (docs.length === 0) {\n      return callback(null, docs);\n    }\n    if (this.options.explain) {\n      return callback(null, docs);\n    }\n\n    if (!mongooseOptions.populate) {\n      return mongooseOptions.lean ?\n        callback(null, docs) :\n        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);\n    }\n\n    const pop = helpers.preparePopulationOptionsMQ(_this, mongooseOptions);\n    completeManyOptions.populated = pop;\n    _this.model.populate(docs, pop, function(err, docs) {\n      if (err) return callback(err);\n      return mongooseOptions.lean ?\n        callback(null, docs) :\n        completeMany(_this.model, docs, fields, userProvidedFields, completeManyOptions, callback);\n    });\n  };\n\n  const options = this._optionsForExec();\n  options.projection = this._fieldsForExec();\n  const filter = this._conditions;\n  this._collection.find(filter, options, cb);\n  return null;\n};\n\n/**\n * Find all documents that match `selector`. The result will be an array of documents.\n *\n * If there are too many documents in the result to fit in memory, use\n * [`Query.prototype.cursor()`](api.html#query_Query-cursor)\n *\n * ####Example\n *\n *     // Using async/await\n *     const arr = await Movie.find({ year: { $gte: 1980, $lte: 1989 } });\n *\n *     // Using callbacks\n *     Movie.find({ year: { $gte: 1980, $lte: 1989 } }, function(err, arr) {});\n *\n * @param {Object} [filter] mongodb selector. If not specified, returns all documents.\n * @param {Function} [callback]\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.find = function(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  conditions = utils.toObject(conditions);\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'find'));\n  }\n\n  // if we don't have a callback, then just return the query object\n  if (!callback) {\n    return Query.base.find.call(this);\n  }\n\n  this._find(callback);\n\n  return this;\n};\n\n/**\n * Merges another Query or conditions object into this one.\n *\n * When a Query is passed, conditions, field selection and options are merged.\n *\n * @param {Query|Object} source\n * @return {Query} this\n */\n\nQuery.prototype.merge = function(source) {\n  if (!source) {\n    return this;\n  }\n\n  const opts = { overwrite: true };\n\n  if (source instanceof Query) {\n    // if source has a feature, apply it to ourselves\n\n    if (source._conditions) {\n      utils.merge(this._conditions, source._conditions, opts);\n    }\n\n    if (source._fields) {\n      this._fields || (this._fields = {});\n      utils.merge(this._fields, source._fields, opts);\n    }\n\n    if (source.options) {\n      this.options || (this.options = {});\n      utils.merge(this.options, source.options, opts);\n    }\n\n    if (source._update) {\n      this._update || (this._update = {});\n      utils.mergeClone(this._update, source._update);\n    }\n\n    if (source._distinct) {\n      this._distinct = source._distinct;\n    }\n\n    return this;\n  }\n\n  // plain object\n  utils.merge(this._conditions, source, opts);\n\n  return this;\n};\n\n/**\n * Adds a collation to this op (MongoDB 3.4 and up)\n *\n * @param {Object} value\n * @return {Query} this\n * @see MongoDB docs https://docs.mongodb.com/manual/reference/method/cursor.collation/#cursor.collation\n * @api public\n */\n\nQuery.prototype.collation = function(value) {\n  if (this.options == null) {\n    this.options = {};\n  }\n  this.options.collation = value;\n  return this;\n};\n\n/**\n * Hydrate a single doc from `findOne()`, `findOneAndUpdate()`, etc.\n *\n * @api private\n */\n\nQuery.prototype._completeOne = function(doc, res, callback) {\n  if (!doc) {\n    return callback(null, null);\n  }\n\n  const model = this.model;\n  const projection = utils.clone(this._fields);\n  const userProvidedFields = this._userProvidedFields || {};\n  // `populate`, `lean`\n  const mongooseOptions = this._mongooseOptions;\n  // `rawResult`\n  const options = this.options;\n\n  if (options.explain) {\n    return callback(null, doc);\n  }\n\n  if (!mongooseOptions.populate) {\n    return mongooseOptions.lean ?\n      _completeOneLean(doc, res, options, callback) :\n      completeOne(model, doc, res, options, projection, userProvidedFields,\n        null, callback);\n  }\n\n  const pop = helpers.preparePopulationOptionsMQ(this, this._mongooseOptions);\n  model.populate(doc, pop, (err, doc) => {\n    if (err) {\n      return callback(err);\n    }\n    return mongooseOptions.lean ?\n      _completeOneLean(doc, res, options, callback) :\n      completeOne(model, doc, res, options, projection, userProvidedFields,\n        pop, callback);\n  });\n};\n\n/**\n * Thunk around findOne()\n *\n * @param {Function} [callback]\n * @see findOne http://docs.mongodb.org/manual/reference/method/db.collection.findOne/\n * @api private\n */\n\nQuery.prototype._findOne = function(callback) {\n  this._castConditions();\n\n  if (this.error()) {\n    callback(this.error());\n    return null;\n  }\n\n  this._applyPaths();\n  this._fields = this._castFields(this._fields);\n\n  // don't pass in the conditions because we already merged them in\n  Query.base.findOne.call(this, {}, (err, doc) => {\n    if (err) {\n      callback(err);\n      return null;\n    }\n\n    this._completeOne(doc, null, callback);\n  });\n};\n\n/**\n * Declares the query a findOne operation. When executed, the first found document is passed to the callback.\n *\n * Passing a `callback` executes the query. The result of the query is a single document.\n *\n * * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `Model.findById()`\n * instead.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * ####Example\n *\n *     var query  = Kitten.where({ color: 'white' });\n *     query.findOne(function (err, kitten) {\n *       if (err) return handleError(err);\n *       if (kitten) {\n *         // doc may be null if no document matched\n *       }\n *     });\n *\n * @param {Object} [filter] mongodb selector\n * @param {Object} [projection] optional fields to return\n * @param {Object} [options] see [`setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback] optional params are (error, document)\n * @return {Query} this\n * @see findOne http://docs.mongodb.org/manual/reference/method/db.collection.findOne/\n * @see Query.select #query_Query-select\n * @api public\n */\n\nQuery.prototype.findOne = function(conditions, projection, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = null;\n    projection = null;\n    options = null;\n  } else if (typeof projection === 'function') {\n    callback = projection;\n    options = null;\n    projection = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  // make sure we don't send in the whole Document to merge()\n  conditions = utils.toObject(conditions);\n\n  this.op = 'findOne';\n\n  if (options) {\n    this.setOptions(options);\n  }\n\n  if (projection) {\n    this.select(projection);\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'findOne'));\n  }\n\n  if (!callback) {\n    // already merged in the conditions, don't need to send them in.\n    return Query.base.findOne.call(this);\n  }\n\n  this._findOne(callback);\n\n  return this;\n};\n\n/**\n * Thunk around count()\n *\n * @param {Function} [callback]\n * @see count http://docs.mongodb.org/manual/reference/method/db.collection.count/\n * @api private\n */\n\nQuery.prototype._count = function(callback) {\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    this.error(err);\n  }\n\n  if (this.error()) {\n    return callback(this.error());\n  }\n\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  this._collection.count(conds, options, utils.tick(callback));\n};\n\n/**\n * Thunk around countDocuments()\n *\n * @param {Function} [callback]\n * @see countDocuments http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments\n * @api private\n */\n\nQuery.prototype._countDocuments = function(callback) {\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    this.error(err);\n  }\n\n  if (this.error()) {\n    return callback(this.error());\n  }\n\n  const conds = this._conditions;\n  const options = this._optionsForExec();\n\n  this._collection.collection.countDocuments(conds, options, utils.tick(callback));\n};\n\n/**\n * Thunk around estimatedDocumentCount()\n *\n * @param {Function} [callback]\n * @see estimatedDocumentCount http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#estimatedDocumentCount\n * @api private\n */\n\nQuery.prototype._estimatedDocumentCount = function(callback) {\n  if (this.error()) {\n    return callback(this.error());\n  }\n\n  const options = this._optionsForExec();\n\n  this._collection.collection.estimatedDocumentCount(options, utils.tick(callback));\n};\n\n/**\n * Specifies this query as a `count` query.\n *\n * This method is deprecated. If you want to count the number of documents in\n * a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](/docs/api.html#query_Query-estimatedDocumentCount)\n * instead. Otherwise, use the [`countDocuments()`](/docs/api.html#query_Query-countDocuments) function instead.\n *\n * Passing a `callback` executes the query.\n *\n * This function triggers the following middleware.\n *\n * - `count()`\n *\n * ####Example:\n *\n *     var countQuery = model.where({ 'color': 'black' }).count();\n *\n *     query.count({ color: 'black' }).count(callback)\n *\n *     query.count({ color: 'black' }, callback)\n *\n *     query.where('color', 'black').count(function (err, count) {\n *       if (err) return handleError(err);\n *       console.log('there are %d kittens', count);\n *     })\n *\n * @deprecated\n * @param {Object} [filter] count documents that match this object\n * @param {Function} [callback] optional params are (error, count)\n * @return {Query} this\n * @see count http://docs.mongodb.org/manual/reference/method/db.collection.count/\n * @api public\n */\n\nQuery.prototype.count = function(filter, callback) {\n  if (typeof filter === 'function') {\n    callback = filter;\n    filter = undefined;\n  }\n\n  filter = utils.toObject(filter);\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n  }\n\n  this.op = 'count';\n  if (!callback) {\n    return this;\n  }\n\n  this._count(callback);\n\n  return this;\n};\n\n/**\n * Specifies this query as a `estimatedDocumentCount()` query. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * `estimatedDocumentCount()` does **not** accept a filter. `Model.find({ foo: bar }).estimatedDocumentCount()`\n * is equivalent to `Model.find().estimatedDocumentCount()`\n *\n * This function triggers the following middleware.\n *\n * - `estimatedDocumentCount()`\n *\n * ####Example:\n *\n *     await Model.find().estimatedDocumentCount();\n *\n * @param {Object} [options] passed transparently to the [MongoDB driver](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#estimatedDocumentCount)\n * @param {Function} [callback] optional params are (error, count)\n * @return {Query} this\n * @see estimatedDocumentCount http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#estimatedDocumentCount\n * @api public\n */\n\nQuery.prototype.estimatedDocumentCount = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  if (typeof options === 'object' && options != null) {\n    this.setOptions(options);\n  }\n\n  this.op = 'estimatedDocumentCount';\n  if (!callback) {\n    return this;\n  }\n\n  this._estimatedDocumentCount(callback);\n\n  return this;\n};\n\n/**\n * Specifies this query as a `countDocuments()` query. Behaves like `count()`,\n * except it always does a full collection scan when passed an empty filter `{}`.\n *\n * There are also minor differences in how `countDocuments()` handles\n * [`$where` and a couple geospatial operators](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments).\n * versus `count()`.\n *\n * Passing a `callback` executes the query.\n *\n * This function triggers the following middleware.\n *\n * - `countDocuments()`\n *\n * ####Example:\n *\n *     const countQuery = model.where({ 'color': 'black' }).countDocuments();\n *\n *     query.countDocuments({ color: 'black' }).count(callback);\n *\n *     query.countDocuments({ color: 'black' }, callback);\n *\n *     query.where('color', 'black').countDocuments(function(err, count) {\n *       if (err) return handleError(err);\n *       console.log('there are %d kittens', count);\n *     });\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://docs.mongodb.com/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://docs.mongodb.com/manual/reference/operator/query/geoWithin/) with [`$center`](https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://docs.mongodb.com/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} [filter] mongodb selector\n * @param {Function} [callback] optional params are (error, count)\n * @return {Query} this\n * @see countDocuments http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments\n * @api public\n */\n\nQuery.prototype.countDocuments = function(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = undefined;\n  }\n\n  conditions = utils.toObject(conditions);\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  this.op = 'countDocuments';\n  if (!callback) {\n    return this;\n  }\n\n  this._countDocuments(callback);\n\n  return this;\n};\n\n/**\n * Declares or executes a distict() operation.\n *\n * Passing a `callback` executes the query.\n *\n * This function does not trigger any middleware.\n *\n * ####Example\n *\n *     distinct(field, conditions, callback)\n *     distinct(field, conditions)\n *     distinct(field, callback)\n *     distinct(field)\n *     distinct(callback)\n *     distinct()\n *\n * @param {String} [field]\n * @param {Object|Query} [filter]\n * @param {Function} [callback] optional params are (error, arr)\n * @return {Query} this\n * @see distinct http://docs.mongodb.org/manual/reference/method/db.collection.distinct/\n * @api public\n */\n\nQuery.prototype.distinct = function(field, conditions, callback) {\n  if (!callback) {\n    if (typeof conditions === 'function') {\n      callback = conditions;\n      conditions = undefined;\n    } else if (typeof field === 'function') {\n      callback = field;\n      field = undefined;\n      conditions = undefined;\n    }\n  }\n\n  conditions = utils.toObject(conditions);\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (conditions != null) {\n    this.error(new ObjectParameterError(conditions, 'filter', 'distinct'));\n  }\n\n  if (callback != null) {\n    this._castConditions();\n\n    if (this.error() != null) {\n      callback(this.error());\n      return this;\n    }\n  }\n\n  return Query.base.distinct.call(this, {}, field, callback);\n};\n\n/**\n * Sets the sort order\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The\n * sort order of each path is ascending unless the path name is prefixed with `-`\n * which will be treated as descending.\n *\n * ####Example\n *\n *     // sort by \"field\" ascending and \"test\" descending\n *     query.sort({ field: 'asc', test: -1 });\n *\n *     // equivalent\n *     query.sort('field -test');\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @param {Object|String} arg\n * @return {Query} this\n * @see cursor.sort http://docs.mongodb.org/manual/reference/method/cursor.sort/\n * @api public\n */\n\nQuery.prototype.sort = function(arg) {\n  if (arguments.length > 1) {\n    throw new Error('sort() only takes 1 Argument');\n  }\n\n  return Query.base.sort.call(this, arg);\n};\n\n/**\n * Declare and/or execute this query as a remove() operation.\n *\n * This function does not trigger any middleware\n *\n * ####Example\n *\n *     Model.remove({ artist: 'Anne Murray' }, callback)\n *\n * ####Note\n *\n * The operation is only executed when a callback is passed. To force execution without a callback, you must first call `remove()` and then execute it by using the `exec()` method.\n *\n *     // not executed\n *     var query = Model.find().remove({ name: 'Anne Murray' })\n *\n *     // executed\n *     query.remove({ name: 'Anne Murray' }, callback)\n *     query.remove({ name: 'Anne Murray' }).remove(callback)\n *\n *     // executed without a callback\n *     query.exec()\n *\n *     // summary\n *     query.remove(conds, fn); // executes\n *     query.remove(conds)\n *     query.remove(fn) // executes\n *     query.remove()\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/\n * @api public\n */\n\nQuery.prototype.remove = function(filter, callback) {\n  if (typeof filter === 'function') {\n    callback = filter;\n    filter = null;\n  }\n\n  filter = utils.toObject(filter);\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'remove'));\n  }\n\n  if (!callback) {\n    return Query.base.remove.call(this);\n  }\n\n  this._remove(callback);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQuery.prototype._remove = function(callback) {\n  this._castConditions();\n\n  if (this.error() != null) {\n    callback(this.error());\n    return this;\n  }\n\n  return Query.base.remove.call(this, helpers.handleWriteOpResult(callback));\n};\n\n/**\n * Declare and/or execute this query as a `deleteOne()` operation. Works like\n * remove, except it deletes at most one document regardless of the `single`\n * option.\n *\n * This function does not trigger any middleware.\n *\n * ####Example\n *\n *     Character.deleteOne({ name: 'Eddard Stark' }, callback)\n *     Character.deleteOne({ name: 'Eddard Stark' }).then(next)\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/\n * @api public\n */\n\nQuery.prototype.deleteOne = function(filter, callback) {\n  if (typeof filter === 'function') {\n    callback = filter;\n    filter = null;\n  }\n\n  filter = utils.toObject(filter);\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteOne'));\n  }\n\n  if (!callback) {\n    return Query.base.deleteOne.call(this);\n  }\n\n  this._deleteOne.call(this, callback);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQuery.prototype._deleteOne = function(callback) {\n  this._castConditions();\n\n  if (this.error() != null) {\n    callback(this.error());\n    return this;\n  }\n\n  return Query.base.deleteOne.call(this, helpers.handleWriteOpResult(callback));\n};\n\n/**\n * Declare and/or execute this query as a `deleteMany()` operation. Works like\n * remove, except it deletes _every_ document that matches `criteria` in the\n * collection, regardless of the value of `single`.\n *\n * This function does not trigger any middleware\n *\n * ####Example\n *\n *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, callback)\n *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }).then(next)\n *\n * @param {Object|Query} [filter] mongodb selector\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @see remove http://docs.mongodb.org/manual/reference/method/db.collection.remove/\n * @api public\n */\n\nQuery.prototype.deleteMany = function(filter, callback) {\n  if (typeof filter === 'function') {\n    callback = filter;\n    filter = null;\n  }\n\n  filter = utils.toObject(filter);\n\n  if (mquery.canMerge(filter)) {\n    this.merge(filter);\n\n    prepareDiscriminatorCriteria(this);\n  } else if (filter != null) {\n    this.error(new ObjectParameterError(filter, 'filter', 'deleteMany'));\n  }\n\n  if (!callback) {\n    return Query.base.deleteMany.call(this);\n  }\n\n  this._deleteMany.call(this, callback);\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQuery.prototype._deleteMany = function(callback) {\n  this._castConditions();\n\n  if (this.error() != null) {\n    callback(this.error());\n    return this;\n  }\n\n  return Query.base.deleteMany.call(this, helpers.handleWriteOpResult(callback));\n};\n\n/*!\n * hydrates a document\n *\n * @param {Model} model\n * @param {Document} doc\n * @param {Object} res 3rd parameter to callback\n * @param {Object} fields\n * @param {Query} self\n * @param {Array} [pop] array of paths used in population\n * @param {Function} callback\n */\n\nfunction completeOne(model, doc, res, options, fields, userProvidedFields, pop, callback) {\n  const opts = pop ?\n    {populated: pop}\n    : undefined;\n\n  const casted = helpers.createModel(model, doc, fields, userProvidedFields);\n  try {\n    casted.init(doc, opts, _init);\n  } catch (error) {\n    _init(error);\n  }\n\n  function _init(err) {\n    if (err) {\n      return process.nextTick(() => callback(err));\n    }\n\n    casted.$session(options.session);\n\n    if (options.rawResult) {\n      res.value = casted;\n      return process.nextTick(() => callback(null, res));\n    }\n    process.nextTick(() => callback(null, casted));\n  }\n}\n\n/*!\n * If the model is a discriminator type and not root, then add the key & value to the criteria.\n */\n\nfunction prepareDiscriminatorCriteria(query) {\n  if (!query || !query.model || !query.model.schema) {\n    return;\n  }\n\n  const schema = query.model.schema;\n\n  if (schema && schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    query._conditions[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * ####Available options\n *\n * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n * - `rawResult`: if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `context` (string) if set to 'query' and `runValidators` is on, `this` will refer to the query in custom validator functions that update validation runs. Does nothing if `runValidators` is false.\n *\n * ####Callback Signature\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * ####Examples\n *\n *     query.findOneAndUpdate(conditions, update, options, callback) // executes\n *     query.findOneAndUpdate(conditions, update, options)  // returns Query\n *     query.findOneAndUpdate(conditions, update, callback) // executes\n *     query.findOneAndUpdate(conditions, update)           // returns Query\n *     query.findOneAndUpdate(update, callback)             // returns Query\n *     query.findOneAndUpdate(update)                       // returns Query\n *     query.findOneAndUpdate(callback)                     // executes\n *     query.findOneAndUpdate()                             // returns Query\n *\n * @method findOneAndUpdate\n * @memberOf Query\n * @instance\n * @param {Object|Query} [query]\n * @param {Object} [doc]\n * @param {Object} [options]\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](http://mongoosejs.com/docs/api.html#query_Query-lean).\n * @param {Function} [callback] optional params are (error, doc), _unless_ `rawResult` is used, in which case params are (error, writeOpResult)\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.findOneAndUpdate = function(criteria, doc, options, callback) {\n  this.op = 'findOneAndUpdate';\n  this._validate();\n\n  switch (arguments.length) {\n    case 3:\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      break;\n    case 2:\n      if (typeof doc === 'function') {\n        callback = doc;\n        doc = criteria;\n        criteria = undefined;\n      }\n      options = undefined;\n      break;\n    case 1:\n      if (typeof criteria === 'function') {\n        callback = criteria;\n        criteria = options = doc = undefined;\n      } else {\n        doc = criteria;\n        criteria = options = undefined;\n      }\n  }\n\n  if (mquery.canMerge(criteria)) {\n    this.merge(criteria);\n  }\n\n  // apply doc\n  if (doc) {\n    this._mergeUpdate(doc);\n  }\n\n  if (options) {\n    options = utils.clone(options);\n    if (options.projection) {\n      this.select(options.projection);\n      delete options.projection;\n    }\n    if (options.fields) {\n      this.select(options.fields);\n      delete options.fields;\n    }\n\n    this.setOptions(options);\n  }\n\n  if (!callback) {\n    return this;\n  }\n\n  this._findOneAndUpdate(callback);\n\n  return this;\n};\n\n/*!\n * Thunk around findOneAndUpdate()\n *\n * @param {Function} [callback]\n * @api private\n */\n\nQuery.prototype._findOneAndUpdate = function(callback) {\n  if (this.error() != null) {\n    return callback(this.error());\n  }\n\n  this._findAndModify('update', callback);\n};\n\n/**\n * Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback` is passed.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * ####Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n *\n * ####Callback Signature\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * ####Examples\n *\n *     A.where().findOneAndRemove(conditions, options, callback) // executes\n *     A.where().findOneAndRemove(conditions, options)  // return Query\n *     A.where().findOneAndRemove(conditions, callback) // executes\n *     A.where().findOneAndRemove(conditions) // returns Query\n *     A.where().findOneAndRemove(callback)   // executes\n *     A.where().findOneAndRemove()           // returns Query\n *\n * @method findOneAndRemove\n * @memberOf Query\n * @instance\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Function} [callback] optional params are (error, document)\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nQuery.prototype.findOneAndRemove = function(conditions, options, callback) {\n  this.op = 'findOneAndRemove';\n  this._validate();\n\n  switch (arguments.length) {\n    case 2:\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      break;\n    case 1:\n      if (typeof conditions === 'function') {\n        callback = conditions;\n        conditions = undefined;\n        options = undefined;\n      }\n      break;\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  options && this.setOptions(options);\n\n  if (!callback) {\n    return this;\n  }\n\n  this._findOneAndRemove(callback);\n\n  return this;\n};\n\n/**\n * Issues a MongoDB [findOneAndDelete](https://docs.mongodb.com/manual/reference/method/db.collection.findOneAndDelete/) command.\n *\n * Finds a matching document, removes it, and passes the found document (if any) to the callback. Executes immediately if `callback` is passed.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * This function differs slightly from `Model.findOneAndRemove()` in that\n * `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/),\n * as opposed to a `findOneAndDelete()` command. For most mongoose use cases,\n * this distinction is purely pedantic. You should use `findOneAndDelete()`\n * unless you have a good reason not to.\n *\n * ####Available options\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `rawResult`: if true, resolves to the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n *\n * ####Callback Signature\n *     function(error, doc) {\n *       // error: any errors that occurred\n *       // doc: the document before updates are applied if `new: false`, or after updates if `new = true`\n *     }\n *\n * ####Examples\n *\n *     A.where().findOneAndDelete(conditions, options, callback) // executes\n *     A.where().findOneAndDelete(conditions, options)  // return Query\n *     A.where().findOneAndDelete(conditions, callback) // executes\n *     A.where().findOneAndDelete(conditions) // returns Query\n *     A.where().findOneAndDelete(callback)   // executes\n *     A.where().findOneAndDelete()           // returns Query\n *\n * @method findOneAndDelete\n * @memberOf Query\n * @param {Object} [conditions]\n * @param {Object} [options]\n * @param {Boolean} [options.rawResult] if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)\n * @param {Function} [callback] optional params are (error, document)\n * @return {Query} this\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nQuery.prototype.findOneAndDelete = function(conditions, options, callback) {\n  this.op = 'findOneAndDelete';\n  this._validate();\n\n  switch (arguments.length) {\n    case 2:\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      break;\n    case 1:\n      if (typeof conditions === 'function') {\n        callback = conditions;\n        conditions = undefined;\n        options = undefined;\n      }\n      break;\n  }\n\n  if (mquery.canMerge(conditions)) {\n    this.merge(conditions);\n  }\n\n  options && this.setOptions(options);\n\n  if (!callback) {\n    return this;\n  }\n\n  this._findOneAndDelete(callback);\n\n  return this;\n};\n\n/*!\n * Thunk around findOneAndDelete()\n *\n * @param {Function} [callback]\n * @return {Query} this\n * @api private\n */\nQuery.prototype._findOneAndDelete = function(callback) {\n  this._castConditions();\n\n  if (this.error() != null) {\n    callback(this.error());\n    return null;\n  }\n\n  const filter = this._conditions;\n  const options = this._optionsForExec();\n  let fields = null;\n\n  if (this._fields != null) {\n    options.projection = this._castFields(utils.clone(this._fields));\n    fields = options.projection;\n    if (fields instanceof Error) {\n      callback(fields);\n      return null;\n    }\n  }\n\n  this._collection.collection.findOneAndDelete(filter, options, (err, res) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const doc = res.value;\n\n    return this._completeOne(doc, res, callback);\n  });\n};\n\n/*!\n * Thunk around findOneAndRemove()\n *\n * @param {Function} [callback]\n * @return {Query} this\n * @api private\n */\nQuery.prototype._findOneAndRemove = function(callback) {\n  if (this.error() != null) {\n    callback(this.error());\n    return;\n  }\n\n  this._findAndModify('remove', callback);\n};\n\n/*!\n * Get options from query opts, falling back to the base mongoose object.\n */\n\nfunction _getOption(query, option, def) {\n  const opts = query._optionsForExec(query.model);\n\n  if (option in opts) {\n    return opts[option];\n  }\n  if (option in query.model.base.options) {\n    return query.model.base.options[option];\n  }\n  return def;\n}\n\n/*!\n * Override mquery.prototype._findAndModify to provide casting etc.\n *\n * @param {String} type - either \"remove\" or \"update\"\n * @param {Function} callback\n * @api private\n */\n\nQuery.prototype._findAndModify = function(type, callback) {\n  if (typeof callback !== 'function') {\n    throw new Error('Expected callback in _findAndModify');\n  }\n\n  const model = this.model;\n  const schema = model.schema;\n  const _this = this;\n  let castedDoc = this._update;\n  let fields;\n  let doValidate;\n\n  const castedQuery = castQuery(this);\n  if (castedQuery instanceof Error) {\n    return callback(castedQuery);\n  }\n\n  const opts = this._optionsForExec(model);\n\n  if ('strict' in opts) {\n    this._mongooseOptions.strict = opts.strict;\n  }\n\n  const isOverwriting = this.options.overwrite && !hasDollarKeys(castedDoc);\n  if (isOverwriting) {\n    castedDoc = new this.model(castedDoc, null, true);\n  }\n\n  if (type === 'remove') {\n    opts.remove = true;\n  } else {\n    if (!('new' in opts)) {\n      opts.new = false;\n    }\n    if (!('upsert' in opts)) {\n      opts.upsert = false;\n    }\n    if (opts.upsert || opts['new']) {\n      opts.remove = false;\n    }\n\n    if (isOverwriting) {\n      doValidate = function(callback) {\n        castedDoc.validate(callback);\n      };\n    } else {\n      castedDoc = castDoc(this, opts.overwrite);\n      castedDoc = setDefaultsOnInsert(this._conditions, schema, castedDoc, opts);\n      if (!castedDoc) {\n        if (opts.upsert) {\n          // still need to do the upsert to empty doc\n          const doc = utils.clone(castedQuery);\n          delete doc._id;\n          castedDoc = {$set: doc};\n        } else {\n          this.findOne(callback);\n          return this;\n        }\n      } else if (castedDoc instanceof Error) {\n        return callback(castedDoc);\n      } else {\n        // In order to make MongoDB 2.6 happy (see\n        // https://jira.mongodb.org/browse/SERVER-12266 and related issues)\n        // if we have an actual update document but $set is empty, junk the $set.\n        if (castedDoc.$set && Object.keys(castedDoc.$set).length === 0) {\n          delete castedDoc.$set;\n        }\n      }\n\n      doValidate = updateValidators(this, schema, castedDoc, opts);\n    }\n  }\n\n  this._applyPaths();\n\n  const options = this._mongooseOptions;\n\n  if (this._fields) {\n    fields = utils.clone(this._fields);\n    opts.projection = this._castFields(fields);\n    if (opts.projection instanceof Error) {\n      return callback(opts.projection);\n    }\n  }\n\n  if (opts.sort) convertSortToArray(opts);\n\n  const cb = function(err, doc, res) {\n    if (err) {\n      return callback(err);\n    }\n\n    _this._completeOne(doc, res, callback);\n  };\n\n  let _callback;\n\n  let useFindAndModify = true;\n  const runValidators = _getOption(this, 'runValidators', false);\n  const base = _this.model && _this.model.base;\n  const conn = get(model, 'collection.conn', {});\n  if ('useFindAndModify' in base.options) {\n    useFindAndModify = base.get('useFindAndModify');\n  }\n  if ('useFindAndModify' in conn.config) {\n    useFindAndModify = conn.config.useFindAndModify;\n  }\n  if ('useFindAndModify' in options) {\n    useFindAndModify = options.useFindAndModify;\n  }\n  if (useFindAndModify === false) {\n    // Bypass mquery\n    const collection = _this._collection.collection;\n    if ('new' in opts) {\n      opts.returnOriginal = !opts['new'];\n      delete opts['new'];\n    }\n\n    if (type === 'remove') {\n      collection.findOneAndDelete(castedQuery, opts, utils.tick(function(error, res) {\n        return cb(error, res ? res.value : res, res);\n      }));\n\n      return this;\n    }\n\n    // honors legacy overwrite option for backward compatibility\n    const updateMethod = isOverwriting ? 'findOneAndReplace' : 'findOneAndUpdate';\n\n    if (runValidators && doValidate) {\n      _callback = function(error) {\n        if (error) {\n          return callback(error);\n        }\n        if (castedDoc && castedDoc.toBSON) {\n          castedDoc = castedDoc.toBSON();\n        }\n\n        collection[updateMethod](castedQuery, castedDoc, opts, utils.tick(function(error, res) {\n          return cb(error, res ? res.value : res, res);\n        }));\n      };\n\n      try {\n        doValidate(_callback);\n      } catch (error) {\n        callback(error);\n      }\n    } else {\n      if (castedDoc && castedDoc.toBSON) {\n        castedDoc = castedDoc.toBSON();\n      }\n      collection[updateMethod](castedQuery, castedDoc, opts, utils.tick(function(error, res) {\n        return cb(error, res ? res.value : res, res);\n      }));\n    }\n\n    return this;\n  }\n\n  if (runValidators && doValidate) {\n    _callback = function(error) {\n      if (error) {\n        return callback(error);\n      }\n      if (castedDoc && castedDoc.toBSON) {\n        castedDoc = castedDoc.toBSON();\n      }\n      _this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {\n        return cb(error, res ? res.value : res, res);\n      }));\n    };\n\n    try {\n      doValidate(_callback);\n    } catch (error) {\n      callback(error);\n    }\n  } else {\n    if (castedDoc && castedDoc.toBSON) {\n      castedDoc = castedDoc.toBSON();\n    }\n    this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {\n      return cb(error, res ? res.value : res, res);\n    }));\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _completeOneLean(doc, res, opts, callback) {\n  if (opts.rawResult) {\n    return callback(null, res);\n  }\n  return callback(null, doc);\n}\n\n/*!\n * Override mquery.prototype._mergeUpdate to handle mongoose objects in\n * updates.\n *\n * @param {Object} doc\n * @api private\n */\n\nQuery.prototype._mergeUpdate = function(doc) {\n  if (!this._update) this._update = {};\n  if (doc instanceof Query) {\n    if (doc._update) {\n      utils.mergeClone(this._update, doc._update);\n    }\n  } else {\n    utils.mergeClone(this._update, doc);\n  }\n};\n\n/*!\n * The mongodb driver 1.3.23 only supports the nested array sort\n * syntax. We must convert it or sorting findAndModify will not work.\n */\n\nfunction convertSortToArray(opts) {\n  if (Array.isArray(opts.sort)) {\n    return;\n  }\n  if (!utils.isObject(opts.sort)) {\n    return;\n  }\n\n  const sort = [];\n\n  for (const key in opts.sort) {\n    if (utils.object.hasOwnProperty(opts.sort, key)) {\n      sort.push([key, opts.sort[key]]);\n    }\n  }\n\n  opts.sort = sort;\n}\n\n/*!\n * ignore\n */\n\nfunction _updateThunk(op, callback) {\n  const schema = this.model.schema;\n  let doValidate;\n  const _this = this;\n\n  this._castConditions();\n\n  if (this.error() != null) {\n    callback(this.error());\n    return null;\n  }\n\n  const castedQuery = this._conditions;\n  let castedDoc;\n  const options = this._optionsForExec(this.model);\n\n  this._update = utils.clone(this._update, options);\n  const isOverwriting = this.options.overwrite && !hasDollarKeys(this._update);\n  if (isOverwriting) {\n    castedDoc = new this.model(this._update, null, true);\n  } else {\n    castedDoc = castDoc(this, options.overwrite);\n\n    if (castedDoc instanceof Error) {\n      callback(castedDoc);\n      return null;\n    }\n\n    if (castedDoc == null || Object.keys(castedDoc).length === 0) {\n      callback(null, 0);\n      return null;\n    }\n\n    castedDoc = setDefaultsOnInsert(this._conditions, this.model.schema,\n      castedDoc, options);\n  }\n\n  const runValidators = _getOption(this, 'runValidators', false);\n  if (runValidators) {\n    if (isOverwriting) {\n      doValidate = function(callback) {\n        castedDoc.validate(callback);\n      };\n    } else {\n      doValidate = updateValidators(this, schema, castedDoc, options);\n    }\n    const _callback = function(err) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (castedDoc.toBSON) {\n        castedDoc = castedDoc.toBSON();\n      }\n      _this._collection[op](castedQuery, castedDoc, options, callback);\n    };\n    try {\n      doValidate(_callback);\n    } catch (err) {\n      process.nextTick(function() {\n        callback(err);\n      });\n    }\n    return null;\n  }\n\n  if (castedDoc.toBSON) {\n    castedDoc = castedDoc.toBSON();\n  }\n\n  this._collection[op](castedQuery, castedDoc, options, callback);\n  return null;\n}\n\n/*!\n * Internal thunk for .update()\n *\n * @param {Function} callback\n * @see Model.update #model_Model.update\n * @api private\n */\nQuery.prototype._execUpdate = function(callback) {\n  return _updateThunk.call(this, 'update', callback);\n};\n\n/*!\n * Internal thunk for .updateMany()\n *\n * @param {Function} callback\n * @see Model.update #model_Model.update\n * @api private\n */\nQuery.prototype._updateMany = function(callback) {\n  return _updateThunk.call(this, 'updateMany', callback);\n};\n\n/*!\n * Internal thunk for .updateOne()\n *\n * @param {Function} callback\n * @see Model.update #model_Model.update\n * @api private\n */\nQuery.prototype._updateOne = function(callback) {\n  return _updateThunk.call(this, 'updateOne', callback);\n};\n\n/*!\n * Internal thunk for .replaceOne()\n *\n * @param {Function} callback\n * @see Model.replaceOne #model_Model.replaceOne\n * @api private\n */\nQuery.prototype._replaceOne = function(callback) {\n  return _updateThunk.call(this, 'replaceOne', callback);\n};\n\n/**\n * Declare and/or execute this query as an update() operation.\n *\n * _All paths passed that are not $atomic operations will become $set ops._\n *\n * This function triggers the following middleware.\n *\n * - `update()`\n *\n * ####Example\n *\n *     Model.where({ _id: id }).update({ title: 'words' })\n *\n *     // becomes\n *\n *     Model.where({ _id: id }).update({ $set: { title: 'words' }})\n *\n * ####Valid options:\n *\n *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)\n *  - `multi` (boolean) whether multiple documents should be updated (false)\n *  - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n *  - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n *  - `strict` (boolean) overrides the `strict` option for this update\n *  - `overwrite` (boolean) disables update-only mode, allowing you to overwrite the doc (false)\n *  - `context` (string) if set to 'query' and `runValidators` is on, `this` will refer to the query in custom validator functions that update validation runs. Does nothing if `runValidators` is false.\n *  - `read`\n *  - `writeConcern`\n *\n * ####Note\n *\n * Passing an empty object `{}` as the doc will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option set, the update operation will be ignored and the callback executed without sending the command to MongoDB so as to prevent accidently overwritting documents in the collection.\n *\n * ####Note\n *\n * The operation is only executed when a callback is passed. To force execution without a callback, we must first call update() and then execute it by using the `exec()` method.\n *\n *     var q = Model.where({ _id: id });\n *     q.update({ $set: { name: 'bob' }}).update(); // not executed\n *\n *     q.update({ $set: { name: 'bob' }}).exec(); // executed\n *\n *     // keys that are not $atomic ops become $set.\n *     // this executes the same command as the previous example.\n *     q.update({ name: 'bob' }).exec();\n *\n *     // overwriting with empty docs\n *     var q = Model.where({ _id: id }).setOptions({ overwrite: true })\n *     q.update({ }, callback); // executes\n *\n *     // multi update with overwrite to empty doc\n *     var q = Model.where({ _id: id });\n *     q.setOptions({ multi: true, overwrite: true })\n *     q.update({ });\n *     q.update(callback); // executed\n *\n *     // multi updates\n *     Model.where()\n *          .update({ name: /^match/ }, { $set: { arr: [] }}, { multi: true }, callback)\n *\n *     // more multi updates\n *     Model.where()\n *          .setOptions({ multi: true })\n *          .update({ $set: { arr: [] }}, callback)\n *\n *     // single update by default\n *     Model.where({ email: 'address@example.com' })\n *          .update({ $inc: { counter: 1 }}, callback)\n *\n * API summary\n *\n *     update(criteria, doc, options, cb) // executes\n *     update(criteria, doc, options)\n *     update(criteria, doc, cb) // executes\n *     update(criteria, doc)\n *     update(doc, cb) // executes\n *     update(doc)\n *     update(cb) // executes\n *     update(true) // executes\n *     update()\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Function} [callback] optional, params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update #model_Model.update\n * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @api public\n */\n\nQuery.prototype.update = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'update', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as an updateMany() operation. Same as\n * `update()`, except MongoDB will update _all_ documents that match\n * `criteria` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update #model_Model.update\n * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @api public\n */\n\nQuery.prototype.updateMany = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateMany', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as an updateOne() operation. Same as\n * `update()`, except it does not support the `multi` or `overwrite` options.\n *\n * - MongoDB will update _only_ the first document that matches `criteria` regardless of the value of the `multi` option.\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * **Note** updateOne will _not_ fire update middleware. Use `pre('updateOne')`\n * and `post('updateOne')` instead.\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n @param {Boolean} [options.multipleCastError] by default, mongoose only returns the first error that occurred in casting the query. Turn on this option to aggregate all the cast errors.\n * @param {Function} [callback] params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update #model_Model.update\n * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @api public\n */\n\nQuery.prototype.updateOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  return _update(this, 'updateOne', conditions, doc, options, callback);\n};\n\n/**\n * Declare and/or execute this query as a replaceOne() operation. Same as\n * `update()`, except MongoDB will replace the existing document and will\n * not accept any atomic operators (`$set`, etc.)\n *\n * **Note** replaceOne will _not_ fire update middleware. Use `pre('replaceOne')`\n * and `post('replaceOne')` instead.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} [criteria]\n * @param {Object} [doc] the update command\n * @param {Object} [options]\n * @param {Function} [callback] optional params are (error, writeOpResult)\n * @return {Query} this\n * @see Model.update #model_Model.update\n * @see update http://docs.mongodb.org/manual/reference/method/db.collection.update/\n * @see writeOpResult http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~WriteOpResult\n * @api public\n */\n\nQuery.prototype.replaceOne = function(conditions, doc, options, callback) {\n  if (typeof options === 'function') {\n    // .update(conditions, doc, callback)\n    callback = options;\n    options = null;\n  } else if (typeof doc === 'function') {\n    // .update(doc, callback);\n    callback = doc;\n    doc = conditions;\n    conditions = {};\n    options = null;\n  } else if (typeof conditions === 'function') {\n    // .update(callback)\n    callback = conditions;\n    conditions = undefined;\n    doc = undefined;\n    options = undefined;\n  } else if (typeof conditions === 'object' && !doc && !options && !callback) {\n    // .update(doc)\n    doc = conditions;\n    conditions = undefined;\n    options = undefined;\n    callback = undefined;\n  }\n\n  this.setOptions({ overwrite: true });\n  return _update(this, 'replaceOne', conditions, doc, options, callback);\n};\n\n/*!\n * Internal helper for update, updateMany, updateOne, replaceOne\n */\n\nfunction _update(query, op, filter, doc, options, callback) {\n  // make sure we don't send in the whole Document to merge()\n  query.op = op;\n  filter = utils.toObject(filter);\n  doc = doc || {};\n\n  const oldCb = callback;\n  if (oldCb) {\n    if (typeof oldCb === 'function') {\n      callback = function(error, result) {\n        oldCb(error, result ? result.result : {ok: 0, n: 0, nModified: 0});\n      };\n    } else {\n      throw new Error('Invalid callback() argument.');\n    }\n  }\n\n  // strict is an option used in the update checking, make sure it gets set\n  if (options) {\n    if ('strict' in options) {\n      query._mongooseOptions.strict = options.strict;\n    }\n  }\n\n  if (!(filter instanceof Query) &&\n      filter != null &&\n      filter.toString() !== '[object Object]') {\n    query.error(new ObjectParameterError(filter, 'filter', op));\n  } else {\n    query.merge(filter);\n  }\n\n  if (utils.isObject(options)) {\n    query.setOptions(options);\n  }\n\n  query._mergeUpdate(doc);\n\n  // Hooks\n  if (callback) {\n    if (op === 'update') {\n      query._execUpdate(callback);\n      return query;\n    }\n    query['_' + op](callback);\n    return query;\n  }\n\n  return Query.base[op].call(query, filter, doc, options, callback);\n}\n\n/**\n *\n */\n\nQuery.prototype.map = function(fn) {\n  this._transforms.push(fn);\n};\n\n/**\n * Make this query throw an error if no documents match the given `filter`.\n * This is handy for integrating with async/await, because `orFail()` saves you\n * an extra `if` statement to check if no document was found.\n *\n * ####Example:\n *\n *     // Throws if no doc returned\n *     await Model.findOne({ foo: 'bar' }).orFail();\n *\n *     // Throws if no document was updated\n *     await Model.updateOne({ foo: 'bar' }, { name: 'test' }).orFail();\n *\n *     // Throws \"No docs found!\" error if no docs match `{ foo: 'bar' }`\n *     await Model.find({ foo: 'bar' }).orFail(new Error('No docs found!'));\n *\n *     // Throws \"Not found\" error if no document was found\n *     await Model.findOneAndUpdate({ foo: 'bar' }, { name: 'test' }).\n *       orFail(() => Error('Not found'));\n *\n * @method orFail\n * @memberOf Query\n * @instance\n * @param {Function|Error} [err] optional error to throw if no docs match `filter`\n * @return {Query} this\n */\n\nQuery.prototype.orFail = function(err) {\n  this.map(res => {\n    switch (this.op) {\n      case 'find':\n        if (res.length === 0) {\n          err = typeof err === 'function' ? err.call(this) : err;\n          throw err;\n        }\n        break;\n      case 'findOne':\n        if (res == null) {\n          err = typeof err === 'function' ? err.call(this) : err;\n          throw err;\n        }\n        break;\n      case 'update':\n      case 'updateMany':\n      case 'updateOne':\n        if (res.nModified === 0) {\n          err = typeof err === 'function' ? err.call(this) : err;\n          throw err;\n        }\n        break;\n      case 'deleteMany':\n      case 'deleteOne':\n      case 'remove':\n        if (res.n === 0) {\n          err = typeof err === 'function' ? err.call(this) : err;\n          throw err;\n        }\n        break;\n      default:\n        break;\n    }\n\n    return res;\n  });\n  return this;\n};\n\n/**\n * Executes the query\n *\n * ####Examples:\n *\n *     var promise = query.exec();\n *     var promise = query.exec('update');\n *\n *     query.exec(callback);\n *     query.exec('find', callback);\n *\n * @param {String|Function} [operation]\n * @param {Function} [callback] optional params depend on the function being called\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.exec = function exec(op, callback) {\n  const _this = this;\n\n  if (typeof op === 'function') {\n    callback = op;\n    op = null;\n  } else if (typeof op === 'string') {\n    this.op = op;\n  }\n\n  if (callback != null) {\n    callback = this.model.$wrapCallback(callback);\n  }\n\n  return utils.promiseOrCallback(callback, (cb) => {\n    if (!_this.op) {\n      cb();\n      return;\n    }\n\n    this[this.op].call(this, (error, res) => {\n      if (error) {\n        cb(error);\n        return;\n      }\n      for (const fn of this._transforms) {\n        try {\n          res = fn(res);\n        } catch (error) {\n          return cb(error);\n        }\n      }\n      cb(null, res);\n    });\n  });\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n *\n * @param {Function} [resolve]\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Executes the query returning a `Promise` which will be\n * resolved with either the doc(s) or rejected with the error.\n * Like `.then()`, but only takes a rejection handler.\n *\n * @param {Function} [reject]\n * @return {Promise}\n * @api public\n */\n\nQuery.prototype.catch = function(reject) {\n  return this.exec().then(null, reject);\n};\n\n/*!\n * Casts obj for an update command.\n *\n * @param {Object} obj\n * @return {Object} obj after casting its values\n * @api private\n */\n\nQuery.prototype._castUpdate = function _castUpdate(obj, overwrite) {\n  let strict;\n  if ('strict' in this._mongooseOptions) {\n    strict = this._mongooseOptions.strict;\n  } else if (this.schema && this.schema.options) {\n    strict = this.schema.options.strict;\n  } else {\n    strict = true;\n  }\n\n  let omitUndefined = false;\n  if ('omitUndefined' in this._mongooseOptions) {\n    omitUndefined = this._mongooseOptions.omitUndefined;\n  }\n\n  let useNestedStrict;\n  if ('useNestedStrict' in this.options) {\n    useNestedStrict = this.options.useNestedStrict;\n  }\n\n  return castUpdate(this.schema, obj, {\n    overwrite: overwrite,\n    strict: strict,\n    omitUndefined,\n    useNestedStrict: useNestedStrict\n  }, this, this._conditions);\n};\n\n/*!\n * castQuery\n * @api private\n */\n\nfunction castQuery(query) {\n  try {\n    return query.cast(query.model);\n  } catch (err) {\n    return err;\n  }\n}\n\n/*!\n * castDoc\n * @api private\n */\n\nfunction castDoc(query, overwrite) {\n  try {\n    return query._castUpdate(query._update, overwrite);\n  } catch (err) {\n    return err;\n  }\n}\n\n/**\n * Specifies paths which should be populated with other documents.\n *\n * ####Example:\n *\n *     Kitten.findOne().populate('owner').exec(function (err, kitten) {\n *       console.log(kitten.owner.name) // Max\n *     })\n *\n *     Kitten.find().populate({\n *         path: 'owner'\n *       , select: 'name'\n *       , match: { color: 'black' }\n *       , options: { sort: { name: -1 }}\n *     }).exec(function (err, kittens) {\n *       console.log(kittens[0].owner.name) // Zoopa\n *     })\n *\n *     // alternatively\n *     Kitten.find().populate('owner', 'name', null, {sort: { name: -1 }}).exec(function (err, kittens) {\n *       console.log(kittens[0].owner.name) // Zoopa\n *     })\n *\n * Paths are populated after the query executes and a response is received. A separate query is then executed for each path specified for population. After a response for each query has also been returned, the results are passed to the callback.\n *\n * @param {Object|String} path either the path to populate or an object specifying all parameters\n * @param {Object|String} [select] Field selection for the population query\n * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.\n * @param {Object} [match] Conditions for the population query\n * @param {Object} [options] Options for the population query (sort, etc)\n * @see population ./populate.html\n * @see Query#select #query_Query-select\n * @see Model.populate #model_Model.populate\n * @return {Query} this\n * @api public\n */\n\nQuery.prototype.populate = function() {\n  if (arguments.length === 0) {\n    return this;\n  }\n\n  const res = utils.populate.apply(null, arguments);\n\n  // Propagate readConcern and readPreference and lean from parent query,\n  // unless one already specified\n  if (this.options != null) {\n    const readConcern = this.options.readConcern;\n    const readPref = this.options.readPreference;\n\n    for (let i = 0; i < res.length; ++i) {\n      if (readConcern != null && get(res[i], 'options.readConcern') == null) {\n        res[i].options = res[i].options || {};\n        res[i].options.readConcern = readConcern;\n      }\n      if (readPref != null && get(res[i], 'options.readPreference') == null) {\n        res[i].options = res[i].options || {};\n        res[i].options.readPreference = readPref;\n      }\n    }\n  }\n\n  const opts = this._mongooseOptions;\n\n  if (opts.lean != null) {\n    const lean = opts.lean;\n    for (let i = 0; i < res.length; ++i) {\n      if (get(res[i], 'options.lean') == null) {\n        res[i].options = res[i].options || {};\n        res[i].options.lean = lean;\n      }\n    }\n  }\n\n  if (!utils.isObject(opts.populate)) {\n    opts.populate = {};\n  }\n\n  const pop = opts.populate;\n\n  for (let i = 0; i < res.length; ++i) {\n    const path = res[i].path;\n    if (pop[path] && pop[path].populate && res[i].populate) {\n      res[i].populate = pop[path].populate.concat(res[i].populate);\n    }\n    pop[res[i].path] = res[i];\n  }\n\n  return this;\n};\n\n/**\n * Gets a list of paths to be populated by this query\n *\n * ####Example:\n *      bookSchema.pre('findOne', function() {\n *        let keys = this.getPopulatedPaths(); // ['author']\n *      })\n *      ...\n *      Book.findOne({}).populate('author')\n *\n * @return {Array} an array of strings representing populated paths\n * @api public\n */\n\nQuery.prototype.getPopulatedPaths = function getPopulatedPaths() {\n  const obj = this._mongooseOptions.populate || {};\n  return Object.keys(obj);\n};\n\n/**\n * Casts this query to the schema of `model`\n *\n * ####Note\n *\n * If `obj` is present, it is cast instead of this query.\n *\n * @param {Model} [model] the model to cast to. If not set, defaults to `this.model`\n * @param {Object} [obj]\n * @return {Object}\n * @api public\n */\n\nQuery.prototype.cast = function(model, obj) {\n  obj || (obj = this._conditions);\n\n  model = model || this.model;\n\n  try {\n    return cast(model.schema, obj, {\n      upsert: this.options && this.options.upsert,\n      strict: (this.options && 'strict' in this.options) ?\n        this.options.strict :\n        get(model, 'schema.options.strict', null),\n      strictQuery: (this.options && this.options.strictQuery) ||\n        get(model, 'schema.options.strictQuery', null)\n    }, this);\n  } catch (err) {\n    // CastError, assign model\n    if (typeof err.setModel === 'function') {\n      err.setModel(model);\n    }\n    throw err;\n  }\n};\n\n/**\n * Casts selected field arguments for field selection with mongo 2.2\n *\n *     query.select({ ids: { $elemMatch: { $in: [hexString] }})\n *\n * @param {Object} fields\n * @see https://github.com/Automattic/mongoose/issues/1091\n * @see http://docs.mongodb.org/manual/reference/projection/elemMatch/\n * @api private\n */\n\nQuery.prototype._castFields = function _castFields(fields) {\n  let selected,\n      elemMatchKeys,\n      keys,\n      key,\n      out,\n      i;\n\n  if (fields) {\n    keys = Object.keys(fields);\n    elemMatchKeys = [];\n    i = keys.length;\n\n    // collect $elemMatch args\n    while (i--) {\n      key = keys[i];\n      if (fields[key].$elemMatch) {\n        selected || (selected = {});\n        selected[key] = fields[key];\n        elemMatchKeys.push(key);\n      }\n    }\n  }\n\n  if (selected) {\n    // they passed $elemMatch, cast em\n    try {\n      out = this.cast(this.model, selected);\n    } catch (err) {\n      return err;\n    }\n\n    // apply the casted field args\n    i = elemMatchKeys.length;\n    while (i--) {\n      key = elemMatchKeys[i];\n      fields[key] = out[key];\n    }\n  }\n\n  return fields;\n};\n\n/**\n * Applies schematype selected options to this query.\n * @api private\n */\n\nQuery.prototype._applyPaths = function applyPaths() {\n  this._fields = this._fields || {};\n  helpers.applyPaths(this._fields, this.model.schema);\n\n  let _selectPopulatedPaths = true;\n\n  if ('selectPopulatedPaths' in this.model.base.options) {\n    _selectPopulatedPaths = this.model.base.options.selectPopulatedPaths;\n  }\n  if ('selectPopulatedPaths' in this.model.schema.options) {\n    _selectPopulatedPaths = this.model.schema.options.selectPopulatedPaths;\n  }\n\n  if (_selectPopulatedPaths) {\n    selectPopulatedFields(this);\n  }\n};\n\n/**\n * Returns a wrapper around a [mongodb driver cursor](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html).\n * A QueryCursor exposes a Streams3 interface, as well as a `.next()` function.\n *\n * The `.cursor()` function triggers pre find hooks, but **not** post find hooks.\n *\n * ####Example\n *\n *     // There are 2 ways to use a cursor. First, as a stream:\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       on('data', function(doc) { console.log(doc); }).\n *       on('end', function() { console.log('Done!'); });\n *\n *     // Or you can use `.next()` to manually get the next doc in the stream.\n *     // `.next()` returns a promise, so you can use promises or callbacks.\n *     var cursor = Thing.find({ name: /^hello/ }).cursor();\n *     cursor.next(function(error, doc) {\n *       console.log(doc);\n *     });\n *\n *     // Because `.next()` returns a promise, you can use co\n *     // to easily iterate through all documents without loading them\n *     // all into memory.\n *     co(function*() {\n *       const cursor = Thing.find({ name: /^hello/ }).cursor();\n *       for (let doc = yield cursor.next(); doc != null; doc = yield cursor.next()) {\n *         console.log(doc);\n *       }\n *     });\n *\n * ####Valid options\n *\n *   - `transform`: optional function which accepts a mongoose document. The return value of the function will be emitted on `data` and returned by `.next()`.\n *\n * @return {QueryCursor}\n * @param {Object} [options]\n * @see QueryCursor\n * @api public\n */\n\nQuery.prototype.cursor = function cursor(opts) {\n  this._applyPaths();\n  this._fields = this._castFields(this._fields);\n  this.setOptions({ projection: this._fieldsForExec() });\n  if (opts) {\n    this.setOptions(opts);\n  }\n\n  try {\n    this.cast(this.model);\n  } catch (err) {\n    return (new QueryCursor(this, this.options))._markError(err);\n  }\n\n  return new QueryCursor(this, this.options);\n};\n\n// the rest of these are basically to support older Mongoose syntax with mquery\n\n/**\n * _DEPRECATED_ Alias of `maxScan`\n *\n * @deprecated\n * @see maxScan #query_Query-maxScan\n * @method maxscan\n * @memberOf Query\n * @instance\n */\n\nQuery.prototype.maxscan = Query.base.maxScan;\n\n/**\n * Sets the tailable option (for use with capped collections).\n *\n * ####Example\n *\n *     query.tailable() // true\n *     query.tailable(true)\n *     query.tailable(false)\n *\n * ####Note\n *\n * Cannot be used with `distinct()`\n *\n * @param {Boolean} bool defaults to true\n * @param {Object} [opts] options to set\n * @param {Number} [opts.numberOfRetries] if cursor is exhausted, retry this many times before giving up\n * @param {Number} [opts.tailableRetryInterval] if cursor is exhausted, wait this many milliseconds before retrying\n * @see tailable http://docs.mongodb.org/manual/tutorial/create-tailable-cursor/\n * @api public\n */\n\nQuery.prototype.tailable = function(val, opts) {\n  // we need to support the tailable({ awaitdata : true }) as well as the\n  // tailable(true, {awaitdata :true}) syntax that mquery does not support\n  if (val && val.constructor.name === 'Object') {\n    opts = val;\n    val = true;\n  }\n\n  if (val === undefined) {\n    val = true;\n  }\n\n  if (opts && typeof opts === 'object') {\n    for (const key in opts) {\n      if (key === 'awaitdata') {\n        // For backwards compatibility\n        this.options[key] = !!opts[key];\n      } else {\n        this.options[key] = opts[key];\n      }\n    }\n  }\n\n  return Query.base.tailable.call(this, val);\n};\n\n/**\n * Declares an intersects query for `geometry()`.\n *\n * ####Example\n *\n *     query.where('path').intersects().geometry({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n *     query.where('path').intersects({\n *         type: 'LineString'\n *       , coordinates: [[180.0, 11.0], [180, 9.0]]\n *     })\n *\n * ####NOTE:\n *\n * **MUST** be used after `where()`.\n *\n * ####NOTE:\n *\n * In Mongoose 3.7, `intersects` changed from a getter to a function. If you need the old syntax, use [this](https://github.com/ebensing/mongoose-within).\n *\n * @method intersects\n * @memberOf Query\n * @instance\n * @param {Object} [arg]\n * @return {Query} this\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @see geoIntersects http://docs.mongodb.org/manual/reference/operator/geoIntersects/\n * @api public\n */\n\n/**\n * Specifies a `$geometry` condition\n *\n * ####Example\n *\n *     var polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\n *     query.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\n *\n *     // or\n *     var polyB = [[ 0, 0 ], [ 1, 1 ]]\n *     query.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\n *\n *     // or\n *     var polyC = [ 0, 0 ]\n *     query.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\n *\n *     // or\n *     query.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\n *\n * The argument is assigned to the most recent path passed to `where()`.\n *\n * ####NOTE:\n *\n * `geometry()` **must** come after either `intersects()` or `within()`.\n *\n * The `object` argument must contain `type` and `coordinates` properties.\n * - type {String}\n * - coordinates {Array}\n *\n * @method geometry\n * @memberOf Query\n * @instance\n * @param {Object} object Must contain a `type` property which is a String and a `coordinates` property which is an Array. See the examples.\n * @return {Query} this\n * @see $geometry http://docs.mongodb.org/manual/reference/operator/geometry/\n * @see http://docs.mongodb.org/manual/release-notes/2.4/#new-geospatial-indexes-with-geojson-and-improved-spherical-geometry\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\n/**\n * Specifies a `$near` or `$nearSphere` condition\n *\n * These operators return documents sorted by distance.\n *\n * ####Example\n *\n *     query.where('loc').near({ center: [10, 10] });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5 });\n *     query.where('loc').near({ center: [10, 10], maxDistance: 5, spherical: true });\n *     query.near('loc', { center: [10, 10], maxDistance: 5 });\n *\n * @method near\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see $near http://docs.mongodb.org/manual/reference/operator/near/\n * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/\n * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\n/*!\n * Overwriting mquery is needed to support a couple different near() forms found in older\n * versions of mongoose\n * near([1,1])\n * near(1,1)\n * near(field, [1,2])\n * near(field, 1, 2)\n * In addition to all of the normal forms supported by mquery\n */\n\nQuery.prototype.near = function() {\n  const params = [];\n  const sphere = this._mongooseOptions.nearSphere;\n\n  // TODO refactor\n\n  if (arguments.length === 1) {\n    if (Array.isArray(arguments[0])) {\n      params.push({center: arguments[0], spherical: sphere});\n    } else if (typeof arguments[0] === 'string') {\n      // just passing a path\n      params.push(arguments[0]);\n    } else if (utils.isObject(arguments[0])) {\n      if (typeof arguments[0].spherical !== 'boolean') {\n        arguments[0].spherical = sphere;\n      }\n      params.push(arguments[0]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      params.push({center: [arguments[0], arguments[1]], spherical: sphere});\n    } else if (typeof arguments[0] === 'string' && Array.isArray(arguments[1])) {\n      params.push(arguments[0]);\n      params.push({center: arguments[1], spherical: sphere});\n    } else if (typeof arguments[0] === 'string' && utils.isObject(arguments[1])) {\n      params.push(arguments[0]);\n      if (typeof arguments[1].spherical !== 'boolean') {\n        arguments[1].spherical = sphere;\n      }\n      params.push(arguments[1]);\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[0] === 'string' && typeof arguments[1] === 'number'\n        && typeof arguments[2] === 'number') {\n      params.push(arguments[0]);\n      params.push({center: [arguments[1], arguments[2]], spherical: sphere});\n    } else {\n      throw new TypeError('invalid argument');\n    }\n  } else {\n    throw new TypeError('invalid argument');\n  }\n\n  return Query.base.near.apply(this, params);\n};\n\n/**\n * _DEPRECATED_ Specifies a `$nearSphere` condition\n *\n * ####Example\n *\n *     query.where('loc').nearSphere({ center: [10, 10], maxDistance: 5 });\n *\n * **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.\n *\n * ####Example\n *\n *     query.where('loc').near({ center: [10, 10], spherical: true });\n *\n * @deprecated\n * @see near() #query_Query-near\n * @see $near http://docs.mongodb.org/manual/reference/operator/near/\n * @see $nearSphere http://docs.mongodb.org/manual/reference/operator/nearSphere/\n * @see $maxDistance http://docs.mongodb.org/manual/reference/operator/maxDistance/\n */\n\nQuery.prototype.nearSphere = function() {\n  this._mongooseOptions.nearSphere = true;\n  this.near.apply(this, arguments);\n  return this;\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](http://bit.ly/async-iterators)\n * This function *only* works for `find()` queries.\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * ####Example\n *\n *     for await (const doc of Model.aggregate([{ $sort: { name: 1 } }])) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method Symbol.asyncIterator\n * @memberOf Query\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Query.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor().transformNull().map(doc => {\n      return doc == null ? { done: true } : { value: doc, done: false };\n    });\n  };\n}\n\n/**\n * Specifies a $polygon condition\n *\n * ####Example\n *\n *     query.where('loc').within().polygon([10,20], [13, 25], [7,15])\n *     query.polygon('loc', [10,20], [13, 25], [7,15])\n *\n * @method polygon\n * @memberOf Query\n * @instance\n * @param {String|Array} [path]\n * @param {Array|Object} [coordinatePairs...]\n * @return {Query} this\n * @see $polygon http://docs.mongodb.org/manual/reference/operator/polygon/\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\n/**\n * Specifies a $box condition\n *\n * ####Example\n *\n *     var lowerLeft = [40.73083, -73.99756]\n *     var upperRight= [40.741404,  -73.988135]\n *\n *     query.where('loc').within().box(lowerLeft, upperRight)\n *     query.box({ ll : lowerLeft, ur : upperRight })\n *\n * @method box\n * @memberOf Query\n * @instance\n * @see $box http://docs.mongodb.org/manual/reference/operator/box/\n * @see within() Query#within #query_Query-within\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @param {Object} val\n * @param [Array] Upper Right Coords\n * @return {Query} this\n * @api public\n */\n\n/*!\n * this is needed to support the mongoose syntax of:\n * box(field, { ll : [x,y], ur : [x2,y2] })\n * box({ ll : [x,y], ur : [x2,y2] })\n */\n\nQuery.prototype.box = function(ll, ur) {\n  if (!Array.isArray(ll) && utils.isObject(ll)) {\n    ur = ll.ur;\n    ll = ll.ll;\n  }\n  return Query.base.box.call(this, ll, ur);\n};\n\n/**\n * Specifies a $center or $centerSphere condition.\n *\n * ####Example\n *\n *     var area = { center: [50, 50], radius: 10, unique: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n *     // spherical calculations\n *     var area = { center: [50, 50], radius: 10, unique: true, spherical: true }\n *     query.where('loc').within().circle(area)\n *     // alternatively\n *     query.circle('loc', area);\n *\n * New in 3.7.0\n *\n * @method circle\n * @memberOf Query\n * @instance\n * @param {String} [path]\n * @param {Object} area\n * @return {Query} this\n * @see $center http://docs.mongodb.org/manual/reference/operator/center/\n * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/\n * @see $geoWithin http://docs.mongodb.org/manual/reference/operator/geoWithin/\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @api public\n */\n\n/**\n * _DEPRECATED_ Alias for [circle](#query_Query-circle)\n *\n * **Deprecated.** Use [circle](#query_Query-circle) instead.\n *\n * @deprecated\n * @method center\n * @memberOf Query\n * @instance\n * @api public\n */\n\nQuery.prototype.center = Query.base.circle;\n\n/**\n * _DEPRECATED_ Specifies a $centerSphere condition\n *\n * **Deprecated.** Use [circle](#query_Query-circle) instead.\n *\n * ####Example\n *\n *     var area = { center: [50, 50], radius: 10 };\n *     query.where('loc').within().centerSphere(area);\n *\n * @deprecated\n * @param {String} [path]\n * @param {Object} val\n * @return {Query} this\n * @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing\n * @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/\n * @api public\n */\n\nQuery.prototype.centerSphere = function() {\n  if (arguments[0] && arguments[0].constructor.name === 'Object') {\n    arguments[0].spherical = true;\n  }\n\n  if (arguments[1] && arguments[1].constructor.name === 'Object') {\n    arguments[1].spherical = true;\n  }\n\n  Query.base.circle.apply(this, arguments);\n};\n\n/**\n * Determines if field selection has been made.\n *\n * @method selected\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\n/**\n * Determines if inclusive field selection has been made.\n *\n *     query.selectedInclusively() // false\n *     query.select('name')\n *     query.selectedInclusively() // true\n *\n * @method selectedInclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedInclusively = function selectedInclusively() {\n  return isInclusive(this._fields);\n};\n\n/**\n * Determines if exclusive field selection has been made.\n *\n *     query.selectedExclusively() // false\n *     query.select('-name')\n *     query.selectedExclusively() // true\n *     query.selectedInclusively() // false\n *\n * @method selectedExclusively\n * @memberOf Query\n * @instance\n * @return {Boolean}\n * @api public\n */\n\nQuery.prototype.selectedExclusively = function selectedExclusively() {\n  if (!this._fields) {\n    return false;\n  }\n\n  const keys = Object.keys(this._fields);\n  if (keys.length === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    if (key === '_id') {\n      continue;\n    }\n    if (this._fields[key] === 0 || this._fields[key] === false) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\n/*!\n * Export\n */\n\nmodule.exports = Query;\n","/*!\n * depd\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar EventEmitter = require('events').EventEmitter\n\n/**\n * Module exports.\n * @public\n */\n\nlazyProperty(module.exports, 'callSiteToString', function callSiteToString () {\n  var limit = Error.stackTraceLimit\n  var obj = {}\n  var prep = Error.prepareStackTrace\n\n  function prepareObjectStackTrace (obj, stack) {\n    return stack\n  }\n\n  Error.prepareStackTrace = prepareObjectStackTrace\n  Error.stackTraceLimit = 2\n\n  // capture the stack\n  Error.captureStackTrace(obj)\n\n  // slice the stack\n  var stack = obj.stack.slice()\n\n  Error.prepareStackTrace = prep\n  Error.stackTraceLimit = limit\n\n  return stack[0].toString ? toString : require('./callsite-tostring')\n})\n\nlazyProperty(module.exports, 'eventListenerCount', function eventListenerCount () {\n  return EventEmitter.listenerCount || require('./event-listener-count')\n})\n\n/**\n * Define a lazy property.\n */\n\nfunction lazyProperty (obj, prop, getter) {\n  function get () {\n    var val = getter()\n\n    Object.defineProperty(obj, prop, {\n      configurable: true,\n      enumerable: true,\n      value: val\n    })\n\n    return val\n  }\n\n  Object.defineProperty(obj, prop, {\n    configurable: true,\n    enumerable: true,\n    get: get\n  })\n}\n\n/**\n * Call toString() on the obj\n */\n\nfunction toString (obj) {\n  return obj.toString()\n}\n","/*!\n * unpipe\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = unpipe\n\n/**\n * Determine if there are Node.js pipe-like data listeners.\n * @private\n */\n\nfunction hasPipeDataListeners(stream) {\n  var listeners = stream.listeners('data')\n\n  for (var i = 0; i < listeners.length; i++) {\n    if (listeners[i].name === 'ondata') {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Unpipe a stream from all destinations.\n *\n * @param {object} stream\n * @public\n */\n\nfunction unpipe(stream) {\n  if (!stream) {\n    throw new TypeError('argument stream is required')\n  }\n\n  if (typeof stream.unpipe === 'function') {\n    // new-style\n    stream.unpipe()\n    return\n  }\n\n  // Node.js 0.8 hack\n  if (!hasPipeDataListeners(stream)) {\n    return\n  }\n\n  var listener\n  var listeners = stream.listeners('close')\n\n  for (var i = 0; i < listeners.length; i++) {\n    listener = listeners[i]\n\n    if (listener.name !== 'cleanup' && listener.name !== 'onclose') {\n      continue\n    }\n\n    // invoke the listener\n    listener.call(stream)\n  }\n}\n","/*!\n * mime-types\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar db = require('mime-db')\nvar extname = require('path').extname\n\n/**\n * Module variables.\n * @private\n */\n\nvar EXTRACT_TYPE_REGEXP = /^\\s*([^;\\s]*)(?:;|\\s|$)/\nvar TEXT_TYPE_REGEXP = /^text\\//i\n\n/**\n * Module exports.\n * @public\n */\n\nexports.charset = charset\nexports.charsets = { lookup: charset }\nexports.contentType = contentType\nexports.extension = extension\nexports.extensions = Object.create(null)\nexports.lookup = lookup\nexports.types = Object.create(null)\n\n// Populate the extensions/types maps\npopulateMaps(exports.extensions, exports.types)\n\n/**\n * Get the default charset for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction charset (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n  var mime = match && db[match[1].toLowerCase()]\n\n  if (mime && mime.charset) {\n    return mime.charset\n  }\n\n  // default text/* to utf-8\n  if (match && TEXT_TYPE_REGEXP.test(match[1])) {\n    return 'UTF-8'\n  }\n\n  return false\n}\n\n/**\n * Create a full Content-Type header given a MIME type or extension.\n *\n * @param {string} str\n * @return {boolean|string}\n */\n\nfunction contentType (str) {\n  // TODO: should this even be in this module?\n  if (!str || typeof str !== 'string') {\n    return false\n  }\n\n  var mime = str.indexOf('/') === -1\n    ? exports.lookup(str)\n    : str\n\n  if (!mime) {\n    return false\n  }\n\n  // TODO: use content-type or other module\n  if (mime.indexOf('charset') === -1) {\n    var charset = exports.charset(mime)\n    if (charset) mime += '; charset=' + charset.toLowerCase()\n  }\n\n  return mime\n}\n\n/**\n * Get the default extension for a MIME type.\n *\n * @param {string} type\n * @return {boolean|string}\n */\n\nfunction extension (type) {\n  if (!type || typeof type !== 'string') {\n    return false\n  }\n\n  // TODO: use media-typer\n  var match = EXTRACT_TYPE_REGEXP.exec(type)\n\n  // get extensions\n  var exts = match && exports.extensions[match[1].toLowerCase()]\n\n  if (!exts || !exts.length) {\n    return false\n  }\n\n  return exts[0]\n}\n\n/**\n * Lookup the MIME type for a file path/extension.\n *\n * @param {string} path\n * @return {boolean|string}\n */\n\nfunction lookup (path) {\n  if (!path || typeof path !== 'string') {\n    return false\n  }\n\n  // get the extension (\"ext\" or \".ext\" or full path)\n  var extension = extname('x.' + path)\n    .toLowerCase()\n    .substr(1)\n\n  if (!extension) {\n    return false\n  }\n\n  return exports.types[extension] || false\n}\n\n/**\n * Populate the extensions and types maps.\n * @private\n */\n\nfunction populateMaps (extensions, types) {\n  // source preference (least -> most)\n  var preference = ['nginx', 'apache', undefined, 'iana']\n\n  Object.keys(db).forEach(function forEachMimeType (type) {\n    var mime = db[type]\n    var exts = mime.extensions\n\n    if (!exts || !exts.length) {\n      return\n    }\n\n    // mime -> extensions\n    extensions[type] = exts\n\n    // extension -> mime\n    for (var i = 0; i < exts.length; i++) {\n      var extension = exts[i]\n\n      if (types[extension]) {\n        var from = preference.indexOf(db[types[extension]].source)\n        var to = preference.indexOf(mime.source)\n\n        if (types[extension] !== 'application/octet-stream' &&\n          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {\n          // skip the remapping\n          continue\n        }\n      }\n\n      // set the extension -> mime\n      types[extension] = type\n    }\n  })\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Route = require('./route');\nvar Layer = require('./layer');\nvar methods = require('methods');\nvar mixin = require('utils-merge');\nvar debug = require('debug')('express:router');\nvar deprecate = require('depd')('express');\nvar flatten = require('array-flatten');\nvar parseUrl = require('parseurl');\nvar setPrototypeOf = require('setprototypeof')\n\n/**\n * Module variables.\n * @private\n */\n\nvar objectRegExp = /^\\[object (\\S+)\\]$/;\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n/**\n * Initialize a new `Router` with the given `options`.\n *\n * @param {Object} [options]\n * @return {Router} which is an callable function\n * @public\n */\n\nvar proto = module.exports = function(options) {\n  var opts = options || {};\n\n  function router(req, res, next) {\n    router.handle(req, res, next);\n  }\n\n  // mixin Router class functions\n  setPrototypeOf(router, proto)\n\n  router.params = {};\n  router._params = [];\n  router.caseSensitive = opts.caseSensitive;\n  router.mergeParams = opts.mergeParams;\n  router.strict = opts.strict;\n  router.stack = [];\n\n  return router;\n};\n\n/**\n * Map the given param placeholder `name`(s) to the given callback.\n *\n * Parameter mapping is used to provide pre-conditions to routes\n * which use normalized placeholders. For example a _:user_id_ parameter\n * could automatically load a user's information from the database without\n * any additional code,\n *\n * The callback uses the same signature as middleware, the only difference\n * being that the value of the placeholder is passed, in this case the _id_\n * of the user. Once the `next()` function is invoked, just like middleware\n * it will continue on to execute the route, or subsequent parameter functions.\n *\n * Just like in middleware, you must either respond to the request or call next\n * to avoid stalling the request.\n *\n *  app.param('user_id', function(req, res, next, id){\n *    User.find(id, function(err, user){\n *      if (err) {\n *        return next(err);\n *      } else if (!user) {\n *        return next(new Error('failed to load user'));\n *      }\n *      req.user = user;\n *      next();\n *    });\n *  });\n *\n * @param {String} name\n * @param {Function} fn\n * @return {app} for chaining\n * @public\n */\n\nproto.param = function param(name, fn) {\n  // param logic\n  if (typeof name === 'function') {\n    deprecate('router.param(fn): Refactor to use path params');\n    this._params.push(name);\n    return;\n  }\n\n  // apply param functions\n  var params = this._params;\n  var len = params.length;\n  var ret;\n\n  if (name[0] === ':') {\n    deprecate('router.param(' + JSON.stringify(name) + ', fn): Use router.param(' + JSON.stringify(name.substr(1)) + ', fn) instead');\n    name = name.substr(1);\n  }\n\n  for (var i = 0; i < len; ++i) {\n    if (ret = params[i](name, fn)) {\n      fn = ret;\n    }\n  }\n\n  // ensure we end up with a\n  // middleware function\n  if ('function' !== typeof fn) {\n    throw new Error('invalid param() call for ' + name + ', got ' + fn);\n  }\n\n  (this.params[name] = this.params[name] || []).push(fn);\n  return this;\n};\n\n/**\n * Dispatch a req, res into the router.\n * @private\n */\n\nproto.handle = function handle(req, res, out) {\n  var self = this;\n\n  debug('dispatching %s %s', req.method, req.url);\n\n  var idx = 0;\n  var protohost = getProtohost(req.url) || ''\n  var removed = '';\n  var slashAdded = false;\n  var paramcalled = {};\n\n  // store options for OPTIONS request\n  // only used if OPTIONS request\n  var options = [];\n\n  // middleware and routes\n  var stack = self.stack;\n\n  // manage inter-router variables\n  var parentParams = req.params;\n  var parentUrl = req.baseUrl || '';\n  var done = restore(out, req, 'baseUrl', 'next', 'params');\n\n  // setup next layer\n  req.next = next;\n\n  // for options requests, respond with a default if nothing else responds\n  if (req.method === 'OPTIONS') {\n    done = wrap(done, function(old, err) {\n      if (err || options.length === 0) return old(err);\n      sendOptionsResponse(res, options, old);\n    });\n  }\n\n  // setup basic req values\n  req.baseUrl = parentUrl;\n  req.originalUrl = req.originalUrl || req.url;\n\n  next();\n\n  function next(err) {\n    var layerError = err === 'route'\n      ? null\n      : err;\n\n    // remove added slash\n    if (slashAdded) {\n      req.url = req.url.substr(1);\n      slashAdded = false;\n    }\n\n    // restore altered req.url\n    if (removed.length !== 0) {\n      req.baseUrl = parentUrl;\n      req.url = protohost + removed + req.url.substr(protohost.length);\n      removed = '';\n    }\n\n    // signal to exit router\n    if (layerError === 'router') {\n      setImmediate(done, null)\n      return\n    }\n\n    // no more matching layers\n    if (idx >= stack.length) {\n      setImmediate(done, layerError);\n      return;\n    }\n\n    // get pathname of request\n    var path = getPathname(req);\n\n    if (path == null) {\n      return done(layerError);\n    }\n\n    // find next matching layer\n    var layer;\n    var match;\n    var route;\n\n    while (match !== true && idx < stack.length) {\n      layer = stack[idx++];\n      match = matchLayer(layer, path);\n      route = layer.route;\n\n      if (typeof match !== 'boolean') {\n        // hold on to layerError\n        layerError = layerError || match;\n      }\n\n      if (match !== true) {\n        continue;\n      }\n\n      if (!route) {\n        // process non-route handlers normally\n        continue;\n      }\n\n      if (layerError) {\n        // routes do not match with a pending error\n        match = false;\n        continue;\n      }\n\n      var method = req.method;\n      var has_method = route._handles_method(method);\n\n      // build up automatic options response\n      if (!has_method && method === 'OPTIONS') {\n        appendMethods(options, route._options());\n      }\n\n      // don't even bother matching route\n      if (!has_method && method !== 'HEAD') {\n        match = false;\n        continue;\n      }\n    }\n\n    // no match\n    if (match !== true) {\n      return done(layerError);\n    }\n\n    // store route for dispatch on change\n    if (route) {\n      req.route = route;\n    }\n\n    // Capture one-time layer values\n    req.params = self.mergeParams\n      ? mergeParams(layer.params, parentParams)\n      : layer.params;\n    var layerPath = layer.path;\n\n    // this should be done for the layer\n    self.process_params(layer, paramcalled, req, res, function (err) {\n      if (err) {\n        return next(layerError || err);\n      }\n\n      if (route) {\n        return layer.handle_request(req, res, next);\n      }\n\n      trim_prefix(layer, layerError, layerPath, path);\n    });\n  }\n\n  function trim_prefix(layer, layerError, layerPath, path) {\n    if (layerPath.length !== 0) {\n      // Validate path breaks on a path separator\n      var c = path[layerPath.length]\n      if (c && c !== '/' && c !== '.') return next(layerError)\n\n      // Trim off the part of the url that matches the route\n      // middleware (.use stuff) needs to have the path stripped\n      debug('trim prefix (%s) from url %s', layerPath, req.url);\n      removed = layerPath;\n      req.url = protohost + req.url.substr(protohost.length + removed.length);\n\n      // Ensure leading slash\n      if (!protohost && req.url[0] !== '/') {\n        req.url = '/' + req.url;\n        slashAdded = true;\n      }\n\n      // Setup base URL (no trailing slash)\n      req.baseUrl = parentUrl + (removed[removed.length - 1] === '/'\n        ? removed.substring(0, removed.length - 1)\n        : removed);\n    }\n\n    debug('%s %s : %s', layer.name, layerPath, req.originalUrl);\n\n    if (layerError) {\n      layer.handle_error(layerError, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n\n/**\n * Process any parameters for the layer.\n * @private\n */\n\nproto.process_params = function process_params(layer, called, req, res, done) {\n  var params = this.params;\n\n  // captured parameters from the layer, keys and values\n  var keys = layer.keys;\n\n  // fast track\n  if (!keys || keys.length === 0) {\n    return done();\n  }\n\n  var i = 0;\n  var name;\n  var paramIndex = 0;\n  var key;\n  var paramVal;\n  var paramCallbacks;\n  var paramCalled;\n\n  // process params in order\n  // param callbacks can be async\n  function param(err) {\n    if (err) {\n      return done(err);\n    }\n\n    if (i >= keys.length ) {\n      return done();\n    }\n\n    paramIndex = 0;\n    key = keys[i++];\n    name = key.name;\n    paramVal = req.params[name];\n    paramCallbacks = params[name];\n    paramCalled = called[name];\n\n    if (paramVal === undefined || !paramCallbacks) {\n      return param();\n    }\n\n    // param previously called with same value or error occurred\n    if (paramCalled && (paramCalled.match === paramVal\n      || (paramCalled.error && paramCalled.error !== 'route'))) {\n      // restore value\n      req.params[name] = paramCalled.value;\n\n      // next param\n      return param(paramCalled.error);\n    }\n\n    called[name] = paramCalled = {\n      error: null,\n      match: paramVal,\n      value: paramVal\n    };\n\n    paramCallback();\n  }\n\n  // single param callbacks\n  function paramCallback(err) {\n    var fn = paramCallbacks[paramIndex++];\n\n    // store updated value\n    paramCalled.value = req.params[key.name];\n\n    if (err) {\n      // store error\n      paramCalled.error = err;\n      param(err);\n      return;\n    }\n\n    if (!fn) return param();\n\n    try {\n      fn(req, res, paramCallback, paramVal, key.name);\n    } catch (e) {\n      paramCallback(e);\n    }\n  }\n\n  param();\n};\n\n/**\n * Use the given middleware function, with optional path, defaulting to \"/\".\n *\n * Use (like `.all`) will run for any http METHOD, but it will not add\n * handlers for those methods so OPTIONS requests will not consider `.use`\n * functions even if they could respond.\n *\n * The other difference is that _route_ path is stripped and not visible\n * to the handler function. The main effect of this feature is that mounted\n * handlers can operate without any code changes regardless of the \"prefix\"\n * pathname.\n *\n * @public\n */\n\nproto.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate router.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var callbacks = flatten(slice.call(arguments, offset));\n\n  if (callbacks.length === 0) {\n    throw new TypeError('Router.use() requires a middleware function')\n  }\n\n  for (var i = 0; i < callbacks.length; i++) {\n    var fn = callbacks[i];\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Router.use() requires a middleware function but got a ' + gettype(fn))\n    }\n\n    // add the middleware\n    debug('use %o %s', path, fn.name || '<anonymous>')\n\n    var layer = new Layer(path, {\n      sensitive: this.caseSensitive,\n      strict: false,\n      end: false\n    }, fn);\n\n    layer.route = undefined;\n\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n\n/**\n * Create a new Route for the given path.\n *\n * Each route contains a separate middleware stack and VERB handlers.\n *\n * See the Route api documentation for details on adding handlers\n * and middleware to routes.\n *\n * @param {String} path\n * @return {Route}\n * @public\n */\n\nproto.route = function route(path) {\n  var route = new Route(path);\n\n  var layer = new Layer(path, {\n    sensitive: this.caseSensitive,\n    strict: this.strict,\n    end: true\n  }, route.dispatch.bind(route));\n\n  layer.route = route;\n\n  this.stack.push(layer);\n  return route;\n};\n\n// create Router#VERB functions\nmethods.concat('all').forEach(function(method){\n  proto[method] = function(path){\n    var route = this.route(path)\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n\n// append methods to a list of methods\nfunction appendMethods(list, addition) {\n  for (var i = 0; i < addition.length; i++) {\n    var method = addition[i];\n    if (list.indexOf(method) === -1) {\n      list.push(method);\n    }\n  }\n}\n\n// get pathname of request\nfunction getPathname(req) {\n  try {\n    return parseUrl(req).pathname;\n  } catch (err) {\n    return undefined;\n  }\n}\n\n// Get get protocol + host for a URL\nfunction getProtohost(url) {\n  if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {\n    return undefined\n  }\n\n  var searchIndex = url.indexOf('?')\n  var pathLength = searchIndex !== -1\n    ? searchIndex\n    : url.length\n  var fqdnIndex = url.substr(0, pathLength).indexOf('://')\n\n  return fqdnIndex !== -1\n    ? url.substr(0, url.indexOf('/', 3 + fqdnIndex))\n    : undefined\n}\n\n// get type for error message\nfunction gettype(obj) {\n  var type = typeof obj;\n\n  if (type !== 'object') {\n    return type;\n  }\n\n  // inspect [[Class]] for objects\n  return toString.call(obj)\n    .replace(objectRegExp, '$1');\n}\n\n/**\n * Match path to a layer.\n *\n * @param {Layer} layer\n * @param {string} path\n * @private\n */\n\nfunction matchLayer(layer, path) {\n  try {\n    return layer.match(path);\n  } catch (err) {\n    return err;\n  }\n}\n\n// merge params with parent params\nfunction mergeParams(params, parent) {\n  if (typeof parent !== 'object' || !parent) {\n    return params;\n  }\n\n  // make copy of parent for base\n  var obj = mixin({}, parent);\n\n  // simple non-numeric merging\n  if (!(0 in params) || !(0 in parent)) {\n    return mixin(obj, params);\n  }\n\n  var i = 0;\n  var o = 0;\n\n  // determine numeric gaps\n  while (i in params) {\n    i++;\n  }\n\n  while (o in parent) {\n    o++;\n  }\n\n  // offset numeric indices in params before merge\n  for (i--; i >= 0; i--) {\n    params[i + o] = params[i];\n\n    // create holes for the merge when necessary\n    if (i < o) {\n      delete params[i];\n    }\n  }\n\n  return mixin(obj, params);\n}\n\n// restore obj props after function\nfunction restore(fn, obj) {\n  var props = new Array(arguments.length - 2);\n  var vals = new Array(arguments.length - 2);\n\n  for (var i = 0; i < props.length; i++) {\n    props[i] = arguments[i + 2];\n    vals[i] = obj[props[i]];\n  }\n\n  return function () {\n    // restore vals\n    for (var i = 0; i < props.length; i++) {\n      obj[props[i]] = vals[i];\n    }\n\n    return fn.apply(this, arguments);\n  };\n}\n\n// send an OPTIONS response\nfunction sendOptionsResponse(res, options, next) {\n  try {\n    var body = options.join(',');\n    res.set('Allow', body);\n    res.send(body);\n  } catch (err) {\n    next(err);\n  }\n}\n\n// wrap a function\nfunction wrap(old, fn) {\n  return function proxy() {\n    var args = new Array(arguments.length + 1);\n\n    args[0] = old;\n    for (var i = 0, len = arguments.length; i < len; i++) {\n      args[i + 1] = arguments[i];\n    }\n\n    fn.apply(this, args);\n  };\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar debug = require('debug')('express:router:route');\nvar flatten = require('array-flatten');\nvar Layer = require('./layer');\nvar methods = require('methods');\n\n/**\n * Module variables.\n * @private\n */\n\nvar slice = Array.prototype.slice;\nvar toString = Object.prototype.toString;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Route;\n\n/**\n * Initialize `Route` with the given `path`,\n *\n * @param {String} path\n * @public\n */\n\nfunction Route(path) {\n  this.path = path;\n  this.stack = [];\n\n  debug('new %o', path)\n\n  // route handlers for various http methods\n  this.methods = {};\n}\n\n/**\n * Determine if the route handles a given method.\n * @private\n */\n\nRoute.prototype._handles_method = function _handles_method(method) {\n  if (this.methods._all) {\n    return true;\n  }\n\n  var name = method.toLowerCase();\n\n  if (name === 'head' && !this.methods['head']) {\n    name = 'get';\n  }\n\n  return Boolean(this.methods[name]);\n};\n\n/**\n * @return {Array} supported HTTP methods\n * @private\n */\n\nRoute.prototype._options = function _options() {\n  var methods = Object.keys(this.methods);\n\n  // append automatic head\n  if (this.methods.get && !this.methods.head) {\n    methods.push('head');\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    // make upper case\n    methods[i] = methods[i].toUpperCase();\n  }\n\n  return methods;\n};\n\n/**\n * dispatch req, res into this route\n * @private\n */\n\nRoute.prototype.dispatch = function dispatch(req, res, done) {\n  var idx = 0;\n  var stack = this.stack;\n  if (stack.length === 0) {\n    return done();\n  }\n\n  var method = req.method.toLowerCase();\n  if (method === 'head' && !this.methods['head']) {\n    method = 'get';\n  }\n\n  req.route = this;\n\n  next();\n\n  function next(err) {\n    // signal to exit route\n    if (err && err === 'route') {\n      return done();\n    }\n\n    // signal to exit router\n    if (err && err === 'router') {\n      return done(err)\n    }\n\n    var layer = stack[idx++];\n    if (!layer) {\n      return done(err);\n    }\n\n    if (layer.method && layer.method !== method) {\n      return next(err);\n    }\n\n    if (err) {\n      layer.handle_error(err, req, res, next);\n    } else {\n      layer.handle_request(req, res, next);\n    }\n  }\n};\n\n/**\n * Add a handler for all HTTP verbs to this route.\n *\n * Behaves just like middleware and can respond or call `next`\n * to continue processing.\n *\n * You can use multiple `.all` call to add multiple handlers.\n *\n *   function check_something(req, res, next){\n *     next();\n *   };\n *\n *   function validate_user(req, res, next){\n *     next();\n *   };\n *\n *   route\n *   .all(validate_user)\n *   .all(check_something)\n *   .get(function(req, res, next){\n *     res.send('hello world');\n *   });\n *\n * @param {function} handler\n * @return {Route} for chaining\n * @api public\n */\n\nRoute.prototype.all = function all() {\n  var handles = flatten(slice.call(arguments));\n\n  for (var i = 0; i < handles.length; i++) {\n    var handle = handles[i];\n\n    if (typeof handle !== 'function') {\n      var type = toString.call(handle);\n      var msg = 'Route.all() requires a callback function but got a ' + type\n      throw new TypeError(msg);\n    }\n\n    var layer = Layer('/', {}, handle);\n    layer.method = undefined;\n\n    this.methods._all = true;\n    this.stack.push(layer);\n  }\n\n  return this;\n};\n\nmethods.forEach(function(method){\n  Route.prototype[method] = function(){\n    var handles = flatten(slice.call(arguments));\n\n    for (var i = 0; i < handles.length; i++) {\n      var handle = handles[i];\n\n      if (typeof handle !== 'function') {\n        var type = toString.call(handle);\n        var msg = 'Route.' + method + '() requires a callback function but got a ' + type\n        throw new Error(msg);\n      }\n\n      debug('%s %o', method, this.path)\n\n      var layer = Layer('/', {}, handle);\n      layer.method = method;\n\n      this.methods[method] = true;\n      this.stack.push(layer);\n    }\n\n    return this;\n  };\n});\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar pathRegexp = require('path-to-regexp');\nvar debug = require('debug')('express:router:layer');\n\n/**\n * Module variables.\n * @private\n */\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Layer;\n\nfunction Layer(path, options, fn) {\n  if (!(this instanceof Layer)) {\n    return new Layer(path, options, fn);\n  }\n\n  debug('new %o', path)\n  var opts = options || {};\n\n  this.handle = fn;\n  this.name = fn.name || '<anonymous>';\n  this.params = undefined;\n  this.path = undefined;\n  this.regexp = pathRegexp(path, this.keys = [], opts);\n\n  // set fast path flags\n  this.regexp.fast_star = path === '*'\n  this.regexp.fast_slash = path === '/' && opts.end === false\n}\n\n/**\n * Handle the error for the layer.\n *\n * @param {Error} error\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\n\nLayer.prototype.handle_error = function handle_error(error, req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length !== 4) {\n    // not a standard error handler\n    return next(error);\n  }\n\n  try {\n    fn(error, req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Handle the request for the layer.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {function} next\n * @api private\n */\n\nLayer.prototype.handle_request = function handle(req, res, next) {\n  var fn = this.handle;\n\n  if (fn.length > 3) {\n    // not a standard request handler\n    return next();\n  }\n\n  try {\n    fn(req, res, next);\n  } catch (err) {\n    next(err);\n  }\n};\n\n/**\n * Check if this route matches `path`, if so\n * populate `.params`.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nLayer.prototype.match = function match(path) {\n  var match\n\n  if (path != null) {\n    // fast path non-ending match for / (any path matches)\n    if (this.regexp.fast_slash) {\n      this.params = {}\n      this.path = ''\n      return true\n    }\n\n    // fast path for * (everything matched in a param)\n    if (this.regexp.fast_star) {\n      this.params = {'0': decode_param(path)}\n      this.path = path\n      return true\n    }\n\n    // match the path\n    match = this.regexp.exec(path)\n  }\n\n  if (!match) {\n    this.params = undefined;\n    this.path = undefined;\n    return false;\n  }\n\n  // store values\n  this.params = {};\n  this.path = match[0]\n\n  var keys = this.keys;\n  var params = this.params;\n\n  for (var i = 1; i < match.length; i++) {\n    var key = keys[i - 1];\n    var prop = key.name;\n    var val = decode_param(match[i])\n\n    if (val !== undefined || !(hasOwnProperty.call(params, prop))) {\n      params[prop] = val;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Decode param value.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction decode_param(val) {\n  if (typeof val !== 'string' || val.length === 0) {\n    return val;\n  }\n\n  try {\n    return decodeURIComponent(val);\n  } catch (err) {\n    if (err instanceof URIError) {\n      err.message = 'Failed to decode param \\'' + val + '\\'';\n      err.status = err.statusCode = 400;\n    }\n\n    throw err;\n  }\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar merge = require('utils-merge')\nvar parseUrl = require('parseurl');\nvar qs = require('qs');\n\n/**\n * @param {Object} options\n * @return {Function}\n * @api public\n */\n\nmodule.exports = function query(options) {\n  var opts = merge({}, options)\n  var queryparse = qs.parse;\n\n  if (typeof options === 'function') {\n    queryparse = options;\n    opts = undefined;\n  }\n\n  if (opts !== undefined && opts.allowPrototypes === undefined) {\n    // back-compat for qs module\n    opts.allowPrototypes = true;\n  }\n\n  return function query(req, res, next){\n    if (!req.query) {\n      var val = parseUrl(req).query;\n      req.query = queryparse(val, opts);\n    }\n\n    next();\n  };\n};\n","/*!\n * content-disposition\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = contentDisposition\nmodule.exports.parse = parse\n\n/**\n * Module dependencies.\n */\n\nvar basename = require('path').basename\n\n/**\n * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including \"%\")\n */\n\nvar ENCODE_URL_ATTR_CHAR_REGEXP = /[\\x00-\\x20\"'()*,/:;<=>?@[\\\\\\]{}\\x7f]/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match percent encoding escape.\n */\n\nvar HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/\nvar HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g\n\n/**\n * RegExp to match non-latin1 characters.\n */\n\nvar NON_LATIN1_REGEXP = /[^\\x20-\\x7e\\xa0-\\xff]/g\n\n/**\n * RegExp to match quoted-pair in RFC 2616\n *\n * quoted-pair = \"\\\" CHAR\n * CHAR        = <any US-ASCII character (octets 0 - 127)>\n */\n\nvar QESC_REGEXP = /\\\\([\\u0000-\\u007f])/g\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 2616\n */\n\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp for various RFC 2616 grammar\n *\n * parameter     = token \"=\" ( token | quoted-string )\n * token         = 1*<any CHAR except CTLs or separators>\n * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *               | \"{\" | \"}\" | SP | HT\n * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n * qdtext        = <any TEXT except <\">>\n * quoted-pair   = \"\\\" CHAR\n * CHAR          = <any US-ASCII character (octets 0 - 127)>\n * TEXT          = <any OCTET except CTLs, but including LWS>\n * LWS           = [CRLF] 1*( SP | HT )\n * CRLF          = CR LF\n * CR            = <US-ASCII CR, carriage return (13)>\n * LF            = <US-ASCII LF, linefeed (10)>\n * SP            = <US-ASCII SP, space (32)>\n * HT            = <US-ASCII HT, horizontal-tab (9)>\n * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n * OCTET         = <any 8-bit sequence of data>\n */\n\nvar PARAM_REGEXP = /;[\\x09\\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*=[\\x09\\x20]*(\"(?:[\\x20!\\x23-\\x5b\\x5d-\\x7e\\x80-\\xff]|\\\\[\\x20-\\x7e])*\"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*/g // eslint-disable-line no-control-regex\nvar TEXT_REGEXP = /^[\\x20-\\x7e\\x80-\\xff]+$/\nvar TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/\n\n/**\n * RegExp for various RFC 5987 grammar\n *\n * ext-value     = charset  \"'\" [ language ] \"'\" value-chars\n * charset       = \"UTF-8\" / \"ISO-8859-1\" / mime-charset\n * mime-charset  = 1*mime-charsetc\n * mime-charsetc = ALPHA / DIGIT\n *               / \"!\" / \"#\" / \"$\" / \"%\" / \"&\"\n *               / \"+\" / \"-\" / \"^\" / \"_\" / \"`\"\n *               / \"{\" / \"}\" / \"~\"\n * language      = ( 2*3ALPHA [ extlang ] )\n *               / 4ALPHA\n *               / 5*8ALPHA\n * extlang       = *3( \"-\" 3ALPHA )\n * value-chars   = *( pct-encoded / attr-char )\n * pct-encoded   = \"%\" HEXDIG HEXDIG\n * attr-char     = ALPHA / DIGIT\n *               / \"!\" / \"#\" / \"$\" / \"&\" / \"+\" / \"-\" / \".\"\n *               / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n */\n\nvar EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/\n\n/**\n * RegExp for various RFC 6266 grammar\n *\n * disposition-type = \"inline\" | \"attachment\" | disp-ext-type\n * disp-ext-type    = token\n * disposition-parm = filename-parm | disp-ext-parm\n * filename-parm    = \"filename\" \"=\" value\n *                  | \"filename*\" \"=\" ext-value\n * disp-ext-parm    = token \"=\" value\n *                  | ext-token \"=\" ext-value\n * ext-token        = <the characters in token, followed by \"*\">\n */\n\nvar DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\\x09\\x20]*(?:$|;)/ // eslint-disable-line no-control-regex\n\n/**\n * Create an attachment Content-Disposition header.\n *\n * @param {string} [filename]\n * @param {object} [options]\n * @param {string} [options.type=attachment]\n * @param {string|boolean} [options.fallback=true]\n * @return {string}\n * @api public\n */\n\nfunction contentDisposition (filename, options) {\n  var opts = options || {}\n\n  // get type\n  var type = opts.type || 'attachment'\n\n  // get parameters\n  var params = createparams(filename, opts.fallback)\n\n  // format into string\n  return format(new ContentDisposition(type, params))\n}\n\n/**\n * Create parameters object from filename and fallback.\n *\n * @param {string} [filename]\n * @param {string|boolean} [fallback=true]\n * @return {object}\n * @api private\n */\n\nfunction createparams (filename, fallback) {\n  if (filename === undefined) {\n    return\n  }\n\n  var params = {}\n\n  if (typeof filename !== 'string') {\n    throw new TypeError('filename must be a string')\n  }\n\n  // fallback defaults to true\n  if (fallback === undefined) {\n    fallback = true\n  }\n\n  if (typeof fallback !== 'string' && typeof fallback !== 'boolean') {\n    throw new TypeError('fallback must be a string or boolean')\n  }\n\n  if (typeof fallback === 'string' && NON_LATIN1_REGEXP.test(fallback)) {\n    throw new TypeError('fallback must be ISO-8859-1 string')\n  }\n\n  // restrict to file base name\n  var name = basename(filename)\n\n  // determine if name is suitable for quoted string\n  var isQuotedString = TEXT_REGEXP.test(name)\n\n  // generate fallback name\n  var fallbackName = typeof fallback !== 'string'\n    ? fallback && getlatin1(name)\n    : basename(fallback)\n  var hasFallback = typeof fallbackName === 'string' && fallbackName !== name\n\n  // set extended filename parameter\n  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {\n    params['filename*'] = name\n  }\n\n  // set filename parameter\n  if (isQuotedString || hasFallback) {\n    params.filename = hasFallback\n      ? fallbackName\n      : name\n  }\n\n  return params\n}\n\n/**\n * Format object to Content-Disposition header.\n *\n * @param {object} obj\n * @param {string} obj.type\n * @param {object} [obj.parameters]\n * @return {string}\n * @api private\n */\n\nfunction format (obj) {\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || typeof type !== 'string' || !TOKEN_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  // start with normalized type\n  var string = String(type).toLowerCase()\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      var val = param.substr(-1) === '*'\n        ? ustring(parameters[param])\n        : qstring(parameters[param])\n\n      string += '; ' + param + '=' + val\n    }\n  }\n\n  return string\n}\n\n/**\n * Decode a RFC 6987 field value (gracefully).\n *\n * @param {string} str\n * @return {string}\n * @api private\n */\n\nfunction decodefield (str) {\n  var match = EXT_VALUE_REGEXP.exec(str)\n\n  if (!match) {\n    throw new TypeError('invalid extended field value')\n  }\n\n  var charset = match[1].toLowerCase()\n  var encoded = match[2]\n  var value\n\n  // to binary string\n  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode)\n\n  switch (charset) {\n    case 'iso-8859-1':\n      value = getlatin1(binary)\n      break\n    case 'utf-8':\n      value = new Buffer(binary, 'binary').toString('utf8')\n      break\n    default:\n      throw new TypeError('unsupported charset in extended field')\n  }\n\n  return value\n}\n\n/**\n * Get ISO-8859-1 version of string.\n *\n * @param {string} val\n * @return {string}\n * @api private\n */\n\nfunction getlatin1 (val) {\n  // simple Unicode -> ISO-8859-1 transformation\n  return String(val).replace(NON_LATIN1_REGEXP, '?')\n}\n\n/**\n * Parse Content-Disposition header string.\n *\n * @param {string} string\n * @return {object}\n * @api private\n */\n\nfunction parse (string) {\n  if (!string || typeof string !== 'string') {\n    throw new TypeError('argument string is required')\n  }\n\n  var match = DISPOSITION_TYPE_REGEXP.exec(string)\n\n  if (!match) {\n    throw new TypeError('invalid type format')\n  }\n\n  // normalize type\n  var index = match[0].length\n  var type = match[1].toLowerCase()\n\n  var key\n  var names = []\n  var params = {}\n  var value\n\n  // calculate index to start at\n  index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ';'\n    ? index - 1\n    : index\n\n  // match parameters\n  while ((match = PARAM_REGEXP.exec(string))) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (names.indexOf(key) !== -1) {\n      throw new TypeError('invalid duplicate parameter')\n    }\n\n    names.push(key)\n\n    if (key.indexOf('*') + 1 === key.length) {\n      // decode extended value\n      key = key.slice(0, -1)\n      value = decodefield(value)\n\n      // overwrite existing value\n      params[key] = value\n      continue\n    }\n\n    if (typeof params[key] === 'string') {\n      continue\n    }\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .substr(1, value.length - 2)\n        .replace(QESC_REGEXP, '$1')\n    }\n\n    params[key] = value\n  }\n\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  return new ContentDisposition(type, params)\n}\n\n/**\n * Percent decode a single character.\n *\n * @param {string} str\n * @param {string} hex\n * @return {string}\n * @api private\n */\n\nfunction pdecode (str, hex) {\n  return String.fromCharCode(parseInt(hex, 16))\n}\n\n/**\n * Percent encode a single character.\n *\n * @param {string} char\n * @return {string}\n * @api private\n */\n\nfunction pencode (char) {\n  var hex = String(char)\n    .charCodeAt(0)\n    .toString(16)\n    .toUpperCase()\n  return hex.length === 1\n    ? '%0' + hex\n    : '%' + hex\n}\n\n/**\n * Quote a string for HTTP.\n *\n * @param {string} val\n * @return {string}\n * @api private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Encode a Unicode string for HTTP (RFC 5987).\n *\n * @param {string} val\n * @return {string}\n * @api private\n */\n\nfunction ustring (val) {\n  var str = String(val)\n\n  // percent encode as UTF-8\n  var encoded = encodeURIComponent(str)\n    .replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode)\n\n  return 'UTF-8\\'\\'' + encoded\n}\n\n/**\n * Class for parsed Content-Disposition header for v8 optimization\n */\n\nfunction ContentDisposition (type, parameters) {\n  this.type = type\n  this.parameters = parameters\n}\n","/*!\n * etag\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = etag\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar crypto = require('crypto')\nvar Stats = require('fs').Stats\n\n/**\n * Module variables.\n * @private\n */\n\nvar toString = Object.prototype.toString\n\n/**\n * Generate an entity tag.\n *\n * @param {Buffer|string} entity\n * @return {string}\n * @private\n */\n\nfunction entitytag (entity) {\n  if (entity.length === 0) {\n    // fast-path empty\n    return '\"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk\"'\n  }\n\n  // compute hash of entity\n  var hash = crypto\n    .createHash('sha1')\n    .update(entity, 'utf8')\n    .digest('base64')\n    .substring(0, 27)\n\n  // compute length of entity\n  var len = typeof entity === 'string'\n    ? Buffer.byteLength(entity, 'utf8')\n    : entity.length\n\n  return '\"' + len.toString(16) + '-' + hash + '\"'\n}\n\n/**\n * Create a simple ETag.\n *\n * @param {string|Buffer|Stats} entity\n * @param {object} [options]\n * @param {boolean} [options.weak]\n * @return {String}\n * @public\n */\n\nfunction etag (entity, options) {\n  if (entity == null) {\n    throw new TypeError('argument entity is required')\n  }\n\n  // support fs.Stats object\n  var isStats = isstats(entity)\n  var weak = options && typeof options.weak === 'boolean'\n    ? options.weak\n    : isStats\n\n  // validate argument\n  if (!isStats && typeof entity !== 'string' && !Buffer.isBuffer(entity)) {\n    throw new TypeError('argument entity must be string, Buffer, or fs.Stats')\n  }\n\n  // generate entity tag\n  var tag = isStats\n    ? stattag(entity)\n    : entitytag(entity)\n\n  return weak\n    ? 'W/' + tag\n    : tag\n}\n\n/**\n * Determine if object is a Stats object.\n *\n * @param {object} obj\n * @return {boolean}\n * @api private\n */\n\nfunction isstats (obj) {\n  // genuine fs.Stats\n  if (typeof Stats === 'function' && obj instanceof Stats) {\n    return true\n  }\n\n  // quack quack\n  return obj && typeof obj === 'object' &&\n    'ctime' in obj && toString.call(obj.ctime) === '[object Date]' &&\n    'mtime' in obj && toString.call(obj.mtime) === '[object Date]' &&\n    'ino' in obj && typeof obj.ino === 'number' &&\n    'size' in obj && typeof obj.size === 'number'\n}\n\n/**\n * Generate a tag for a stat.\n *\n * @param {object} stat\n * @return {string}\n * @private\n */\n\nfunction stattag (stat) {\n  var mtime = stat.mtime.getTime().toString(16)\n  var size = stat.size.toString(16)\n\n  return '\"' + size + '-' + mtime + '\"'\n}\n","/*!\n * fresh\n * Copyright(c) 2012 TJ Holowaychuk\n * Copyright(c) 2016-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to check for no-cache token in Cache-Control.\n * @private\n */\n\nvar CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\\s*?no-cache\\s*?(?:,|$)/\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = fresh\n\n/**\n * Check freshness of the response using request and response headers.\n *\n * @param {Object} reqHeaders\n * @param {Object} resHeaders\n * @return {Boolean}\n * @public\n */\n\nfunction fresh (reqHeaders, resHeaders) {\n  // fields\n  var modifiedSince = reqHeaders['if-modified-since']\n  var noneMatch = reqHeaders['if-none-match']\n\n  // unconditional request\n  if (!modifiedSince && !noneMatch) {\n    return false\n  }\n\n  // Always return stale when Cache-Control: no-cache\n  // to support end-to-end reload requests\n  // https://tools.ietf.org/html/rfc2616#section-14.9.4\n  var cacheControl = reqHeaders['cache-control']\n  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {\n    return false\n  }\n\n  // if-none-match\n  if (noneMatch && noneMatch !== '*') {\n    var etag = resHeaders['etag']\n\n    if (!etag) {\n      return false\n    }\n\n    var etagStale = true\n    var matches = parseTokenList(noneMatch)\n    for (var i = 0; i < matches.length; i++) {\n      var match = matches[i]\n      if (match === etag || match === 'W/' + etag || 'W/' + match === etag) {\n        etagStale = false\n        break\n      }\n    }\n\n    if (etagStale) {\n      return false\n    }\n  }\n\n  // if-modified-since\n  if (modifiedSince) {\n    var lastModified = resHeaders['last-modified']\n    var modifiedStale = !lastModified || !(parseHttpDate(lastModified) <= parseHttpDate(modifiedSince))\n\n    if (modifiedStale) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Parse an HTTP Date into a number.\n *\n * @param {string} date\n * @private\n */\n\nfunction parseHttpDate (date) {\n  var timestamp = date && Date.parse(date)\n\n  // istanbul ignore next: guard against date.js Date.parse patching\n  return typeof timestamp === 'number'\n    ? timestamp\n    : NaN\n}\n\n/**\n * Parse a HTTP token list.\n *\n * @param {string} str\n * @private\n */\n\nfunction parseTokenList (str) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = str.length; i < len; i++) {\n    switch (str.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(str.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(str.substring(start, end))\n\n  return list\n}\n","/*!\n * range-parser\n * Copyright(c) 2012-2014 TJ Holowaychuk\n * Copyright(c) 2015-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = rangeParser\n\n/**\n * Parse \"Range\" header `str` relative to the given file `size`.\n *\n * @param {Number} size\n * @param {String} str\n * @param {Object} [options]\n * @return {Array}\n * @public\n */\n\nfunction rangeParser (size, str, options) {\n  var index = str.indexOf('=')\n\n  if (index === -1) {\n    return -2\n  }\n\n  // split the range string\n  var arr = str.slice(index + 1).split(',')\n  var ranges = []\n\n  // add ranges type\n  ranges.type = str.slice(0, index)\n\n  // parse all ranges\n  for (var i = 0; i < arr.length; i++) {\n    var range = arr[i].split('-')\n    var start = parseInt(range[0], 10)\n    var end = parseInt(range[1], 10)\n\n    // -nnn\n    if (isNaN(start)) {\n      start = size - end\n      end = size - 1\n    // nnn-\n    } else if (isNaN(end)) {\n      end = size - 1\n    }\n\n    // limit last-byte-pos to current length\n    if (end > size - 1) {\n      end = size - 1\n    }\n\n    // invalid or unsatisifiable\n    if (isNaN(start) || isNaN(end) || start > end || start < 0) {\n      continue\n    }\n\n    // add range\n    ranges.push({\n      start: start,\n      end: end\n    })\n  }\n\n  if (ranges.length < 1) {\n    // unsatisifiable\n    return -1\n  }\n\n  return options && options.combine\n    ? combineRanges(ranges)\n    : ranges\n}\n\n/**\n * Combine overlapping & adjacent ranges.\n * @private\n */\n\nfunction combineRanges (ranges) {\n  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart)\n\n  for (var j = 0, i = 1; i < ordered.length; i++) {\n    var range = ordered[i]\n    var current = ordered[j]\n\n    if (range.start > current.end + 1) {\n      // next range\n      ordered[++j] = range\n    } else if (range.end > current.end) {\n      // extend range\n      current.end = range.end\n      current.index = Math.min(current.index, range.index)\n    }\n  }\n\n  // trim ordered array\n  ordered.length = j + 1\n\n  // generate combined range\n  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex)\n\n  // copy ranges type\n  combined.type = ranges.type\n\n  return combined\n}\n\n/**\n * Map function to add index value to ranges.\n * @private\n */\n\nfunction mapWithIndex (range, index) {\n  return {\n    start: range.start,\n    end: range.end,\n    index: index\n  }\n}\n\n/**\n * Map function to remove index value from ranges.\n * @private\n */\n\nfunction mapWithoutIndex (range) {\n  return {\n    start: range.start,\n    end: range.end\n  }\n}\n\n/**\n * Sort function to sort ranges by index.\n * @private\n */\n\nfunction sortByRangeIndex (a, b) {\n  return a.index - b.index\n}\n\n/**\n * Sort function to sort ranges by start position.\n * @private\n */\n\nfunction sortByRangeStart (a, b) {\n  return a.start - b.start\n}\n","/*!\n * proxy-addr\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = proxyaddr\nmodule.exports.all = alladdrs\nmodule.exports.compile = compile\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar forwarded = require('forwarded')\nvar ipaddr = require('ipaddr.js')\n\n/**\n * Variables.\n * @private\n */\n\nvar DIGIT_REGEXP = /^[0-9]+$/\nvar isip = ipaddr.isValid\nvar parseip = ipaddr.parse\n\n/**\n * Pre-defined IP ranges.\n * @private\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n}\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @public\n */\n\nfunction alladdrs (req, trust) {\n  // get addresses\n  var addrs = forwarded(req)\n\n  if (!trust) {\n    // Return all addresses\n    return addrs\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust)\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue\n\n    addrs.length = i + 1\n  }\n\n  return addrs\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @private\n */\n\nfunction compile (val) {\n  if (!val) {\n    throw new TypeError('argument is required')\n  }\n\n  var trust\n\n  if (typeof val === 'string') {\n    trust = [val]\n  } else if (Array.isArray(val)) {\n    trust = val.slice()\n  } else {\n    throw new TypeError('unsupported trust argument')\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i]\n\n    if (!IP_RANGES.hasOwnProperty(val)) {\n      continue\n    }\n\n    // Splice in pre-defined range\n    val = IP_RANGES[val]\n    trust.splice.apply(trust, [i, 1].concat(val))\n    i += val.length - 1\n  }\n\n  return compileTrust(compileRangeSubnets(trust))\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @private\n */\n\nfunction compileRangeSubnets (arr) {\n  var rangeSubnets = new Array(arr.length)\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i])\n  }\n\n  return rangeSubnets\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @private\n */\n\nfunction compileTrust (rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length\n  return len === 0\n    ? trustNone\n    : len === 1\n      ? trustSingle(rangeSubnets[0])\n      : trustMulti(rangeSubnets)\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @private\n */\n\nfunction parseipNotation (note) {\n  var pos = note.lastIndexOf('/')\n  var str = pos !== -1\n    ? note.substring(0, pos)\n    : note\n\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str)\n  }\n\n  var ip = parseip(str)\n\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address()\n  }\n\n  var max = ip.kind() === 'ipv6'\n    ? 128\n    : 32\n\n  var range = pos !== -1\n    ? note.substring(pos + 1, note.length)\n    : null\n\n  if (range === null) {\n    range = max\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10)\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range)\n  } else {\n    range = null\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note)\n  }\n\n  return [ip, range]\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} netmask\n * @private\n */\n\nfunction parseNetmask (netmask) {\n  var ip = parseip(netmask)\n  var kind = ip.kind()\n\n  return kind === 'ipv4'\n    ? ip.prefixLengthFromSubnetMask()\n    : null\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @public\n */\n\nfunction proxyaddr (req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required')\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required')\n  }\n\n  var addrs = alladdrs(req, trust)\n  var addr = addrs[addrs.length - 1]\n\n  return addr\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @private\n */\n\nfunction trustNone () {\n  return false\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @private\n */\n\nfunction trustMulti (subnets) {\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var ipconv\n    var kind = ip.kind()\n\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i]\n      var subnetip = subnet[0]\n      var subnetkind = subnetip.kind()\n      var subnetrange = subnet[1]\n      var trusted = ip\n\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue\n        }\n\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4'\n            ? ip.toIPv4Address()\n            : ip.toIPv4MappedAddress()\n        }\n\n        trusted = ipconv\n      }\n\n      if (trusted.match(subnetip, subnetrange)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @private\n */\n\nfunction trustSingle (subnet) {\n  var subnetip = subnet[0]\n  var subnetkind = subnetip.kind()\n  var subnetisipv4 = subnetkind === 'ipv4'\n  var subnetrange = subnet[1]\n\n  return function trust (addr) {\n    if (!isip(addr)) return false\n\n    var ip = parseip(addr)\n    var kind = ip.kind()\n\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4\n        ? ip.toIPv4Address()\n        : ip.toIPv4MappedAddress()\n    }\n\n    return ip.match(subnetip, subnetrange)\n  }\n}\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseCollection = require('../../collection');\nconst Collection = require('mongodb').Collection;\nconst get = require('lodash.get');\nconst sliced = require('sliced');\nconst stream = require('stream');\nconst util = require('util');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) collection implementation.\n *\n * All methods methods from the [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver are copied and wrapped in queue management.\n *\n * @inherits Collection\n * @api private\n */\n\nfunction NativeCollection() {\n  this.collection = null;\n  MongooseCollection.apply(this, arguments);\n}\n\n/*!\n * Inherit from abstract Collection.\n */\n\nNativeCollection.prototype.__proto__ = MongooseCollection.prototype;\n\n/**\n * Called when the connection opens.\n *\n * @api private\n */\n\nNativeCollection.prototype.onOpen = function() {\n  const _this = this;\n\n  // always get a new collection in case the user changed host:port\n  // of parent db instance when re-opening the connection.\n\n  if (!_this.opts.capped.size) {\n    // non-capped\n    callback(null, _this.conn.db.collection(_this.name));\n    return _this.collection;\n  }\n\n  // capped\n  return _this.conn.db.collection(_this.name, function(err, c) {\n    if (err) return callback(err);\n\n    // discover if this collection exists and if it is capped\n    _this.conn.db.listCollections({name: _this.name}).toArray(function(err, docs) {\n      if (err) {\n        return callback(err);\n      }\n      const doc = docs[0];\n      const exists = !!doc;\n\n      if (exists) {\n        if (doc.options && doc.options.capped) {\n          callback(null, c);\n        } else {\n          const msg = 'A non-capped collection exists with the name: ' + _this.name + '\\n\\n'\n              + ' To use this collection as a capped collection, please '\n              + 'first convert it.\\n'\n              + ' http://www.mongodb.org/display/DOCS/Capped+Collections#CappedCollections-Convertingacollectiontocapped';\n          err = new Error(msg);\n          callback(err);\n        }\n      } else {\n        // create\n        const opts = Object.assign({}, _this.opts.capped);\n        opts.capped = true;\n        _this.conn.db.createCollection(_this.name, opts, callback);\n      }\n    });\n  });\n\n  function callback(err, collection) {\n    if (err) {\n      // likely a strict mode error\n      _this.conn.emit('error', err);\n    } else {\n      _this.collection = collection;\n      MongooseCollection.prototype.onOpen.call(_this);\n    }\n  }\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nNativeCollection.prototype.onClose = function(force) {\n  MongooseCollection.prototype.onClose.call(this, force);\n};\n\n/*!\n * ignore\n */\n\nconst syncCollectionMethods = { watch: true };\n\n/*!\n * Copy the collection methods and make them subject to queues\n */\n\nfunction iter(i) {\n  NativeCollection.prototype[i] = function() {\n    const collection = this.collection;\n    const args = arguments;\n    const _this = this;\n    const debug = _this.conn.base.options.debug;\n\n    // If user force closed, queueing will hang forever. See #5664\n    if (this.opts.$wasForceClosed) {\n      return this.conn.db.collection(this.name)[i].apply(collection, args);\n    }\n    if (this.buffer) {\n      if (syncCollectionMethods[i]) {\n        throw new Error('Collection method ' + i + ' is synchronous');\n      }\n      this.addQueue(i, arguments);\n      return;\n    }\n\n    if (debug) {\n      if (typeof debug === 'function') {\n        debug.apply(_this,\n          [_this.name, i].concat(sliced(args, 0, args.length - 1)));\n      } else if (debug instanceof stream.Writable) {\n        this.$printToStream(_this.name, i, args, debug);\n      } else {\n        this.$print(_this.name, i, args);\n      }\n    }\n\n    try {\n      return collection[i].apply(collection, args);\n    } catch (error) {\n      // Collection operation may throw because of max bson size, catch it here\n      // See gh-3906\n      if (args.length > 0 &&\n          typeof args[args.length - 1] === 'function') {\n        args[args.length - 1](error);\n      } else {\n        throw error;\n      }\n    }\n  };\n}\n\nfor (const i in Collection.prototype) {\n  // Janky hack to work around gh-3005 until we can get rid of the mongoose\n  // collection abstraction\n  try {\n    if (typeof Collection.prototype[i] !== 'function') {\n      continue;\n    }\n  } catch (e) {\n    continue;\n  }\n\n  iter(i);\n}\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$print = function(name, i, args) {\n  const moduleName = '\\x1B[0;36mMongoose:\\x1B[0m ';\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j]));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  console.info(moduleName + functionCall + params);\n};\n\n/**\n * Debug print helper\n *\n * @api public\n * @method $print\n */\n\nNativeCollection.prototype.$printToStream = function(name, i, args, stream) {\n  const functionCall = [name, i].join('.');\n  const _args = [];\n  for (let j = args.length - 1; j >= 0; --j) {\n    if (this.$format(args[j]) || _args.length) {\n      _args.unshift(this.$format(args[j]));\n    }\n  }\n  const params = '(' + _args.join(', ') + ')';\n\n  stream.write(functionCall + params, 'utf8');\n};\n\n/**\n * Formatter for debug print args\n *\n * @api public\n * @method $format\n */\n\nNativeCollection.prototype.$format = function(arg) {\n  const type = typeof arg;\n  if (type === 'function' || type === 'undefined') return '';\n  return format(arg);\n};\n\n/*!\n * Debug print helper\n */\n\nfunction inspectable(representation) {\n  const ret = {\n    inspect: function() { return representation; },\n  };\n  if (util.inspect.custom) {\n    ret[util.inspect.custom] = ret.inspect;\n  }\n  return ret;\n}\nfunction map(o) {\n  return format(o, true);\n}\nfunction formatObjectId(x, key) {\n  x[key] = inspectable('ObjectId(\"' + x[key].toHexString() + '\")');\n}\nfunction formatDate(x, key) {\n  x[key] = inspectable('new Date(\"' + x[key].toUTCString() + '\")');\n}\nfunction format(obj, sub) {\n  if (obj && typeof obj.toBSON === 'function') {\n    obj = obj.toBSON();\n  }\n  if (obj == null) {\n    return obj;\n  }\n\n  let x = require('../../utils').clone(obj, {transform: false});\n\n  if (x.constructor.name === 'Binary') {\n    x = 'BinData(' + x.sub_type + ', \"' + x.toString('base64') + '\")';\n  } else if (x.constructor.name === 'ObjectID') {\n    x = inspectable('ObjectId(\"' + x.toHexString() + '\")');\n  } else if (x.constructor.name === 'Date') {\n    x = inspectable('new Date(\"' + x.toUTCString() + '\")');\n  } else if (x.constructor.name === 'Object') {\n    const keys = Object.keys(x);\n    const numKeys = keys.length;\n    let key;\n    for (let i = 0; i < numKeys; ++i) {\n      key = keys[i];\n      if (x[key]) {\n        let error;\n        if (typeof x[key].toBSON === 'function') {\n          try {\n            // `session.toBSON()` throws an error. This means we throw errors\n            // in debug mode when using transactions, see gh-6712. As a\n            // workaround, catch `toBSON()` errors, try to serialize without\n            // `toBSON()`, and rethrow if serialization still fails.\n            x[key] = x[key].toBSON();\n          } catch (_error) {\n            error = _error;\n          }\n        }\n        if (x[key].constructor.name === 'Binary') {\n          x[key] = 'BinData(' + x[key].sub_type + ', \"' +\n            x[key].buffer.toString('base64') + '\")';\n        } else if (x[key].constructor.name === 'Object') {\n          x[key] = format(x[key], true);\n        } else if (x[key].constructor.name === 'ObjectID') {\n          formatObjectId(x, key);\n        } else if (x[key].constructor.name === 'Date') {\n          formatDate(x, key);\n        } else if (x[key].constructor.name === 'ClientSession') {\n          x[key] = inspectable('ClientSession(\"' +\n            get(x[key], 'id.id.buffer', '').toString('hex') + '\")');\n        } else if (Array.isArray(x[key])) {\n          x[key] = x[key].map(map);\n        } else if (error != null) {\n          // If there was an error with `toBSON()` and the object wasn't\n          // already converted to a string representation, rethrow it.\n          // Open to better ideas on how to handle this.\n          throw error;\n        }\n      }\n    }\n  }\n  if (sub) {\n    return x;\n  }\n\n  return util.\n    inspect(x, false, 10, true).\n    replace(/\\n/g, '').\n    replace(/\\s{2,}/g, ' ');\n}\n\n/**\n * Retrieves information about this collections indexes.\n *\n * @param {Function} callback\n * @method getIndexes\n * @api public\n */\n\nNativeCollection.prototype.getIndexes = NativeCollection.prototype.indexInformation;\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeCollection;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst STATES = require('./connectionstate');\nconst immediate = require('./helpers/immediate');\n\n/**\n * Abstract Collection constructor\n *\n * This is the base class that drivers inherit from and implement.\n *\n * @param {String} name name of the collection\n * @param {Connection} conn A MongooseConnection instance\n * @param {Object} opts optional collection options\n * @api public\n */\n\nfunction Collection(name, conn, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  if (opts.capped === void 0) {\n    opts.capped = {};\n  }\n\n  opts.bufferCommands = undefined === opts.bufferCommands\n    ? true\n    : opts.bufferCommands;\n\n  if (typeof opts.capped === 'number') {\n    opts.capped = {size: opts.capped};\n  }\n\n  this.opts = opts;\n  this.name = name;\n  this.collectionName = name;\n  this.conn = conn;\n  this.queue = [];\n  this.buffer = this.opts.bufferCommands;\n  this.emitter = new EventEmitter();\n\n  if (STATES.connected === this.conn.readyState) {\n    this.onOpen();\n  }\n}\n\n/**\n * The collection name\n *\n * @api public\n * @property name\n */\n\nCollection.prototype.name;\n\n/**\n * The collection name\n *\n * @api public\n * @property collectionName\n */\n\nCollection.prototype.collectionName;\n\n/**\n * The Connection instance\n *\n * @api public\n * @property conn\n */\n\nCollection.prototype.conn;\n\n/**\n * Called when the database connects\n *\n * @api private\n */\n\nCollection.prototype.onOpen = function() {\n  this.buffer = false;\n  immediate(() => this.doQueue());\n};\n\n/**\n * Called when the database disconnects\n *\n * @api private\n */\n\nCollection.prototype.onClose = function(force) {\n  if (this.opts.bufferCommands && !force) {\n    this.buffer = true;\n  }\n};\n\n/**\n * Queues a method for later execution when its\n * database connection opens.\n *\n * @param {String} name name of the method to queue\n * @param {Array} args arguments to pass to the method when executed\n * @api private\n */\n\nCollection.prototype.addQueue = function(name, args) {\n  this.queue.push([name, args]);\n  return this;\n};\n\n/**\n * Executes all queued methods and clears the queue.\n *\n * @api private\n */\n\nCollection.prototype.doQueue = function() {\n  for (let i = 0, l = this.queue.length; i < l; i++) {\n    if (typeof this.queue[i][0] === 'function') {\n      this.queue[i][0].apply(this, this.queue[i][1]);\n    } else {\n      this[this.queue[i][0]].apply(this, this.queue[i][1]);\n    }\n  }\n  this.queue = [];\n  const _this = this;\n  process.nextTick(function() {\n    _this.emitter.emit('queue');\n  });\n  return this;\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.ensureIndex = function() {\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.createIndex = function() {\n  throw new Error('Collection#ensureIndex unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findAndModify = function() {\n  throw new Error('Collection#findAndModify unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndUpdate = function() {\n  throw new Error('Collection#findOneAndUpdate unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOneAndDelete = function() {\n  throw new Error('Collection#findOneAndDelete unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.findOne = function() {\n  throw new Error('Collection#findOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.find = function() {\n  throw new Error('Collection#find unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insert = function() {\n  throw new Error('Collection#insert unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertOne = function() {\n  throw new Error('Collection#insertOne unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.insertMany = function() {\n  throw new Error('Collection#insertMany unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.save = function() {\n  throw new Error('Collection#save unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.update = function() {\n  throw new Error('Collection#update unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.getIndexes = function() {\n  throw new Error('Collection#getIndexes unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.mapReduce = function() {\n  throw new Error('Collection#mapReduce unimplemented by driver');\n};\n\n/**\n * Abstract method that drivers must implement.\n */\n\nCollection.prototype.watch = function() {\n  throw new Error('Collection#watch unimplemented by driver');\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Collection;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nvar Buffer = require('safe-buffer').Buffer;\nvar RegExpClone = require('regexp-clone');\n\n/**\n * Clones objects\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @return {Object} the cloned object\n * @api private\n */\n\nvar clone = exports.clone = function clone(obj, options) {\n  if (obj === undefined || obj === null)\n    return obj;\n\n  if (Array.isArray(obj))\n    return exports.cloneArray(obj, options);\n\n  if (obj.constructor) {\n    if (/ObjectI[dD]$/.test(obj.constructor.name)) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.id);\n    }\n\n    if (obj.constructor.name === 'ReadPreference') {\n      return new obj.constructor(obj.mode, clone(obj.tags, options));\n    }\n\n    if ('Binary' == obj._bsontype && obj.buffer && obj.value) {\n      return 'function' == typeof obj.clone\n        ? obj.clone()\n        : new obj.constructor(obj.value(true), obj.sub_type);\n    }\n\n    if ('Date' === obj.constructor.name || 'Function' === obj.constructor.name)\n      return new obj.constructor(+obj);\n\n    if ('RegExp' === obj.constructor.name)\n      return RegExpClone(obj);\n\n    if ('Buffer' === obj.constructor.name)\n      return exports.cloneBuffer(obj);\n  }\n\n  if (isObject(obj))\n    return exports.cloneObject(obj, options);\n\n  if (obj.valueOf)\n    return obj.valueOf();\n};\n\n/*!\n * ignore\n */\n\nexports.cloneObject = function cloneObject(obj, options) {\n  var minimize = options && options.minimize;\n  var ret = {};\n  var hasKeys;\n  var val;\n  var k;\n\n  for (k in obj) {\n    val = clone(obj[k], options);\n\n    if (!minimize || ('undefined' !== typeof val)) {\n      hasKeys || (hasKeys = true);\n      ret[k] = val;\n    }\n  }\n\n  return minimize\n    ? hasKeys && ret\n    : ret;\n};\n\nexports.cloneArray = function cloneArray(arr, options) {\n  var ret = [];\n  for (var i = 0, l = arr.length; i < l; i++)\n    ret.push(clone(arr[i], options));\n  return ret;\n};\n\n/**\n * process.nextTick helper.\n *\n * Wraps the given `callback` in a try/catch. If an error is\n * caught it will be thrown on nextTick.\n *\n * node-mongodb-native had a habit of state corruption when\n * an error was immediately thrown from within a collection\n * method (find, update, etc) callback.\n *\n * @param {Function} [callback]\n * @api private\n */\n\nexports.tick = function tick(callback) {\n  if ('function' !== typeof callback) return;\n  return function() {\n    // callbacks should always be fired on the next\n    // turn of the event loop. A side benefit is\n    // errors thrown from executing the callback\n    // will not cause drivers state to be corrupted\n    // which has historically been a problem.\n    var args = arguments;\n    soon(function() {\n      callback.apply(this, args);\n    });\n  };\n};\n\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.merge = function merge(to, from) {\n  var keys = Object.keys(from),\n      i = keys.length,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    if ('undefined' === typeof to[key]) {\n      to[key] = from[key];\n    } else {\n      if (exports.isObject(from[key])) {\n        merge(to[key], from[key]);\n      } else {\n        to[key] = from[key];\n      }\n    }\n  }\n};\n\n/**\n * Same as merge but clones the assigned values.\n *\n * @param {Object} to\n * @param {Object} from\n * @api private\n */\n\nexports.mergeClone = function mergeClone(to, from) {\n  var keys = Object.keys(from),\n      i = keys.length,\n      key;\n\n  while (i--) {\n    key = keys[i];\n    if ('undefined' === typeof to[key]) {\n      to[key] = clone(from[key]);\n    } else {\n      if (exports.isObject(from[key])) {\n        mergeClone(to[key], from[key]);\n      } else {\n        to[key] = clone(from[key]);\n      }\n    }\n  }\n};\n\n/**\n * Read pref helper (mongo 2.2 drivers support this)\n *\n * Allows using aliases instead of full preference names:\n *\n *     p   primary\n *     pp  primaryPreferred\n *     s   secondary\n *     sp  secondaryPreferred\n *     n   nearest\n *\n * @param {String} pref\n */\n\nexports.readPref = function readPref(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n\n\n/**\n * Read Concern helper (mongo 3.2 drivers support this)\n *\n * Allows using string to specify read concern level:\n *\n *     local          3.2+\n *     available      3.6+\n *     majority       3.2+\n *     linearizable   3.4+\n *     snapshot       4.0+\n *\n * @param {String|Object} concern\n */\n\nexports.readConcern = function readConcern(concern) {\n  if ('string' === typeof concern) {\n    switch (concern) {\n      case 'l':\n        concern = 'local';\n        break;\n      case 'a':\n        concern = 'available';\n        break;\n      case 'm':\n        concern = 'majority';\n        break;\n      case 'lz':\n        concern = 'linearizable';\n        break;\n      case 's':\n        concern = 'snapshot';\n        break;\n    }\n    concern = { level: concern };\n  }\n  return concern;\n};\n\n/**\n * Object.prototype.toString.call helper\n */\n\nvar _toString = Object.prototype.toString;\nexports.toString = function(arg) {\n  return _toString.call(arg);\n};\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @return {Boolean}\n */\n\nvar isObject = exports.isObject = function(arg) {\n  return '[object Object]' == exports.toString(arg);\n};\n\n/**\n * Determines if `arg` is an array.\n *\n * @param {Object}\n * @return {Boolean}\n * @see nodejs utils\n */\n\nexports.isArray = function(arg) {\n  return Array.isArray(arg) ||\n    'object' == typeof arg && '[object Array]' == exports.toString(arg);\n};\n\n/**\n * Object.keys helper\n */\n\nexports.keys = Object.keys || function(obj) {\n  var keys = [];\n  for (var k in obj) if (obj.hasOwnProperty(k)) {\n    keys.push(k);\n  }\n  return keys;\n};\n\n/**\n * Basic Object.create polyfill.\n * Only one argument is supported.\n *\n * Based on https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/create\n */\n\nexports.create = 'function' == typeof Object.create\n  ? Object.create\n  : create;\n\nfunction create(proto) {\n  if (arguments.length > 1) {\n    throw new Error('Adding properties is not supported');\n  }\n\n  function F() {}\n  F.prototype = proto;\n  return new F;\n}\n\n/**\n * inheritance\n */\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.prototype = exports.create(superCtor.prototype);\n  ctor.prototype.constructor = ctor;\n};\n\n/**\n * nextTick helper\n * compat with node 0.10 which behaves differently than previous versions\n */\n\nvar soon = exports.soon = 'function' == typeof setImmediate\n  ? setImmediate\n  : process.nextTick;\n\n/**\n * Clones the contents of a buffer.\n *\n * @param {Buffer} buff\n * @return {Buffer}\n */\n\nexports.cloneBuffer = function(buff) {\n  var dupe = Buffer.alloc(buff.length);\n  buff.copy(dupe, 0, 0, buff.length);\n  return dupe;\n};\n\n/**\n * Check if this object is an arguments object\n *\n * @param {Any} v\n * @return {Boolean}\n */\n\nexports.isArgumentsObject = function(v) {\n  return Object.prototype.toString.call(v) === '[object Arguments]';\n};\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  if (typeof val !== 'number' && typeof val !== 'string') {\n    throw new Error('$type parameter must be number or string');\n  }\n\n  return val;\n};\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('./');\n\n/**\n * Strict mode error constructor\n *\n * @param {String} type\n * @param {String} value\n * @inherits MongooseError\n * @api private\n */\n\nfunction ObjectExpectedError(path, val) {\n  MongooseError.call(this, 'Tried to set nested object field `' + path +\n    '` to primitive value `' + val + '` and strict mode is set to throw.');\n  this.name = 'ObjectExpectedError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.path = path;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nObjectExpectedError.prototype = Object.create(MongooseError.prototype);\nObjectExpectedError.prototype.constructor = MongooseError;\n\nmodule.exports = ObjectExpectedError;\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('./');\n\n/**\n * Constructor for errors that happen when a parameter that's expected to be\n * an object isn't an object\n *\n * @param {Any} value\n * @param {String} paramName\n * @param {String} fnName\n * @inherits MongooseError\n * @api private\n */\n\nfunction ObjectParameterError(value, paramName, fnName) {\n  MongooseError.call(this, 'Parameter \"' + paramName + '\" to ' + fnName +\n    '() must be an object, got ' + value.toString());\n  this.name = 'ObjectParameterError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nObjectParameterError.prototype = Object.create(MongooseError.prototype);\nObjectParameterError.prototype.constructor = MongooseError;\n\nmodule.exports = ObjectParameterError;\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function cleanModifiedSubpaths(doc, path, options) {\n  options = options || {};\n  const skipDocArrays = options.skipDocArrays;\n\n  let deleted = 0;\n  for (const modifiedPath of Object.keys(doc.$__.activePaths.states.modify)) {\n    if (skipDocArrays) {\n      const schemaType = doc.schema.path(modifiedPath);\n      if (schemaType && schemaType.$isMongooseDocumentArray) {\n        continue;\n      }\n    }\n    if (modifiedPath.indexOf(path + '.') === 0) {\n      delete doc.$__.activePaths.states.modify[modifiedPath];\n      ++deleted;\n    }\n  }\n  return deleted;\n};\n","'use strict';\n\n/* eslint-env browser */\n\n/*!\n * Module dependencies.\n */\nconst Document = require('./document.js');\nconst BrowserDocument = require('./browserDocument.js');\n\nlet isBrowser = false;\n\n/**\n * Returns the Document constructor for the current context\n *\n * @api private\n */\nmodule.exports = function() {\n  if (isBrowser) {\n    return BrowserDocument;\n  }\n  return Document;\n};\n\n/*!\n * ignore\n */\nmodule.exports.setBrowser = function(flag) {\n  isBrowser = flag;\n};\n","'use strict';\n\nconst handleTimestampOption = require('../schema/handleTimestampOption');\n\nmodule.exports = applyTimestampsToChildren;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToChildren(now, update, schema) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  let key;\n  let len;\n  let createdAt;\n  let updatedAt;\n  let timestamps;\n  let path;\n\n  const hasDollarKey = keys.length && keys[0].charAt(0) === '$';\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      for (key in update.$push) {\n        const $path = schema.path(key);\n        if (update.$push[key] &&\n            $path &&\n            $path.$isMongooseDocumentArray &&\n            $path.schema.options.timestamps) {\n          timestamps = $path.schema.options.timestamps;\n          createdAt = handleTimestampOption(timestamps, 'createdAt');\n          updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n          if (update.$push[key].$each) {\n            update.$push[key].$each.forEach(function(subdoc) {\n              if (updatedAt != null) {\n                subdoc[updatedAt] = now;\n              }\n              if (createdAt != null) {\n                subdoc[createdAt] = now;\n              }\n            });\n          } else {\n            if (updatedAt != null) {\n              update.$push[key][updatedAt] = now;\n            }\n            if (createdAt != null) {\n              update.$push[key][createdAt] = now;\n            }\n          }\n        }\n      }\n    }\n    if (update.$set != null) {\n      const keys = Object.keys(update.$set);\n      for (key of keys) {\n        // Replace positional operator `$` and array filters `$[]` and `$[.*]`\n        const keyToSearch = key.\n          replace(/\\.\\$(\\[[^\\]]*\\])?\\./g, '.0.').\n          replace(/\\.(\\[[^\\]]*\\])?\\$$/, '.0');\n        path = schema.path(keyToSearch);\n        if (!path) {\n          continue;\n        }\n        if (Array.isArray(update.$set[key]) && path.$isMongooseDocumentArray) {\n          len = update.$set[key].length;\n          timestamps = path.schema.options.timestamps;\n          if (timestamps) {\n            createdAt = handleTimestampOption(timestamps, 'createdAt');\n            updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n            for (let i = 0; i < len; ++i) {\n              if (updatedAt != null) {\n                update.$set[key][i][updatedAt] = now;\n              }\n              if (createdAt != null) {\n                update.$set[key][i][createdAt] = now;\n              }\n            }\n          }\n        } else if (update.$set[key] && path.$isSingleNested) {\n          timestamps = path.schema.options.timestamps;\n          if (timestamps) {\n            createdAt = handleTimestampOption(timestamps, 'createdAt');\n            updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n            if (updatedAt != null) {\n              update.$set[key][updatedAt] = now;\n            }\n            if (createdAt != null) {\n              update.$set[key][createdAt] = now;\n            }\n          }\n        } else if (path.$parentSchema !== schema && path.$parentSchema != null) {\n          const parentPath = path.$parentSchema.$schemaType;\n\n          if (parentPath == null) {\n            continue;\n          }\n\n          timestamps = parentPath.schema.options.timestamps;\n          createdAt = handleTimestampOption(timestamps, 'createdAt');\n          updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n          if (updatedAt == null) {\n            continue;\n          }\n\n          if (parentPath.$isSingleNested) {\n            // Single nested is easy\n            update.$set[parentPath.path + '.' + updatedAt] = now;\n            continue;\n          }\n\n          let childPath = key.substr(parentPath.path.length + 1);\n          const firstDot = childPath.indexOf('.');\n\n          // Shouldn't happen, but if it does ignore this path\n          if (firstDot === -1) {\n            continue;\n          }\n\n          childPath = childPath.substr(0, firstDot);\n\n          update.$set[parentPath.path + '.' + childPath + '.' + updatedAt] = now;\n        } else if (path.schema != null && path.schema != schema) {\n          timestamps = path.schema.options.timestamps;\n          createdAt = handleTimestampOption(timestamps, 'createdAt');\n          updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n          if (updatedAt != null) {\n            update.$set[key][updatedAt] = now;\n          }\n          if (createdAt != null) {\n            update.$set[key][createdAt] = now;\n          }\n        }\n      }\n    }\n  }\n}","'use strict';\n\nmodule.exports = handleTimestampOption;\n\n/*!\n * ignore\n */\n\nfunction handleTimestampOption(arg, prop) {\n  if (arg == null) {\n    return null;\n  }\n\n  if (typeof arg === 'boolean') {\n    return prop;\n  }\n  if (typeof arg[prop] === 'boolean') {\n    return arg[prop] ? prop : null;\n  }\n  if (!(prop in arg)) {\n    return prop;\n  }\n  return arg[prop];\n}","'use strict';\n\n/*!\n * ignore\n */\n\nconst get = require('lodash.get');\n\nmodule.exports = applyTimestampsToUpdate;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options) {\n  const updates = currentUpdate;\n  let _updates = updates;\n  const overwrite = get(options, 'overwrite', false);\n  const timestamps = get(options, 'timestamps', true);\n\n  // Support skipping timestamps at the query level, see gh-6980\n  if (!timestamps || updates == null) {\n    return currentUpdate;\n  }\n\n  if (overwrite) {\n    if (currentUpdate && currentUpdate.$set) {\n      currentUpdate = currentUpdate.$set;\n      updates.$set = {};\n      _updates = updates.$set;\n    }\n    if (updatedAt && !currentUpdate[updatedAt]) {\n      _updates[updatedAt] = now;\n    }\n    if (createdAt && !currentUpdate[createdAt]) {\n      _updates[createdAt] = now;\n    }\n    return updates;\n  }\n  updates.$set = updates.$set || {};\n  currentUpdate = currentUpdate || {};\n\n  if (updatedAt &&\n      (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {\n    updates.$set[updatedAt] = now;\n  }\n\n  if (createdAt) {\n    if (currentUpdate[createdAt]) {\n      delete currentUpdate[createdAt];\n    }\n    if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n      delete currentUpdate.$set[createdAt];\n    }\n\n    updates.$setOnInsert = updates.$setOnInsert || {};\n    updates.$setOnInsert[createdAt] = now;\n  }\n\n  if (Object.keys(updates.$set).length === 0) {\n    delete updates.$set;\n  }\n\n  return updates;\n}\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = applyQueryMiddleware;\n\n/*!\n * ignore\n */\n\napplyQueryMiddleware.middlewareFunctions = [\n  'count',\n  'countDocuments',\n  'estimatedDocumentCount',\n  'find',\n  'findOne',\n  'findOneAndDelete',\n  'findOneAndRemove',\n  'findOneAndUpdate',\n  'remove',\n  'replaceOne',\n  'update',\n  'updateMany',\n  'updateOne'\n];\n\n/*!\n * Apply query middleware\n *\n * @param {Query} query constructor\n * @param {Model} model\n */\n\nfunction applyQueryMiddleware(Query, model) {\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true\n  };\n\n  const middleware = model.hooks.filter(hook => {\n    if (hook.name !== 'remove') {\n      return true;\n    }\n    return !!hook.query;\n  });\n\n  // `update()` thunk has a different name because `_update` was already taken\n  Query.prototype._execUpdate = middleware.createWrapper('update',\n    Query.prototype._execUpdate, null, kareemOptions);\n\n  applyQueryMiddleware.middlewareFunctions.\n    filter(v => v !== 'update').\n    forEach(fn => {\n      Query.prototype[`_${fn}`] = middleware.createWrapper(fn,\n        Query.prototype[`_${fn}`], null, kareemOptions);\n    });\n}\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst MongooseError = require('../error');\nconst castString = require('../cast/string');\nconst utils = require('../utils');\n\nlet Document;\n\n/**\n * String SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaString(key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaString.schemaName = 'String';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaString.prototype = Object.create(SchemaType.prototype);\nSchemaString.prototype.constructor = SchemaString;\n\n/**\n * Adds an enum validator\n *\n * ####Example:\n *\n *     var states = ['opening', 'open', 'closing', 'closed']\n *     var s = new Schema({ state: { type: String, enum: states }})\n *     var M = db.model('M', s)\n *     var m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: `invalid` is not a valid enum value for path `state`.\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n *     // or with custom error messages\n *     var enum = {\n *       values: ['opening', 'open', 'closing', 'closed'],\n *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n *     }\n *     var s = new Schema({ state: { type: String, enum: enum })\n *     var M = db.model('M', s)\n *     var m = new M({ state: 'invalid' })\n *     m.save(function (err) {\n *       console.error(String(err)) // ValidationError: enum validator failed for path `state` with value `invalid`\n *       m.state = 'open'\n *       m.save(callback) // success\n *     })\n *\n * @param {String|Object} [args...] enumeration values\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaString.prototype.enum = function() {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (arguments[0] === void 0 || arguments[0] === false) {\n    return this;\n  }\n\n  let values;\n  let errorMessage;\n\n  if (utils.isObject(arguments[0])) {\n    values = arguments[0].values;\n    errorMessage = arguments[0].message;\n  } else {\n    values = arguments;\n    errorMessage = MongooseError.messages.String.enum;\n  }\n\n  for (let i = 0; i < values.length; i++) {\n    if (undefined !== values[i]) {\n      this.enumValues.push(this.cast(values[i]));\n    }\n  }\n\n  const vals = this.enumValues;\n  this.enumValidator = function(v) {\n    return undefined === v || ~vals.indexOf(v);\n  };\n  this.validators.push({\n    validator: this.enumValidator,\n    message: errorMessage,\n    type: 'enum',\n    enumValues: vals\n  });\n\n  return this;\n};\n\n/**\n * Adds a lowercase [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set).\n *\n * ####Example:\n *\n *     var s = new Schema({ email: { type: String, lowercase: true }})\n *     var M = db.model('M', s);\n *     var m = new M({ email: 'SomeEmail@example.COM' });\n *     console.log(m.email) // someemail@example.com\n *     M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.lowercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(function(v, self) {\n    if (typeof v !== 'string') {\n      v = self.cast(v);\n    }\n    if (v) {\n      return v.toLowerCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds an uppercase [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set).\n *\n * ####Example:\n *\n *     var s = new Schema({ caps: { type: String, uppercase: true }})\n *     var M = db.model('M', s);\n *     var m = new M({ caps: 'an example' });\n *     console.log(m.caps) // AN EXAMPLE\n *     M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.uppercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(function(v, self) {\n    if (typeof v !== 'string') {\n      v = self.cast(v);\n    }\n    if (v) {\n      return v.toUpperCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds a trim [setter](http://mongoosejs.com/docs/api.html#schematype_SchemaType-set).\n *\n * The string value will be trimmed when set.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, trim: true }})\n *     var M = db.model('M', s)\n *     var string = ' some name '\n *     console.log(string.length) // 11\n *     var m = new M({ name: string })\n *     console.log(m.name.length) // 9\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.trim = function(shouldTrim) {\n  if (arguments.length > 0 && !shouldTrim) {\n    return this;\n  }\n  return this.set(function(v, self) {\n    if (typeof v !== 'string') {\n      v = self.cast(v);\n    }\n    if (v) {\n      return v.trim();\n    }\n    return v;\n  });\n};\n\n/**\n * Sets a minimum length validator.\n *\n * ####Example:\n *\n *     var schema = new Schema({ postalCode: { type: String, minlength: 5 })\n *     var Address = db.model('Address', schema)\n *     var address = new Address({ postalCode: '9512' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length\n *     var minlength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];\n *     var schema = new Schema({ postalCode: { type: String, minlength: minlength })\n *     var Address = mongoose.model('Address', schema);\n *     var address = new Address({ postalCode: '9512' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n *     })\n *\n * @param {Number} value minimum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaString.prototype.minlength = function(value, message) {\n  if (this.minlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.minlength;\n    msg = msg.replace(/{MINLENGTH}/, value);\n    this.validators.push({\n      validator: this.minlengthValidator = function(v) {\n        return v === null || v.length >= value;\n      },\n      message: msg,\n      type: 'minlength',\n      minlength: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum length validator.\n *\n * ####Example:\n *\n *     var schema = new Schema({ postalCode: { type: String, maxlength: 9 })\n *     var Address = db.model('Address', schema)\n *     var address = new Address({ postalCode: '9512512345' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length\n *     var maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n *     var schema = new Schema({ postalCode: { type: String, maxlength: maxlength })\n *     var Address = mongoose.model('Address', schema);\n *     var address = new Address({ postalCode: '9512512345' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).\n *     })\n *\n * @param {Number} value maximum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaString.prototype.maxlength = function(value, message) {\n  if (this.maxlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.maxlength;\n    msg = msg.replace(/{MAXLENGTH}/, value);\n    this.validators.push({\n      validator: this.maxlengthValidator = function(v) {\n        return v === null || v.length <= value;\n      },\n      message: msg,\n      type: 'maxlength',\n      maxlength: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a regexp validator.\n *\n * Any value that does not pass `regExp`.test(val) will fail validation.\n *\n * ####Example:\n *\n *     var s = new Schema({ name: { type: String, match: /^a/ }})\n *     var M = db.model('M', s)\n *     var m = new M({ name: 'I am invalid' })\n *     m.validate(function (err) {\n *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n *       m.name = 'apples'\n *       m.validate(function (err) {\n *         assert.ok(err) // success\n *       })\n *     })\n *\n *     // using a custom error message\n *     var match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\n *     var s = new Schema({ file: { type: String, match: match }})\n *     var M = db.model('M', s);\n *     var m = new M({ file: 'invalid' });\n *     m.validate(function (err) {\n *       console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n *     })\n *\n * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n *\n *     var s = new Schema({ name: { type: String, match: /^a/, required: true }})\n *\n * @param {RegExp} regExp regular expression to test against\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaString.prototype.match = function match(regExp, message) {\n  // yes, we allow multiple match validators\n\n  const msg = message || MongooseError.messages.String.match;\n\n  const matchValidator = function(v) {\n    if (!regExp) {\n      return false;\n    }\n\n    const ret = ((v != null && v !== '')\n      ? regExp.test(v)\n      : true);\n    return ret;\n  };\n\n  this.validators.push({\n    validator: matchValidator,\n    message: msg,\n    type: 'regexp',\n    regexp: regExp\n  });\n  return this;\n};\n\n/**\n * Check if the given value satisfies the `required` validator. The value is\n * considered valid if it is a string (that is, not `null` or `undefined`) and\n * has positive length. The `required` validator **will** fail for empty\n * strings.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaString.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return (value instanceof String || typeof value === 'string') && value.length;\n};\n\n/**\n * Casts to String\n *\n * @api private\n */\n\nSchemaString.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (typeof value === 'string') {\n      return value;\n    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n      throw new CastError('string', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    const path = doc.$__fullPath(this.path);\n    const owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    const pop = owner.populated(path, true);\n    const ret = new pop.options.model(value);\n    ret.$__.wasPopulated = true;\n    return ret;\n  }\n\n  return castString(value, this.path);\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.castForQuery(val);\n}\n\nfunction handleArray(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(val)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(m);\n  });\n}\n\nSchemaString.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $all: handleArray,\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle,\n      $options: handleSingle,\n      $regex: handleSingle,\n      $not: handleSingle\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nSchemaString.prototype.castForQuery = function($conditional, val) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with String.');\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (Object.prototype.toString.call(val) === '[object RegExp]') {\n    return val;\n  }\n\n  return this._castForQuery(val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaString;\n","'use strict';\n\nconst CastError = require('../error/cast');\n\n/*!\n * Given a value, cast it to a string, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {string|null|undefined}\n * @throws {CastError}\n * @api private\n */\n\nmodule.exports = function castString(value, path) {\n  // If null or undefined\n  if (value == null) {\n    return value;\n  }\n\n  // handle documents being passed\n  if (value._id && typeof value._id === 'string') {\n    return value._id;\n  }\n\n  // Re: gh-647 and gh-3030, we're ok with casting using `toString()`\n  // **unless** its the default Object.toString, because \"[object Object]\"\n  // doesn't really qualify as useful data\n  if (value.toString && value.toString !== Object.prototype.toString) {\n    return value.toString();\n  }\n\n  throw new CastError('string', value, path);\n};\n","'use strict';\n\nconst CastError = require('../error/cast');\n\n/*!\n * Given a value, cast it to a number, or throw a `CastError` if the value\n * cannot be casted. `null` and `undefined` are considered valid.\n *\n * @param {Any} value\n * @param {String} [path] optional the path to set on the CastError\n * @return {Boolean|null|undefined}\n * @throws {CastError} if `value` is not one of the allowed values\n * @api private\n */\n\nmodule.exports = function castNumber(val, path) {\n  if (isNaN(val)) {\n    throw new CastError('number', val, path);\n  }\n\n  if (val == null) {\n    return val;\n  }\n  if (val === '') {\n    return null;\n  }\n\n  if (typeof val === 'string' || typeof val === 'boolean') {\n    val = Number(val);\n  }\n\n  if (isNaN(val)) {\n    throw new CastError('number', val, path);\n  }\n  if (val instanceof Number) {\n    return val;\n  }\n  if (typeof val === 'number') {\n    return val;\n  }\n  if (!Array.isArray(val) && typeof val.valueOf === 'function') {\n    return Number(val.valueOf());\n  }\n  if (val.toString && !Array.isArray(val) && val.toString() == Number(val)) {\n    return new Number(val);\n  }\n\n  throw new CastError('number', val, path);\n};\n","/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst CastError = require('../../error/cast');\n\n/*!\n * ignore\n */\n\nfunction handleBitwiseOperator(val) {\n  const _this = this;\n  if (Array.isArray(val)) {\n    return val.map(function(v) {\n      return _castNumber(_this.path, v);\n    });\n  } else if (Buffer.isBuffer(val)) {\n    return val;\n  }\n  // Assume trying to cast to number\n  return _castNumber(_this.path, val);\n}\n\n/*!\n * ignore\n */\n\nfunction _castNumber(path, num) {\n  const v = Number(num);\n  if (isNaN(v)) {\n    throw new CastError('number', num, path);\n  }\n  return v;\n}\n\nmodule.exports = handleBitwiseOperator;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst SchemaType = require('../schematype');\nconst castBoolean = require('../cast/boolean');\nconst utils = require('../utils');\n\n/**\n * Boolean SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBoolean(path, options) {\n  SchemaType.call(this, path, options, 'Boolean');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBoolean.schemaName = 'Boolean';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBoolean.prototype = Object.create(SchemaType.prototype);\nSchemaBoolean.prototype.constructor = SchemaBoolean;\n\n/**\n * Check if the given value satisfies a required validator. For a boolean\n * to satisfy a required validator, it must be strictly equal to true or to\n * false.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBoolean.prototype.checkRequired = function(value) {\n  return value === true || value === false;\n};\n\n/**\n * Configure which values get casted to `true`.\n *\n * ####Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'affirmative' }).b; // undefined\n *     mongoose.Schema.Boolean.convertToTrue.add('affirmative');\n *     new M({ b: 'affirmative' }).b; // true\n *\n * @property convertToTrue\n * @type Set\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToTrue', {\n  get: () => castBoolean.convertToTrue,\n  set: v => { castBoolean.convertToTrue = v; }\n});\n\n/**\n * Configure which values get casted to `false`.\n *\n * ####Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'nay' }).b; // undefined\n *     mongoose.Schema.Types.Boolean.convertToFalse.add('nay');\n *     new M({ b: 'nay' }).b; // false\n *\n * @property convertToFalse\n * @type Set\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToFalse', {\n  get: () => castBoolean.convertToFalse,\n  set: v => { castBoolean.convertToFalse = v; }\n});\n\n/**\n * Casts to boolean\n *\n * @param {Object} value\n * @param {Object} model - this value is optional\n * @api private\n */\n\nSchemaBoolean.prototype.cast = function(value) {\n  return castBoolean(value, this.path);\n};\n\nSchemaBoolean.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBoolean.prototype.castForQuery = function($conditional, val) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = SchemaBoolean.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this._castForQuery(val);\n  }\n\n  return this._castForQuery($conditional);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBoolean;\n","/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst MongooseError = require('../error');\nconst utils = require('../utils');\n\nconst SchemaType = require('../schematype');\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [guille](https://github.com/guille/) allowing us to use a friendlier syntax:\n *\n * ####Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     var schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (!this._index || this._index.constructor.name !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value) {\n  return value instanceof Date;\n};\n\n/**\n * Sets a minimum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     var min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     var schema = new Schema({ d: { type: Date, min: min })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        const min = (value === Date.now ? value() : _this.cast(value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * ####Example:\n *\n *     var s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     var M = db.model('M', s)\n *     var m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     var max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     var schema = new Schema({ d: { type: Date, max: max })\n *     var M = mongoose.model('M', schema);\n *     var s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages #error_messages_MongooseError-messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : this.cast(value).toString()));\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        const max = (value === Date.now ? value() : _this.cast(value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  // If null or undefined\n  if (value === null || value === void 0 || value === '') {\n    return null;\n  }\n\n  if (value instanceof Date) {\n    if (isNaN(value.valueOf())) {\n      throw new CastError('date', value, this.path);\n    }\n\n    return value;\n  }\n\n  let date;\n\n  if (typeof value === 'boolean') {\n    throw new CastError('date', value, this.path);\n  }\n\n  if (value instanceof Number || typeof value === 'number') {\n    date = new Date(value);\n  } else if (typeof value === 'string' && !isNaN(Number(value)) && (Number(value) >= 275761 || Number(value) < -271820)) {\n    // string representation of milliseconds take this path\n    date = new Date(Number(value));\n  } else if (typeof value.valueOf === 'function') {\n    // support for moment.js. This is also the path strings will take because\n    // strings have a `valueOf()`\n    date = new Date(value.valueOf());\n  } else {\n    // fallback\n    date = new Date(value);\n  }\n\n  if (!isNaN(date.valueOf())) {\n    return date;\n  }\n\n  throw new CastError('date', value, this.path);\n};\n\n/*!\n * Date Query casting.\n *\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nSchemaDate.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val) {\n  if (arguments.length !== 2) {\n    return this._castForQuery($conditional);\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst handleBitwiseOperator = require('./operators/bitwise');\nconst utils = require('../utils');\n\nconst MongooseBuffer = require('../types/buffer');\nconst SchemaType = require('../schematype');\n\nconst Binary = MongooseBuffer.Binary;\nconst CastError = SchemaType.CastError;\nlet Document;\n\n/**\n * Buffer SchemaType constructor\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBuffer(key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBuffer.schemaName = 'Buffer';\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBuffer.prototype = Object.create(SchemaType.prototype);\nSchemaBuffer.prototype.constructor = SchemaBuffer;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy a\n * required validator, a buffer must not be null or undefined and have\n * non-zero length.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaBuffer.prototype.checkRequired = function(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return !!(value && value.length);\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaBuffer.prototype.cast = function(value, doc, init) {\n  let ret;\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (Buffer.isBuffer(value)) {\n      return value;\n    } else if (!utils.isObject(value)) {\n      throw new CastError('buffer', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    const path = doc.$__fullPath(this.path);\n    const owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    const pop = owner.populated(path, true);\n    ret = new pop.options.model(value);\n    ret.$__.wasPopulated = true;\n    return ret;\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (value && value.isMongooseBuffer) {\n    return value;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isMongooseBuffer) {\n      value = new MongooseBuffer(value, [this.path, doc]);\n      if (this.options.subtype != null) {\n        value._subtype = this.options.subtype;\n      }\n    }\n    return value;\n  }\n\n  if (value instanceof Binary) {\n    ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n    if (typeof value.sub_type !== 'number') {\n      throw new CastError('buffer', value, this.path);\n    }\n    ret._subtype = value.sub_type;\n    return ret;\n  }\n\n  if (value === null) {\n    return value;\n  }\n\n\n  const type = typeof value;\n  if (\n    type === 'string' || type === 'number' || Array.isArray(value) ||\n    (type === 'object' && value.type === 'Buffer' && Array.isArray(value.data)) // gh-6863\n  ) {\n    if (type === 'number') {\n      value = [value];\n    }\n    ret = new MongooseBuffer(value, [this.path, doc]);\n    if (this.options.subtype != null) {\n      ret._subtype = this.options.subtype;\n    }\n    return ret;\n  }\n\n  throw new CastError('buffer', value, this.path);\n};\n\n/**\n * Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/)\n * for this buffer. You can find a [list of allowed subtypes here](http://api.mongodb.com/python/current/api/bson/binary.html).\n *\n * ####Example:\n *\n *     var s = new Schema({ uuid: { type: Buffer, subtype: 4 });\n *     var M = db.model('M', s);\n *     var m = new M({ uuid: 'test string' });\n *     m.uuid._subtype; // 4\n *\n * @param {Number} subtype the default subtype\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaBuffer.prototype.subtype = function(subtype) {\n  this.options.subtype = subtype;\n  return this;\n};\n\n/*!\n * ignore\n */\nfunction handleSingle(val) {\n  return this.castForQuery(val);\n}\n\nSchemaBuffer.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $bitsAllClear: handleBitwiseOperator,\n      $bitsAnyClear: handleBitwiseOperator,\n      $bitsAllSet: handleBitwiseOperator,\n      $bitsAnySet: handleBitwiseOperator,\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaBuffer.prototype.castForQuery = function($conditional, val) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Buffer.');\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  const casted = this._castForQuery(val);\n  return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBuffer;\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst Binary = require('../driver').get().Binary;\nconst utils = require('../utils');\nconst Buffer = require('safe-buffer').Buffer;\n\n// Yes this is weird. See https://github.com/feross/safe-buffer/pull/23\nconst proto = Buffer.from('').constructor.prototype;\n\n/**\n * Mongoose Buffer constructor.\n *\n * Values always have to be passed to the constructor to initialize.\n *\n * @param {Buffer} value\n * @param {String} encode\n * @param {Number} offset\n * @api private\n * @inherits Buffer\n * @see http://bit.ly/f6CnZU\n */\n\nfunction MongooseBuffer(value, encode, offset) {\n  const length = arguments.length;\n  let val;\n\n  if (length === 0 || arguments[0] === null || arguments[0] === undefined) {\n    val = 0;\n  } else {\n    val = value;\n  }\n\n  let encoding;\n  let path;\n  let doc;\n\n  if (Array.isArray(encode)) {\n    // internal casting\n    path = encode[0];\n    doc = encode[1];\n  } else {\n    encoding = encode;\n  }\n\n  let buf;\n  if (typeof val === 'number' || val instanceof Number) {\n    buf = Buffer.alloc(val);\n  } else { // string, array or object { type: 'Buffer', data: [...] }\n    buf = Buffer.from(val, encoding, offset);\n  }\n  utils.decorate(buf, MongooseBuffer.mixin);\n  buf.isMongooseBuffer = true;\n\n  // make sure these internal props don't show up in Object.keys()\n  Object.defineProperties(buf, {\n    validators: {\n      value: [],\n      enumerable: false\n    },\n    _path: {\n      value: path,\n      enumerable: false\n    },\n    _parent: {\n      value: doc,\n      enumerable: false\n    }\n  });\n\n  if (doc && typeof path === 'string') {\n    Object.defineProperty(buf, '_schema', {\n      value: doc.schema.path(path)\n    });\n  }\n\n  buf._subtype = 0;\n  return buf;\n}\n\n/*!\n * Inherit from Buffer.\n */\n\n// MongooseBuffer.prototype = Buffer.alloc(0);\n\nMongooseBuffer.mixin = {\n\n  /**\n   * Parent owner document\n   *\n   * @api private\n   * @property _parent\n   * @receiver MongooseBuffer\n   */\n\n  _parent: undefined,\n\n  /**\n   * Default subtype for the Binary representing this Buffer\n   *\n   * @api private\n   * @property _subtype\n   * @receiver MongooseBuffer\n   */\n\n  _subtype: undefined,\n\n  /**\n   * Marks this buffer as modified.\n   *\n   * @api private\n   * @method _markModified\n   * @receiver MongooseBuffer\n   */\n\n  _markModified: function() {\n    const parent = this._parent;\n\n    if (parent) {\n      parent.markModified(this._path);\n    }\n    return this;\n  },\n\n  /**\n   * Writes the buffer.\n   *\n   * @api public\n   * @method write\n   * @receiver MongooseBuffer\n   */\n\n  write: function() {\n    const written = proto.write.apply(this, arguments);\n\n    if (written > 0) {\n      this._markModified();\n    }\n\n    return written;\n  },\n\n  /**\n   * Copies the buffer.\n   *\n   * ####Note:\n   *\n   * `Buffer#copy` does not mark `target` as modified so you must copy from a `MongooseBuffer` for it to work as expected. This is a work around since `copy` modifies the target, not this.\n   *\n   * @return {Number} The number of bytes copied.\n   * @param {Buffer} target\n   * @method copy\n   * @receiver MongooseBuffer\n   */\n\n  copy: function(target) {\n    const ret = proto.copy.apply(this, arguments);\n\n    if (target && target.isMongooseBuffer) {\n      target._markModified();\n    }\n\n    return ret;\n  }\n};\n\n/*!\n * Compile other Buffer methods marking this buffer as modified.\n */\n\n(\n// node < 0.5\n  ('writeUInt8 writeUInt16 writeUInt32 writeInt8 writeInt16 writeInt32 ' +\n    'writeFloat writeDouble fill ' +\n    'utf8Write binaryWrite asciiWrite set ' +\n\n  // node >= 0.5\n    'writeUInt16LE writeUInt16BE writeUInt32LE writeUInt32BE ' +\n    'writeInt16LE writeInt16BE writeInt32LE writeInt32BE ' + 'writeFloatLE writeFloatBE writeDoubleLE writeDoubleBE')\n).split(' ').forEach(function(method) {\n  if (!proto[method]) {\n    return;\n  }\n  MongooseBuffer.mixin[method] = function() {\n    const ret = proto[method].apply(this, arguments);\n    this._markModified();\n    return ret;\n  };\n});\n\n/**\n * Converts this buffer to its Binary type representation.\n *\n * ####SubTypes:\n *\n *   var bson = require('bson')\n *   bson.BSON_BINARY_SUBTYPE_DEFAULT\n *   bson.BSON_BINARY_SUBTYPE_FUNCTION\n *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *   bson.BSON_BINARY_SUBTYPE_UUID\n *   bson.BSON_BINARY_SUBTYPE_MD5\n *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *   doc.buffer.toObject(bson.BSON_BINARY_SUBTYPE_USER_DEFINED);\n *\n * @see http://bsonspec.org/#/specification\n * @param {Hex} [subtype]\n * @return {Binary}\n * @api public\n * @method toObject\n * @receiver MongooseBuffer\n */\n\nMongooseBuffer.mixin.toObject = function(options) {\n  const subtype = typeof options === 'number'\n    ? options\n    : (this._subtype || 0);\n  return new Binary(this, subtype);\n};\n\n/**\n * Converts this buffer for storage in MongoDB, including subtype\n *\n * @return {Binary}\n * @api public\n * @method toBSON\n * @receiver MongooseBuffer\n */\n\nMongooseBuffer.mixin.toBSON = function() {\n  return new Binary(this, this._subtype || 0);\n};\n\n/**\n * Determines if this buffer is equals to `other` buffer\n *\n * @param {Buffer} other\n * @return {Boolean}\n * @method equals\n * @receiver MongooseBuffer\n */\n\nMongooseBuffer.mixin.equals = function(other) {\n  if (!Buffer.isBuffer(other)) {\n    return false;\n  }\n\n  if (this.length !== other.length) {\n    return false;\n  }\n\n  for (let i = 0; i < this.length; ++i) {\n    if (this[i] !== other[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * Sets the subtype option and marks the buffer modified.\n *\n * ####SubTypes:\n *\n *   var bson = require('bson')\n *   bson.BSON_BINARY_SUBTYPE_DEFAULT\n *   bson.BSON_BINARY_SUBTYPE_FUNCTION\n *   bson.BSON_BINARY_SUBTYPE_BYTE_ARRAY\n *   bson.BSON_BINARY_SUBTYPE_UUID\n *   bson.BSON_BINARY_SUBTYPE_MD5\n *   bson.BSON_BINARY_SUBTYPE_USER_DEFINED\n *\n *   doc.buffer.subtype(bson.BSON_BINARY_SUBTYPE_UUID);\n *\n * @see http://bsonspec.org/#/specification\n * @param {Hex} subtype\n * @api public\n * @method subtype\n * @receiver MongooseBuffer\n */\n\nMongooseBuffer.mixin.subtype = function(subtype) {\n  if (typeof subtype !== 'number') {\n    throw new TypeError('Invalid subtype. Expected a number');\n  }\n\n  if (this._subtype !== subtype) {\n    this._markModified();\n  }\n\n  this._subtype = subtype;\n};\n\n/*!\n * Module exports.\n */\n\nMongooseBuffer.Binary = Binary;\n\nmodule.exports = MongooseBuffer;\n","'use strict';\n\n/*!\n * ignore\n */\n\nconst MongooseMap = require('../types/map');\nconst SchemaType = require('../schematype');\n\n/*!\n * ignore\n */\n\nclass SchemaMap extends SchemaType {\n  constructor(key, options) {\n    super(key, options, 'Map');\n    this.$isSchemaMap = true;\n  }\n\n  cast(val, doc) {\n    if (val instanceof MongooseMap) {\n      return val;\n    }\n\n    return new MongooseMap(val, this.path, doc, this.$__schemaType);\n  }\n}\n\nmodule.exports = SchemaMap;\n","/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst castArraysOfNumbers = require('./helpers').castArraysOfNumbers;\nconst castToNumber = require('./helpers').castToNumber;\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  const SchemaArray = require('../array');\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(self, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    const type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(arr => {\n      if (!Array.isArray(arr)) {\n        const msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach((v, i) => {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    const type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach((item, i) => {\n      if (Array.isArray(item)) {\n        item.forEach((v, j) => {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  const geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n","'use strict';\n\nconst Document = require('../document');\nconst immediate = require('../helpers/immediate');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst utils = require('../utils');\n\nmodule.exports = Subdocument;\n\n/**\n * Subdocument constructor.\n *\n * @inherits Document\n * @api private\n */\n\nfunction Subdocument(value, fields, parent, skipId, options) {\n  this.$isSingleNested = true;\n  if (parent != null) {\n    // If setting a nested path, should copy isNew from parent re: gh-7048\n    options = Object.assign({}, options, { isNew: parent.isNew });\n  }\n  Document.call(this, value, fields, skipId, options);\n\n  delete this.$__.$options.priorDoc;\n}\n\nSubdocument.prototype = Object.create(Document.prototype);\n\nSubdocument.prototype.toBSON = function() {\n  return this.toObject(internalToObjectOptions);\n};\n\n/**\n * Used as a stub for middleware\n *\n * ####NOTE:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @return {Promise} resolved Promise\n * @api private\n */\n\nSubdocument.prototype.save = function(options, fn) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = {};\n  }\n  options = options || {};\n\n  if (!options.suppressWarning) {\n    console.warn('mongoose: calling `save()` on a subdoc does **not** save ' +\n      'the document to MongoDB, it only runs save middleware. ' +\n      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +\n      'if you\\'re sure this behavior is right for your app.');\n  }\n\n  return utils.promiseOrCallback(fn, cb => {\n    this.$__save(cb);\n  });\n};\n\n/**\n * Used as a stub for middleware\n *\n * ####NOTE:\n *\n * _This is a no-op. Does not actually save the doc to the db._\n *\n * @param {Function} [fn]\n * @method $__save\n * @api private\n */\n\nSubdocument.prototype.$__save = function(fn) {\n  return immediate(() => fn(null, this));\n};\n\nSubdocument.prototype.$isValid = function(path) {\n  if (this.$parent && this.$basePath) {\n    return this.$parent.$isValid([this.$basePath, path].join('.'));\n  }\n  return Document.prototype.$isValid.call(this, path);\n};\n\nSubdocument.prototype.markModified = function(path) {\n  Document.prototype.markModified.call(this, path);\n\n  if (this.$parent && this.$basePath) {\n    if (this.$parent.isDirectModified(this.$basePath)) {\n      return;\n    }\n    this.$parent.markModified([this.$basePath, path].join('.'), this);\n  }\n};\n\nSubdocument.prototype.$markValid = function(path) {\n  Document.prototype.$markValid.call(this, path);\n  if (this.$parent && this.$basePath) {\n    this.$parent.$markValid([this.$basePath, path].join('.'));\n  }\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.invalidate = function(path, err, val) {\n  // Hack: array subdocuments' validationError is equal to the owner doc's,\n  // so validating an array subdoc gives the top-level doc back. Temporary\n  // workaround for #5208 so we don't have circular errors.\n  if (err !== this.ownerDocument().$__.validationError) {\n    Document.prototype.invalidate.call(this, path, err, val);\n  }\n\n  if (this.$parent && this.$basePath) {\n    this.$parent.invalidate([this.$basePath, path].join('.'), err, val);\n  } else if (err.kind === 'cast' || err.name === 'CastError') {\n    throw err;\n  }\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.$ignore = function(path) {\n  Document.prototype.$ignore.call(this, path);\n  if (this.$parent && this.$basePath) {\n    this.$parent.$ignore([this.$basePath, path].join('.'));\n  }\n};\n\n/**\n * Returns the top level document of this sub-document.\n *\n * @return {Document}\n */\n\nSubdocument.prototype.ownerDocument = function() {\n  if (this.$__.ownerDocument) {\n    return this.$__.ownerDocument;\n  }\n\n  let parent = this.$parent;\n  if (!parent) {\n    return this;\n  }\n\n  while (parent.$parent || parent.__parent) {\n    parent = parent.$parent || parent.__parent;\n  }\n\n  this.$__.ownerDocument = parent;\n  return this.$__.ownerDocument;\n};\n\n/**\n * Returns this sub-documents parent document.\n *\n * @api public\n */\n\nSubdocument.prototype.parent = function() {\n  return this.$parent;\n};\n\n/*!\n * no-op for hooks\n */\n\nSubdocument.prototype.$__remove = function(cb) {\n  return cb(null, this);\n};\n\n/**\n * Null-out this subdoc\n *\n * @param {Object} [options]\n * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove\n */\n\nSubdocument.prototype.remove = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  registerRemoveListener(this);\n\n  // If removing entire doc, no need to remove subdoc\n  if (!options || !options.noop) {\n    this.$parent.set(this.$basePath, null);\n  }\n\n  if (typeof callback === 'function') {\n    callback(null);\n  }\n};\n\n/*!\n * ignore\n */\n\nSubdocument.prototype.populate = function() {\n  throw new Error('Mongoose does not support calling populate() on nested ' +\n    'docs. Instead of `doc.nested.populate(\"path\")`, use ' +\n    '`doc.populate(\"nested.path\")`');\n};\n\n/*!\n * Registers remove event listeners for triggering\n * on subdocuments.\n *\n * @param {EmbeddedDocument} sub\n * @api private\n */\n\nfunction registerRemoveListener(sub) {\n  let owner = sub.ownerDocument();\n\n  function emitRemove() {\n    owner.removeListener('save', emitRemove);\n    owner.removeListener('remove', emitRemove);\n    sub.emit('remove', sub);\n    sub.constructor.emit('remove', sub);\n    owner = sub = null;\n  }\n\n  owner.on('save', emitRemove);\n  owner.on('remove', emitRemove);\n}\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst async = require('async');\nconst utils = require('../../utils');\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = function eachAsync(next, fn, options, callback) {\n  const parallel = options.parallel || 1;\n\n  const handleNextResult = function(doc, callback) {\n    const promise = fn(doc);\n    if (promise && typeof promise.then === 'function') {\n      promise.then(\n        function() { callback(null); },\n        function(error) { callback(error || new Error('`eachAsync()` promise rejected without error')); });\n    } else {\n      callback(null);\n    }\n  };\n\n  const iterate = function(callback) {\n    let drained = false;\n    const nextQueue = async.queue(function(task, cb) {\n      if (drained) return cb();\n      next(function(err, doc) {\n        if (err) return cb(err);\n        if (!doc) drained = true;\n        cb(null, doc);\n      });\n    }, 1);\n\n    const getAndRun = function(cb) {\n      nextQueue.push({}, function(err, doc) {\n        if (err) return cb(err);\n        if (!doc) return cb();\n        handleNextResult(doc, function(err) {\n          if (err) return cb(err);\n          // Make sure to clear the stack re: gh-4697\n          setTimeout(function() {\n            getAndRun(cb);\n          }, 0);\n        });\n      });\n    };\n\n    async.times(parallel, function(n, cb) {\n      getAndRun(cb);\n    }, callback);\n  };\n\n  return utils.promiseOrCallback(callback, cb => {\n    iterate(cb);\n  });\n};\n","'use strict';\n\nconst CastError = require('../../error/cast');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst utils = require('../../utils');\n\n/*!\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} options\n * @param {Boolean} [options.overwrite] defaults to false\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n */\n\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (!obj) {\n    return undefined;\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let hasKeys;\n  let val;\n  let hasDollarKey = false;\n  const overwrite = options.overwrite;\n\n  filter = filter || {};\n\n  while (i--) {\n    const op = ops[i];\n    // if overwrite is set, don't do any of the special $set stuff\n    if (op[0] !== '$' && !overwrite) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n\n  // cast each value\n  i = ops.length;\n\n  // if we get passed {} for the update, we still need to respect that when it\n  // is an overwrite scenario\n  if (overwrite) {\n    hasKeys = true;\n  }\n\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.charAt(0) === '$';\n\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        (!overwrite || hasDollarKey)) {\n      hasKeys |= walkUpdatePath(schema, val, op, options, context, filter);\n    } else if (overwrite && ret && typeof ret === 'object') {\n      // if we are just using overwrite, cast the query and then we will\n      // *always* return the value, even if it is an empty object. We need to\n      // set hasKeys above because we need to account for the case where the\n      // user passes {} and wants to clobber the whole document\n      // Also, _walkUpdatePath expects an operation, so give it $set since that\n      // is basically what we're doing\n      walkUpdatePath(schema, ret, '$set', options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n  }\n\n  return hasKeys && ret;\n};\n\n/*!\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj - part of a query\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {Object} options\n * @param {Boolean|String} [options.strict]\n * @param {Boolean} [options.omitUndefined]\n * @param {Query} context\n * @param {String} pref - path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  let useNestedStrict;\n  if (options.useNestedStrict === undefined) {\n    useNestedStrict = schema.options.useNestedStrict;\n  } else {\n    useNestedStrict = options.useNestedStrict;\n  }\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (val && val.constructor.name === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _handleCastError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (!!val.$position || val.$position === 0) {\n            obj[key].$position = val.$position;\n          }\n        } else {\n          try {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } catch (error) {\n            aggregatedError = _handleCastError(error, context, key, aggregatedError);\n          }\n\n          if (options.omitUndefined && obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _handleCastError(error, context, key, aggregatedError);\n        }\n\n        if (options.omitUndefined && obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (useNestedStrict &&\n            v &&\n            v.schema &&\n            'strict' in v.schema.options) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (useNestedStrict &&\n          pathDetails &&\n          pathDetails.schema &&\n          'strict' in pathDetails.schema.options) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _handleCastError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype && schematype.caster && !schematype.caster.$isMongooseArray) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (options.omitUndefined && obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _handleCastError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/*!\n * These operators should be cast to numbers instead\n * of their path schema type.\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/*!\n * These ops require no casting because the RHS doesn't do anything.\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/*!\n * These operators require casting docs\n * to real Documents for Update operations.\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op - the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    return op in numberOps ?\n      castNumber(val, path) :\n      val;\n  }\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && op !== '$set') {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    const tmp = schema.cast(val);\n    if (Array.isArray(val)) {\n      val = tmp;\n    } else if (Array.isArray(tmp)) {\n      val = tmp[0];\n    } else {\n      val = tmp;\n    }\n    return val;\n  } else if (cond && op === '$set') {\n    return schema.cast(val);\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQueryWrapper({\n        val: val,\n        context: context\n      });\n    }\n    return castNumber(val, schema.path);\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {$type: val.$type};\n    }\n    return Boolean(val);\n  }\n\n  if (/^\\$/.test($conditional)) {\n    return schema.castForQueryWrapper({\n      $conditional: $conditional,\n      val: val,\n      context: context\n    });\n  }\n\n  if (overwriteOps[op]) {\n    return schema.castForQueryWrapper({\n      val: val,\n      context: context,\n      $skipQueryCastForUpdate: val != null && schema.$isMongooseArray && schema.$parentSchema\n    });\n  }\n\n  return schema.castForQueryWrapper({ val: val, context: context });\n}\n","'use strict';\n\n/*!\n * Module dependencies\n */\n\nconst AggregationCursor = require('./cursor/AggregationCursor');\nconst Query = require('./query');\nconst util = require('util');\nconst utils = require('./utils');\nconst read = Query.prototype.read;\nconst readConcern = Query.prototype.readConcern;\n\n/**\n * Aggregate constructor used for building aggregation pipelines. Do not\n * instantiate this class directly, use [Model.aggregate()](/docs/api.html#model_Model.aggregate) instead.\n *\n * ####Example:\n *\n *     const aggregate = Model.aggregate([\n *       { $project: { a: 1, b: 1 } },\n *       { $skip: 5 }\n *     ]);\n *\n *     Model.\n *       aggregate([{ $match: { age: { $gte: 21 }}}]).\n *       unwind('tags').\n *       exec(callback);\n *\n * ####Note:\n *\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Mongoose does **not** cast pipeline stages. The below will **not** work unless `_id` is a string in the database\n *\n * ```javascript\n *   new Aggregate([{ $match: { _id: '00000000000000000000000a' } }]);\n *   // Do this instead to cast to an ObjectId\n *   new Aggregate([{ $match: { _id: mongoose.Types.ObjectId('00000000000000000000000a') } }]);\n * ```\n *\n * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/\n * @see driver http://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @api public\n */\n\nfunction Aggregate(pipeline) {\n  this._pipeline = [];\n  this._model = undefined;\n  this.options = {};\n\n  if (arguments.length === 1 && util.isArray(pipeline)) {\n    this.append.apply(this, pipeline);\n  }\n}\n\n/**\n * Contains options passed down to the [aggregate command](https://docs.mongodb.com/manual/reference/command/aggregate/).\n * Supported options are:\n *\n * - `readPreference`\n * - [`cursor`](./api.html#aggregate_Aggregate-cursor)\n * - [`explain`](./api.html#aggregate_Aggregate-explain)\n * - [`allowDiskUse`](./api.html#aggregate_Aggregate-allowDiskUse)\n * - `maxTimeMS`\n * - `bypassDocumentValidation`\n * - `raw`\n * - `promoteLongs`\n * - `promoteValues`\n * - `promoteBuffers`\n * - [`collation`](./api.html#aggregate_Aggregate-collation)\n * - `comment`\n * - [`session`](./api.html#aggregate_Aggregate-session)\n *\n * @property options\n * @memberOf Aggregate\n * @api public\n */\n\nAggregate.prototype.options;\n\n/**\n * Binds this aggregate to a model.\n *\n * @param {Model} model the model to which the aggregate is to be bound\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.model = function(model) {\n  this._model = model;\n  if (model.schema != null) {\n    if (this.options.readPreference == null &&\n        model.schema.options.read != null) {\n      this.options.readPreference = model.schema.options.read;\n    }\n    if (this.options.collation == null &&\n        model.schema.options.collation != null) {\n      this.options.collation = model.schema.options.collation;\n    }\n  }\n  return this;\n};\n\n/**\n * Appends new operators to this aggregate pipeline\n *\n * ####Examples:\n *\n *     aggregate.append({ $project: { field: 1 }}, { $limit: 2 });\n *\n *     // or pass an array\n *     var pipeline = [{ $match: { daw: 'Logic Audio X' }} ];\n *     aggregate.append(pipeline);\n *\n * @param {Object} ops operator(s) to append\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.append = function() {\n  const args = (arguments.length === 1 && util.isArray(arguments[0]))\n    ? arguments[0]\n    : utils.args(arguments);\n\n  if (!args.every(isOperator)) {\n    throw new Error('Arguments must be aggregate pipeline operators');\n  }\n\n  this._pipeline = this._pipeline.concat(args);\n\n  return this;\n};\n\n/**\n * Appends a new $addFields operator to this aggregate pipeline.\n * Requires MongoDB v3.4+ to work\n *\n * ####Examples:\n  *\n *     // adding new fields based on existing fields\n *     aggregate.addFields({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.addFields({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object} arg field specification\n * @see $addFields https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/\n * @return {Aggregate}\n * @api public\n */\nAggregate.prototype.addFields = function(arg) {\n  const fields = {};\n  if (typeof arg === 'object' && !util.isArray(arg)) {\n    Object.keys(arg).forEach(function(field) {\n      fields[field] = arg[field];\n    });\n  } else {\n    throw new Error('Invalid addFields() argument. Must be an object');\n  }\n  return this.append({$addFields: fields});\n};\n\n/**\n * Appends a new $project operator to this aggregate pipeline.\n *\n * Mongoose query [selection syntax](#query_Query-select) is also supported.\n *\n * ####Examples:\n *\n *     // include a, include b, exclude _id\n *     aggregate.project(\"a b -_id\");\n *\n *     // or you may use object notation, useful when\n *     // you have keys already prefixed with a \"-\"\n *     aggregate.project({a: 1, b: 1, _id: 0});\n *\n *     // reshaping documents\n *     aggregate.project({\n *         newField: '$b.nested'\n *       , plusTen: { $add: ['$val', 10]}\n *       , sub: {\n *            name: '$a'\n *         }\n *     })\n *\n *     // etc\n *     aggregate.project({ salary_k: { $divide: [ \"$salary\", 1000 ] } });\n *\n * @param {Object|String} arg field specification\n * @see projection http://docs.mongodb.org/manual/reference/aggregation/project/\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.project = function(arg) {\n  const fields = {};\n\n  if (typeof arg === 'object' && !util.isArray(arg)) {\n    Object.keys(arg).forEach(function(field) {\n      fields[field] = arg[field];\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const include = field[0] === '-' ? 0 : 1;\n      if (include === 0) {\n        field = field.substring(1);\n      }\n      fields[field] = include;\n    });\n  } else {\n    throw new Error('Invalid project() argument. Must be string or object');\n  }\n\n  return this.append({$project: fields});\n};\n\n/**\n * Appends a new custom $group operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.group({ _id: \"$department\" });\n *\n * @see $group http://docs.mongodb.org/manual/reference/aggregation/group/\n * @method group\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $group operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new custom $match operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.match({ department: { $in: [ \"sales\", \"engineering\" ] } });\n *\n * @see $match http://docs.mongodb.org/manual/reference/aggregation/match/\n * @method match\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg $match operator contents\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $skip operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.skip(10);\n *\n * @see $skip http://docs.mongodb.org/manual/reference/aggregation/skip/\n * @method skip\n * @memberOf Aggregate\n * @instance\n * @param {Number} num number of records to skip before next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $limit operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.limit(10);\n *\n * @see $limit http://docs.mongodb.org/manual/reference/aggregation/limit/\n * @method limit\n * @memberOf Aggregate\n * @instance\n * @param {Number} num maximum number of records to pass to the next stage\n * @return {Aggregate}\n * @api public\n */\n\n/**\n * Appends a new $geoNear operator to this aggregate pipeline.\n *\n * ####NOTE:\n *\n * **MUST** be used as the first operator in the pipeline.\n *\n * ####Examples:\n *\n *     aggregate.near({\n *       near: [40.724, -73.997],\n *       distanceField: \"dist.calculated\", // required\n *       maxDistance: 0.008,\n *       query: { type: \"public\" },\n *       includeLocs: \"dist.location\",\n *       uniqueDocs: true,\n *       num: 5\n *     });\n *\n * @see $geoNear http://docs.mongodb.org/manual/reference/aggregation/geoNear/\n * @method near\n * @memberOf Aggregate\n * @instance\n * @param {Object} arg\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.near = function(arg) {\n  const op = {};\n  op.$geoNear = arg;\n  return this.append(op);\n};\n\n/*!\n * define methods\n */\n\n'group match skip limit out'.split(' ').forEach(function($operator) {\n  Aggregate.prototype[$operator] = function(arg) {\n    const op = {};\n    op['$' + $operator] = arg;\n    return this.append(op);\n  };\n});\n\n/**\n * Appends new custom $unwind operator(s) to this aggregate pipeline.\n *\n * Note that the `$unwind` operator requires the path name to start with '$'.\n * Mongoose will prepend '$' if the specified field doesn't start '$'.\n *\n * ####Examples:\n *\n *     aggregate.unwind(\"tags\");\n *     aggregate.unwind(\"a\", \"b\", \"c\");\n *\n * @see $unwind http://docs.mongodb.org/manual/reference/aggregation/unwind/\n * @param {String} fields the field(s) to unwind\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.unwind = function() {\n  const args = utils.args(arguments);\n\n  const res = [];\n  for (let i = 0; i < args.length; ++i) {\n    const arg = args[i];\n    if (arg && typeof arg === 'object') {\n      res.push({ $unwind: arg });\n    } else if (typeof arg === 'string') {\n      res.push({\n        $unwind: (arg && arg.charAt(0) === '$') ? arg : '$' + arg\n      });\n    } else {\n      throw new Error('Invalid arg \"' + arg + '\" to unwind(), ' +\n        'must be string or object');\n    }\n  }\n\n  return this.append.apply(this, res);\n};\n\n/**\n * Appends a new $replaceRoot operator to this aggregate pipeline.\n *\n * Note that the `$replaceRoot` operator requires field strings to start with '$'.\n * If you are passing in a string Mongoose will prepend '$' if the specified field doesn't start '$'.\n * If you are passing in an object the strings in your expression will not be altered.\n *\n * ####Examples:\n *\n *     aggregate.replaceRoot(\"user\");\n *\n *     aggregate.replaceRoot({ x: { $concat: ['$this', '$that'] } });\n *\n * @see $replaceRoot https://docs.mongodb.org/manual/reference/operator/aggregation/replaceRoot\n * @param {String|Object} the field or document which will become the new root document\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.replaceRoot = function(newRoot) {\n  let ret;\n\n  if (typeof newRoot === 'string') {\n    ret = newRoot.startsWith('$') ? newRoot : '$' + newRoot;\n  } else {\n    ret = newRoot;\n  }\n\n  return this.append({\n    $replaceRoot: {\n      newRoot: ret\n    }\n  });\n};\n\n/**\n * Appends a new $count operator to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.count(\"userCount\");\n *\n * @see $count https://docs.mongodb.org/manual/reference/operator/aggregation/count\n * @param {String} the name of the count field\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.count = function(countName) {\n  return this.append({ $count: countName });\n};\n\n/**\n * Appends a new $sortByCount operator to this aggregate pipeline. Accepts either a string field name\n * or a pipeline object.\n *\n * Note that the `$sortByCount` operator requires the new root to start with '$'.\n * Mongoose will prepend '$' if the specified field name doesn't start with '$'.\n *\n * ####Examples:\n *\n *     aggregate.sortByCount('users');\n *     aggregate.sortByCount({ $mergeObjects: [ \"$employee\", \"$business\" ] })\n *\n * @see $sortByCount https://docs.mongodb.com/manual/reference/operator/aggregation/sortByCount/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sortByCount = function(arg) {\n  if (arg && typeof arg === 'object') {\n    return this.append({ $sortByCount: arg });\n  } else if (typeof arg === 'string') {\n    return this.append({\n      $sortByCount: (arg && arg.charAt(0) === '$') ? arg : '$' + arg\n    });\n  } else {\n    throw new TypeError('Invalid arg \"' + arg + '\" to sortByCount(), ' +\n      'must be string or object');\n  }\n};\n\n/**\n * Appends new custom $lookup operator(s) to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.lookup({ from: 'users', localField: 'userId', foreignField: '_id', as: 'users' });\n *\n * @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup\n * @param {Object} options to $lookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.lookup = function(options) {\n  return this.append({$lookup: options});\n};\n\n/**\n * Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.\n *\n * Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is specified.\n *\n * #### Examples:\n *      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: 'Calculus', prerequisite: 'Trigonometry'}` and `{ _id: 0, name: 'Trigonometry', prerequisite: 'Algebra' }`\n *      aggregate.graphLookup({ from: 'courses', startWith: '$prerequisite', connectFromField: 'prerequisite', connectToField: 'name', as: 'prerequisites', maxDepth: 3 }) // this will recursively search the 'courses' collection up to 3 prerequisites\n *\n * @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup\n * @param {Object} options to $graphLookup as described in the above link\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.graphLookup = function(options) {\n  const cloneOptions = {};\n  if (options) {\n    if (!utils.isObject(options)) {\n      throw new TypeError('Invalid graphLookup() argument. Must be an object.');\n    }\n\n    utils.mergeClone(cloneOptions, options);\n    const startWith = cloneOptions.startWith;\n\n    if (startWith && typeof startWith === 'string') {\n      cloneOptions.startWith = cloneOptions.startWith.charAt(0) === '$' ?\n        cloneOptions.startWith :\n        '$' + cloneOptions.startWith;\n    }\n\n  }\n  return this.append({ $graphLookup: cloneOptions });\n};\n\n/**\n * Appends new custom $sample operator(s) to this aggregate pipeline.\n *\n * ####Examples:\n *\n *     aggregate.sample(3); // Add a pipeline that picks 3 random documents\n *\n * @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample\n * @param {Number} size number of random documents to pick\n * @return {Aggregate}\n * @api public\n */\n\nAggregate.prototype.sample = function(size) {\n  return this.append({$sample: {size: size}});\n};\n\n/**\n * Appends a new $sort operator to this aggregate pipeline.\n *\n * If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\n *\n * If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\n *\n * ####Examples:\n *\n *     // these are equivalent\n *     aggregate.sort({ field: 'asc', test: -1 });\n *     aggregate.sort('field -test');\n *\n * @see $sort http://docs.mongodb.org/manual/reference/aggregation/sort/\n * @param {Object|String} arg\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.sort = function(arg) {\n  // TODO refactor to reuse the query builder logic\n\n  const sort = {};\n\n  if (arg.constructor.name === 'Object') {\n    const desc = ['desc', 'descending', -1];\n    Object.keys(arg).forEach(function(field) {\n      // If sorting by text score, skip coercing into 1/-1\n      if (arg[field] instanceof Object && arg[field].$meta) {\n        sort[field] = arg[field];\n        return;\n      }\n      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;\n    });\n  } else if (arguments.length === 1 && typeof arg === 'string') {\n    arg.split(/\\s+/).forEach(function(field) {\n      if (!field) {\n        return;\n      }\n      const ascend = field[0] === '-' ? -1 : 1;\n      if (ascend === -1) {\n        field = field.substring(1);\n      }\n      sort[field] = ascend;\n    });\n  } else {\n    throw new TypeError('Invalid sort() argument. Must be a string or object.');\n  }\n\n  return this.append({$sort: sort});\n};\n\n/**\n * Sets the readPreference option for the aggregation query.\n *\n * ####Example:\n *\n *     Model.aggregate(..).read('primaryPreferred').exec(callback)\n *\n * @param {String} pref one of the listed preference options or their aliases\n * @param {Array} [tags] optional tags for this query\n * @return {Aggregate} this\n * @api public\n * @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference\n * @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences\n */\n\nAggregate.prototype.read = function(pref, tags) {\n  if (!this.options) {\n    this.options = {};\n  }\n  read.call(this, pref, tags);\n  return this;\n};\n\n/**\n * Sets the readConcern level for the aggregation query.\n *\n * ####Example:\n *\n *     Model.aggregate(..).readConcern('majority').exec(callback)\n *\n * @param {String} level one of the listed read concern level or their aliases\n * @see mongodb https://docs.mongodb.com/manual/reference/read-concern/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.readConcern = function(level) {\n  if (!this.options) {\n    this.options = {};\n  }\n  readConcern.call(this, level);\n  return this;\n};\n\n/**\n * Appends a new $redact operator to this aggregate pipeline.\n *\n * If 3 arguments are supplied, Mongoose will wrap them with if-then-else of $cond operator respectively\n * If `thenExpr` or `elseExpr` is string, make sure it starts with $$, like `$$DESCEND`, `$$PRUNE` or `$$KEEP`.\n *\n * ####Example:\n *\n *     Model.aggregate(...)\n *      .redact({\n *        $cond: {\n *          if: { $eq: [ '$level', 5 ] },\n *          then: '$$PRUNE',\n *          else: '$$DESCEND'\n *        }\n *      })\n *      .exec();\n *\n *     // $redact often comes with $cond operator, you can also use the following syntax provided by mongoose\n *     Model.aggregate(...)\n *      .redact({ $eq: [ '$level', 5 ] }, '$$PRUNE', '$$DESCEND')\n *      .exec();\n *\n * @param {Object} expression redact options or conditional expression\n * @param {String|Object} [thenExpr] true case for the condition\n * @param {String|Object} [elseExpr] false case for the condition\n * @return {Aggregate} this\n * @see $redact https://docs.mongodb.com/manual/reference/operator/aggregation/redact/\n * @api public\n */\n\nAggregate.prototype.redact = function(expression, thenExpr, elseExpr) {\n  if (arguments.length === 3) {\n    if ((typeof thenExpr === 'string' && !thenExpr.startsWith('$$')) ||\n        (typeof elseExpr === 'string' && !elseExpr.startsWith('$$'))) {\n      throw new Error('If thenExpr or elseExpr is string, it must start with $$. e.g. $$DESCEND, $$PRUNE, $$KEEP');\n    }\n\n    expression = {\n      $cond: {\n        if: expression,\n        then: thenExpr,\n        else: elseExpr\n      }\n    };\n  } else if (arguments.length !== 1) {\n    throw new TypeError('Invalid arguments');\n  }\n\n  return this.append({$redact: expression});\n};\n\n/**\n * Execute the aggregation with explain\n *\n * ####Example:\n *\n *     Model.aggregate(..).explain(callback)\n *\n * @param {Function} callback\n * @return {Promise}\n */\n\nAggregate.prototype.explain = function(callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    if (!this._pipeline.length) {\n      const err = new Error('Aggregate has empty pipeline');\n      return cb(err);\n    }\n\n    prepareDiscriminatorPipeline(this);\n\n    this._model.collection.\n      aggregate(this._pipeline, this.options || {}).\n      explain(function(error, result) {\n        if (error) {\n          return cb(error);\n        }\n        cb(null, result);\n      });\n  });\n};\n\n/**\n * Sets the allowDiskUse option for the aggregation query (ignored for < 2.6.0)\n *\n * ####Example:\n *\n *     await Model.aggregate([{ $match: { foo: 'bar' } }]).allowDiskUse(true);\n *\n * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.\n * @param {Array} [tags] optional tags for this query\n * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.allowDiskUse = function(value) {\n  this.options.allowDiskUse = value;\n  return this;\n};\n\n/**\n * Sets the hint option for the aggregation query (ignored for < 3.6.0)\n *\n * ####Example:\n *\n *     Model.aggregate(..).hint({ qty: 1, category: 1 } }).exec(callback)\n *\n * @param {Object|String} value a hint object or the index name\n * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.hint = function(value) {\n  this.options.hint = value;\n  return this;\n};\n\n/**\n * Sets the session for this aggregation. Useful for [transactions](/docs/transactions.html).\n *\n * ####Example:\n *\n *     const session = await Model.startSession();\n *     await Model.aggregate(..).session(session);\n *\n * @param {ClientSession} session\n * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/\n */\n\nAggregate.prototype.session = function(session) {\n  if (session == null) {\n    delete this.options.session;\n  } else {\n    this.options.session = session;\n  }\n  return this;\n};\n\n/**\n * Lets you set arbitrary options, for middleware or plugins.\n *\n * ####Example:\n *\n *     var agg = Model.aggregate(..).option({ allowDiskUse: true }); // Set the `allowDiskUse` option\n *     agg.options; // `{ allowDiskUse: true }`\n *\n * @param {Object} options keys to merge into current options\n * @param [options.maxTimeMS] number limits the time this aggregation will run, see [MongoDB docs on `maxTimeMS`](https://docs.mongodb.com/manual/reference/operator/meta/maxTimeMS/)\n * @param [options.allowDiskUse] boolean if true, the MongoDB server will use the hard drive to store data during this aggregation\n * @param [options.collation] object see [`Aggregate.prototype.collation()`](./docs/api.html#aggregate_Aggregate-collation)\n * @param [options.session] ClientSession see [`Aggregate.prototype.session()`](./docs/api.html#aggregate_Aggregate-session)\n * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/\n * @return {Aggregate} this\n * @api public\n */\n\nAggregate.prototype.option = function(value) {\n  for (const key in value) {\n    this.options[key] = value[key];\n  }\n  return this;\n};\n\n/**\n * Sets the cursor option option for the aggregation query (ignored for < 2.6.0).\n * Note the different syntax below: .exec() returns a cursor object, and no callback\n * is necessary.\n *\n * ####Example:\n *\n *     var cursor = Model.aggregate(..).cursor({ batchSize: 1000 }).exec();\n *     cursor.each(function(error, doc) {\n *       // use doc\n *     });\n *\n * @param {Object} options\n * @param {Number} options.batchSize set the cursor batch size\n * @param {Boolean} [options.useMongooseAggCursor] use experimental mongoose-specific aggregation cursor (for `eachAsync()` and other query cursor semantics)\n * @return {Aggregate} this\n * @api public\n * @see mongodb http://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html\n */\n\nAggregate.prototype.cursor = function(options) {\n  if (!this.options) {\n    this.options = {};\n  }\n  this.options.cursor = options || {};\n  return this;\n};\n\n/**\n * Sets an option on this aggregation. This function will be deprecated in a\n * future release. Use the [`cursor()`](./api.html#aggregate_Aggregate-cursor),\n * [`collation()`](./api.html#aggregate_Aggregate-collation), etc. helpers to\n * set individual options, or access `agg.options` directly.\n *\n * Note that MongoDB aggregations [do **not** support the `noCursorTimeout` flag](https://jira.mongodb.org/browse/SERVER-6036),\n * if you try setting that flag with this function you will get a \"unrecognized field 'noCursorTimeout'\" error.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {Aggregate} this\n * @api public\n * @see mongodb http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag\n */\n\nAggregate.prototype.addCursorFlag = function(flag, value) {\n  if (!this.options) {\n    this.options = {};\n  }\n  this.options[flag] = value;\n  return this;\n};\n\n/**\n * Adds a collation\n *\n * ####Example:\n *\n *     Model.aggregate(..).collation({ locale: 'en_US', strength: 1 }).exec();\n *\n * @param {Object} collation options\n * @return {Aggregate} this\n * @api public\n * @see mongodb http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#aggregate\n */\n\nAggregate.prototype.collation = function(collation) {\n  if (!this.options) {\n    this.options = {};\n  }\n  this.options.collation = collation;\n  return this;\n};\n\n/**\n * Combines multiple aggregation pipelines.\n *\n * ####Example:\n *\n *     Model.aggregate(...)\n *      .facet({\n *        books: [{ groupBy: '$author' }],\n *        price: [{ $bucketAuto: { groupBy: '$price', buckets: 2 } }]\n *      })\n *      .exec();\n *\n *     // Output: { books: [...], price: [{...}, {...}] }\n *\n * @param {Object} facet options\n * @return {Aggregate} this\n * @see $facet https://docs.mongodb.com/v3.4/reference/operator/aggregation/facet/\n * @api public\n */\n\nAggregate.prototype.facet = function(options) {\n  return this.append({$facet: options});\n};\n\n/**\n * Returns the current pipeline\n *\n * ####Example:\n *\n *     MyModel.aggregate().match({ test: 1 }).pipeline(); // [{ $match: { test: 1 } }]\n *\n * @return {Array}\n * @api public\n */\n\n\nAggregate.prototype.pipeline = function() {\n  return this._pipeline;\n};\n\n/**\n * Executes the aggregate pipeline on the currently bound Model.\n *\n * ####Example:\n *\n *     aggregate.exec(callback);\n *\n *     // Because a promise is returned, the `callback` is optional.\n *     var promise = aggregate.exec();\n *     promise.then(..);\n *\n * @see Promise #promise_Promise\n * @param {Function} [callback]\n * @return {Promise}\n * @api public\n */\n\nAggregate.prototype.exec = function(callback) {\n  if (!this._model) {\n    throw new Error('Aggregate not bound to any Model');\n  }\n  const model = this._model;\n  const options = utils.clone(this.options || {});\n  const pipeline = this._pipeline;\n  const collection = this._model.collection;\n\n  if (options && options.cursor) {\n    return new AggregationCursor(this);\n  }\n\n  return utils.promiseOrCallback(callback, cb => {\n    if (!pipeline.length) {\n      const err = new Error('Aggregate has empty pipeline');\n      return cb(err);\n    }\n\n    prepareDiscriminatorPipeline(this);\n\n    model.hooks.execPre('aggregate', this, error => {\n      if (error) {\n        const _opts = { error: error };\n        return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n          cb(error);\n        });\n      }\n\n      collection.aggregate(pipeline, options, (error, cursor) => {\n        if (error) {\n          const _opts = { error: error };\n          return model.hooks.execPost('aggregate', this, [null], _opts, error => {\n            if (error) {\n              return cb(error);\n            }\n            return cb(null);\n          });\n        }\n        cursor.toArray((error, result) => {\n          const _opts = { error: error };\n          model.hooks.execPost('aggregate', this, [result], _opts, (error, result) => {\n            if (error) {\n              return cb(error);\n            }\n\n            cb(null, result);\n          });\n        });\n      });\n    });\n  });\n};\n\n/**\n * Provides promise for aggregate.\n *\n * ####Example:\n *\n *     Model.aggregate(..).then(successCallback, errorCallback);\n *\n * @see Promise #promise_Promise\n * @param {Function} [resolve] successCallback\n * @param {Function} [reject]  errorCallback\n * @return {Promise}\n */\nAggregate.prototype.then = function(resolve, reject) {\n  return this.exec().then(resolve, reject);\n};\n\n/**\n * Returns an asyncIterator for use with [`for/await/of` loops](http://bit.ly/async-iterators)\n * This function *only* works for `find()` queries.\n * You do not need to call this function explicitly, the JavaScript runtime\n * will call it for you.\n *\n * ####Example\n *\n *     for await (const doc of Model.find().sort({ name: 1 })) {\n *       console.log(doc.name);\n *     }\n *\n * Node.js 10.x supports async iterators natively without any flags. You can\n * enable async iterators in Node.js 8.x using the [`--harmony_async_iteration` flag](https://github.com/tc39/proposal-async-iteration/issues/117#issuecomment-346695187).\n *\n * **Note:** This function is not if `Symbol.asyncIterator` is undefined. If\n * `Symbol.asyncIterator` is undefined, that means your Node.js version does not\n * support async iterators.\n *\n * @method Symbol.asyncIterator\n * @memberOf Aggregate\n * @instance\n * @api public\n */\n\nif (Symbol.asyncIterator != null) {\n  Aggregate.prototype[Symbol.asyncIterator] = function() {\n    return this.cursor({ useMongooseAggCursor: true }).\n      exec().\n      transformNull().\n      map(doc => {\n        return doc == null ? { done: true } : { value: doc, done: false };\n      });\n  };\n}\n\n/*!\n * Helpers\n */\n\n/**\n * Checks whether an object is likely a pipeline operator\n *\n * @param {Object} obj object to check\n * @return {Boolean}\n * @api private\n */\n\nfunction isOperator(obj) {\n  if (typeof obj !== 'object') {\n    return false;\n  }\n\n  const k = Object.keys(obj);\n\n  return k.length === 1 && k.some(key => { return key[0] === '$'; });\n}\n\n/*!\n * Adds the appropriate `$match` pipeline step to the top of an aggregate's\n * pipeline, should it's model is a non-root discriminator type. This is\n * analogous to the `prepareDiscriminatorCriteria` function in `lib/query.js`.\n *\n * @param {Aggregate} aggregate Aggregate to prepare\n */\n\nAggregate._prepareDiscriminatorPipeline = prepareDiscriminatorPipeline;\n\nfunction prepareDiscriminatorPipeline(aggregate) {\n  const schema = aggregate._model.schema;\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = aggregate._pipeline;\n    const discriminatorKey = discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] && originalPipeline[0].$match && !originalPipeline[0].$match[discriminatorKey]) {\n      originalPipeline[0].$match[discriminatorKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[discriminatorKey] = discriminatorValue;\n    } else {\n      const match = {};\n      match[discriminatorKey] = discriminatorValue;\n      aggregate._pipeline.unshift({ $match: match });\n    }\n  }\n}\n\n/*!\n * Exports\n */\n\nmodule.exports = Aggregate;\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = new WeakMap();","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\nconst Schema = require('./schema');\nconst Collection = require('./driver').get().Collection;\nconst STATES = require('./connectionstate');\nconst MongooseError = require('./error');\nconst PromiseProvider = require('./promise_provider');\nconst get = require('lodash.get');\nconst mongodb = require('mongodb');\nconst utils = require('./utils');\n\nconst parseConnectionString = require('mongodb-core').parseConnectionString;\n\n/*!\n * A list of authentication mechanisms that don't require a password for authentication.\n * This is used by the authMechanismDoesNotRequirePassword method.\n *\n * @api private\n */\nconst noPasswordAuthMechanisms = [\n  'MONGODB-X509'\n];\n\n/**\n * Connection constructor\n *\n * For practical reasons, a Connection equals a Db.\n *\n * @param {Mongoose} base a mongoose instance\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `connecting`: Emitted when `connection.openUri()` is executed on this connection.\n * @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected` scenarios.\n * @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.\n * @event `disconnecting`: Emitted when `connection.close()` was executed.\n * @event `disconnected`: Emitted after getting disconnected from the db.\n * @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.\n * @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successfull connection.\n * @event `error`: Emitted when an error occurs on this connection.\n * @event `fullsetup`: Emitted in a replica-set scenario, when primary and at least one seconaries specified in the connection string are connected.\n * @event `all`: Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.\n * @api public\n */\n\nfunction Connection(base) {\n  this.base = base;\n  this.collections = {};\n  this.models = {};\n  this.config = {autoIndex: true};\n  this.replica = false;\n  this.options = null;\n  this.otherDbs = []; // FIXME: To be replaced with relatedDbs\n  this.relatedDbs = {}; // Hashmap of other dbs that share underlying connection\n  this.states = STATES;\n  this._readyState = STATES.disconnected;\n  this._closeCalled = false;\n  this._hasOpened = false;\n\n  this.$internalEmitter = new EventEmitter();\n  this.$internalEmitter.setMaxListeners(0);\n}\n\n/*!\n * Inherit from EventEmitter\n */\n\nConnection.prototype.__proto__ = EventEmitter.prototype;\n\n/**\n * Connection ready state\n *\n * - 0 = disconnected\n * - 1 = connected\n * - 2 = connecting\n * - 3 = disconnecting\n *\n * Each state change emits its associated event name.\n *\n * ####Example\n *\n *     conn.on('connected', callback);\n *     conn.on('disconnected', callback);\n *\n * @property readyState\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'readyState', {\n  get: function() {\n    return this._readyState;\n  },\n  set: function(val) {\n    if (!(val in STATES)) {\n      throw new Error('Invalid connection state: ' + val);\n    }\n\n    if (this._readyState !== val) {\n      this._readyState = val;\n      // [legacy] loop over the otherDbs on this connection and change their state\n      for (let i = 0; i < this.otherDbs.length; i++) {\n        this.otherDbs[i].readyState = val;\n      }\n\n      // loop over relatedDbs on this connection and change their state\n      for (const k in this.relatedDbs) {\n        this.relatedDbs[k].readyState = val;\n      }\n\n      if (STATES.connected === val) {\n        this._hasOpened = true;\n      }\n\n      this.emit(STATES[val]);\n    }\n  }\n});\n\n/**\n * A hash of the collections associated with this connection\n *\n * @property collections\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.collections;\n\n/**\n * The name of the database this connection points to.\n *\n * ####Example\n *\n *     mongoose.createConnection('mongodb://localhost:27017/mydb').name; // \"mydb\"\n *\n * @property name\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.name;\n\n/**\n * The host name portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the first host name in the URI\n *\n * ####Example\n *\n *     mongoose.createConnection('mongodb://localhost:27017/mydb').host; // \"localhost\"\n *\n * @property host\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'host', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The port portion of the URI. If multiple hosts, such as a replica set,\n * this will contain the port from the first host name in the URI.\n *\n * ####Example\n *\n *     mongoose.createConnection('mongodb://localhost:27017/mydb').port; // 27017\n *\n * @property port\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'port', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The username specified in the URI\n *\n * ####Example\n *\n *     mongoose.createConnection('mongodb://val:psw@localhost:27017/mydb').user; // \"val\"\n *\n * @property user\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'user', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The password specified in the URI\n *\n * ####Example\n *\n *     mongoose.createConnection('mongodb://val:psw@localhost:27017/mydb').pass; // \"psw\"\n *\n * @property pass\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nObject.defineProperty(Connection.prototype, 'pass', {\n  configurable: true,\n  enumerable: true,\n  writable: true\n});\n\n/**\n * The mongodb.Db instance, set when the connection is opened\n *\n * @property db\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.db;\n\n/**\n * A hash of the global options that are associated with this connection\n *\n * @property config\n * @memberOf Connection\n * @instance\n * @api public\n */\n\nConnection.prototype.config;\n\n/**\n * Helper for `createCollection()`. Will explicitly create the given collection\n * with specified options. Used to create [capped collections](https://docs.mongodb.com/manual/core/capped-collections/)\n * and [views](https://docs.mongodb.com/manual/core/views/) from mongoose.\n *\n * Options are passed down without modification to the [MongoDB driver's `createCollection()` function](http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html#createCollection)\n *\n * @method createCollection\n * @param {string} collection The collection to create\n * @param {Object} [options] see [MongoDB driver docs](http://mongodb.github.io/node-mongodb-native/2.2/api/Db.html#createCollection)\n * @param {Function} [callback]\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.createCollection = _wrapConnHelper(function createCollection(collection, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n  this.db.createCollection(collection, options, cb);\n});\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),\n * and [transactions](http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * ####Example:\n *\n *     const session = await conn.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n *\n * @method startSession\n * @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @param {Function} [callback]\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nConnection.prototype.startSession = _wrapConnHelper(function startSession(options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = null;\n  }\n  const session = this.client.startSession(options);\n  cb(null, session);\n});\n\n/**\n * Helper for `dropCollection()`. Will delete the given collection, including\n * all documents and indexes.\n *\n * @method dropCollection\n * @param {string} collection The collection to delete\n * @param {Function} [callback]\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropCollection = _wrapConnHelper(function dropCollection(collection, cb) {\n  this.db.dropCollection(collection, cb);\n});\n\n/**\n * Helper for `dropDatabase()`. Deletes the given database, including all\n * collections, documents, and indexes.\n *\n * @method dropDatabase\n * @param {Function} [callback]\n * @return {Promise}\n * @api public\n */\n\nConnection.prototype.dropDatabase = _wrapConnHelper(function dropDatabase(cb) {\n  this.$internalEmitter.emit('dropDatabase');\n  this.db.dropDatabase(cb);\n});\n\n/*!\n * ignore\n */\n\nfunction _wrapConnHelper(fn) {\n  return function() {\n    const cb = arguments.length > 0 ? arguments[arguments.length - 1] : null;\n    const argsWithoutCb = typeof cb === 'function' ?\n      Array.prototype.slice.call(arguments, 0, arguments.length - 1) :\n      Array.prototype.slice.call(arguments);\n    return utils.promiseOrCallback(cb, cb => {\n      if (this.readyState !== STATES.connected) {\n        this.once('open', function() {\n          fn.apply(this, argsWithoutCb.concat([cb]));\n        });\n      } else {\n        fn.apply(this, argsWithoutCb.concat([cb]));\n      }\n    });\n  };\n}\n\n/**\n * error\n *\n * Graceful error handling, passes error to callback\n * if available, else emits error on the connection.\n *\n * @param {Error} err\n * @param {Function} callback optional\n * @api private\n */\n\nConnection.prototype.error = function(err, callback) {\n  if (callback) {\n    callback(err);\n    return null;\n  }\n  if (this.listeners('error').length > 0) {\n    this.emit('error', err);\n  }\n  return Promise.reject(err);\n};\n\n/**\n * Called when the connection is opened\n *\n * @api private\n */\n\nConnection.prototype.onOpen = function() {\n  this.readyState = STATES.connected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onOpen();\n    }\n  }\n\n  this.emit('open');\n};\n\n/**\n * Opens the connection with a URI using `MongoClient.connect()`.\n *\n * @param {String} uri The URI to connect with.\n * @param {Object} [options] Passed on to http://mongodb.github.io/node-mongodb-native/2.2/api/MongoClient.html#connect\n * @param {Function} [callback]\n * @returns {Connection} this\n * @api private\n */\n\nConnection.prototype.openUri = function(uri, options, callback) {\n  this.readyState = STATES.connecting;\n  this._closeCalled = false;\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  if (['string', 'number'].indexOf(typeof options) !== -1) {\n    throw new MongooseError('Mongoose 5.x no longer supports ' +\n      '`mongoose.connect(host, dbname, port)` or ' +\n      '`mongoose.createConnection(host, dbname, port)`. See ' +\n      'http://mongoosejs.com/docs/connections.html for supported connection syntax');\n  }\n\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +\n      `string, got \"${typeof uri}\". Make sure the first parameter to ` +\n      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n\n  const Promise = PromiseProvider.get();\n  const _this = this;\n\n  if (options) {\n    options = utils.clone(options);\n    const autoIndex = options.config && options.config.autoIndex != null ?\n      options.config.autoIndex :\n      options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n    if ('useCreateIndex' in options) {\n      this.config.useCreateIndex = !!options.useCreateIndex;\n      delete options.useCreateIndex;\n    }\n\n    if ('useFindAndModify' in options) {\n      this.config.useFindAndModify = !!options.useFindAndModify;\n      delete options.useFindAndModify;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.user = options.user;\n      options.auth.password = options.pass;\n\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n\n    if (options.bufferCommands != null) {\n      options.bufferMaxEntries = 0;\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n\n    if (options.useMongoClient != null) {\n      handleUseMongoClient(options);\n    }\n  } else {\n    options = {};\n  }\n\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n\n  if (!('promiseLibrary' in options)) {\n    options.promiseLibrary = PromiseProvider.get();\n  }\n  if (!('useNewUrlParser' in options)) {\n    if ('useNewUrlParser' in this.base.options) {\n      options.useNewUrlParser = this.base.options.useNewUrlParser;\n    } else {\n      options.useNewUrlParser = false;\n    }\n  }\n\n  const parsePromise = new Promise((resolve, reject) => {\n    parseConnectionString(uri, options, (err, parsed) => {\n      if (err) {\n        return reject(err);\n      }\n      this.name = dbName != null ? dbName : get(parsed, 'auth.db', null);\n      this.host = get(parsed, 'hosts.0.host') || 'localhost';\n      this.port = get(parsed, 'hosts.0.port') || 27017;\n      this.user = this.user || get(parsed, 'auth.username');\n      this.pass = this.pass || get(parsed, 'auth.password');\n      resolve();\n    });\n  });\n\n  const promise = new Promise((resolve, reject) => {\n    const client = new mongodb.MongoClient(uri, options);\n    _this.client = client;\n    client.connect(function(error) {\n      if (error) {\n        _this.readyState = STATES.disconnected;\n        return reject(error);\n      }\n\n      const db = dbName != null ? client.db(dbName) : client.db();\n      _this.db = db;\n\n      // Backwards compat for mongoose 4.x\n      db.on('reconnect', function() {\n        _this.readyState = STATES.connected;\n        _this.emit('reconnect');\n        _this.emit('reconnected');\n      });\n      db.s.topology.on('reconnectFailed', function() {\n        _this.emit('reconnectFailed');\n      });\n      db.s.topology.on('left', function(data) {\n        _this.emit('left', data);\n      });\n      db.s.topology.on('joined', function(data) {\n        _this.emit('joined', data);\n      });\n      db.s.topology.on('fullsetup', function(data) {\n        _this.emit('fullsetup', data);\n      });\n      db.on('close', function() {\n        // Implicitly emits 'disconnected'\n        _this.readyState = STATES.disconnected;\n      });\n      db.on('timeout', function() {\n        _this.emit('timeout');\n      });\n\n      delete _this.then;\n      delete _this.catch;\n      _this.readyState = STATES.connected;\n\n      for (const i in _this.collections) {\n        if (utils.object.hasOwnProperty(_this.collections, i)) {\n          _this.collections[i].onOpen();\n        }\n      }\n\n      resolve(_this);\n      _this.emit('open');\n    });\n  });\n\n  this.$initialConnection = Promise.all([promise, parsePromise]).\n    then(res => res[0]).\n    catch(err => {\n      if (this.listeners('error').length > 0) {\n        process.nextTick(() => this.emit('error', err));\n        return;\n      }\n      throw err;\n    });\n  this.then = function(resolve, reject) {\n    return this.$initialConnection.then(resolve, reject);\n  };\n  this.catch = function(reject) {\n    return this.$initialConnection.catch(reject);\n  };\n\n  if (callback != null) {\n    this.$initialConnection = this.$initialConnection.then(\n      () => callback(null, this),\n      err => callback(err)\n    );\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nconst handleUseMongoClient = function handleUseMongoClient(options) {\n  console.warn('WARNING: The `useMongoClient` option is no longer ' +\n    'necessary in mongoose 5.x, please remove it.');\n  const stack = new Error().stack;\n  console.warn(stack.substr(stack.indexOf('\\n') + 1));\n  delete options.useMongoClient;\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force] optional\n * @param {Function} [callback] optional\n * @return {Connection} self\n * @api public\n */\n\nConnection.prototype.close = function(force, callback) {\n  if (typeof force === 'function') {\n    callback = force;\n    force = false;\n  }\n\n  this.$wasForceClosed = !!force;\n\n  return utils.promiseOrCallback(callback, cb => {\n    this._close(force, cb);\n  });\n};\n\n/**\n * Handles closing the connection\n *\n * @param {Boolean} force\n * @param {Function} callback\n * @api private\n */\nConnection.prototype._close = function(force, callback) {\n  const _this = this;\n  this._closeCalled = true;\n\n  switch (this.readyState) {\n    case 0: // disconnected\n      callback();\n      break;\n\n    case 1: // connected\n      this.readyState = STATES.disconnecting;\n      this.doClose(force, function(err) {\n        if (err) {\n          return callback(err);\n        }\n        _this.onClose(force);\n        callback(null);\n      });\n\n      break;\n    case 2: // connecting\n      this.once('open', function() {\n        _this.close(callback);\n      });\n      break;\n\n    case 3: // disconnecting\n      this.once('close', function() {\n        callback();\n      });\n      break;\n  }\n\n  return this;\n};\n\n/**\n * Called when the connection closes\n *\n * @api private\n */\n\nConnection.prototype.onClose = function(force) {\n  this.readyState = STATES.disconnected;\n\n  // avoid having the collection subscribe to our event emitter\n  // to prevent 0.3 warning\n  for (const i in this.collections) {\n    if (utils.object.hasOwnProperty(this.collections, i)) {\n      this.collections[i].onClose(force);\n    }\n  }\n\n  this.emit('close', force);\n};\n\n/**\n * Retrieves a collection, creating it if not cached.\n *\n * Not typically needed by applications. Just talk to your collection through your model.\n *\n * @param {String} name of the collection\n * @param {Object} [options] optional collection options\n * @return {Collection} collection instance\n * @api public\n */\n\nConnection.prototype.collection = function(name, options) {\n  options = options ? utils.clone(options) : {};\n  options.$wasForceClosed = this.$wasForceClosed;\n  if (!(name in this.collections)) {\n    this.collections[name] = new Collection(name, this, options);\n  }\n  return this.collections[name];\n};\n\n/**\n * Defines or retrieves a model.\n *\n *     var mongoose = require('mongoose');\n *     var db = mongoose.createConnection(..);\n *     db.model('Venue', new Schema(..));\n *     var Ticket = db.model('Ticket', new Schema(..));\n *     var Venue = db.model('Venue');\n *\n * _When no `collection` argument is passed, Mongoose produces a collection name by passing the model `name` to the [utils.toCollectionName](#utils_exports.toCollectionName) method. This method pluralizes the name. If you don't like this behavior, either pass a collection name or set your schemas collection name option._\n *\n * ####Example:\n *\n *     var schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     var collectionName = 'actor'\n *     var M = conn.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name the model name or class extending Model\n * @param {Schema} [schema] a schema. necessary when defining a model\n * @param {String} [collection] name of mongodb collection (optional) if not given it will be induced from model name\n * @see Mongoose#model #index_Mongoose-model\n * @return {Model} The compiled model\n * @api public\n */\n\nConnection.prototype.model = function(name, schema, collection) {\n  if (!(this instanceof Connection)) {\n    throw new MongooseError('`connection.model()` should not be run with ' +\n      '`new`. If you are doing `new db.model(foo)(bar)`, use ' +\n      '`db.model(foo)(bar)` instead');\n  }\n\n  let fn;\n  if (typeof name === 'function') {\n    fn = name;\n    name = fn.name;\n  }\n\n  // collection name discovery\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  if (this.models[name] && !collection) {\n    // model exists but we are not subclassing with custom collection\n    if (schema && schema.instanceOfSchema && schema !== this.models[name].schema) {\n      throw new MongooseError.OverwriteModelError(name);\n    }\n    return this.models[name];\n  }\n\n  const opts = {cache: false, connection: this};\n  let model;\n\n  if (schema && schema.instanceOfSchema) {\n    // compile a model\n    model = this.base.model(fn || name, schema, collection, opts);\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    // Errors handled internally, so safe to ignore error\n    model.init(function $modelInitNoop() {});\n\n    return model;\n  }\n\n  if (this.models[name] && collection) {\n    // subclassing current model with alternate collection\n    model = this.models[name];\n    schema = model.prototype.schema;\n    const sub = model.__subclass(this, schema, collection);\n    // do not cache the sub model\n    return sub;\n  }\n\n  // lookup model in mongoose module\n  model = this.base.models[name];\n\n  if (!model) {\n    throw new MongooseError.MissingSchemaError(name);\n  }\n\n  if (this === model.prototype.db\n      && (!collection || collection === model.collection.name)) {\n    // model already uses this connection.\n\n    // only the first model with this name is cached to allow\n    // for one-offs with custom collection names etc.\n    if (!this.models[name]) {\n      this.models[name] = model;\n    }\n\n    return model;\n  }\n  this.models[name] = model.__subclass(this, schema, collection);\n  return this.models[name];\n};\n\n/**\n * Removes the model named `name` from this connection, if it exists. You can\n * use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * ####Example:\n *\n *     conn.model('User', new Schema({ name: String }));\n *     console.log(conn.model('User')); // Model object\n *     conn.deleteModel('User');\n *     console.log(conn.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       conn.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Connection} this\n */\n\nConnection.prototype.deleteModel = function(name) {\n  if (typeof name === 'string') {\n    const model = this.model(name);\n    if (model == null) {\n      return this;\n    }\n    delete this.models[name];\n    delete this.collections[model.collection.name];\n    delete this.base.modelSchemas[name];\n  } else if (name instanceof RegExp) {\n    const pattern = name;\n    const names = this.modelNames();\n    for (const name of names) {\n      if (pattern.test(name)) {\n        this.deleteModel(name);\n      }\n    }\n  } else {\n    throw new Error('First parameter to `deleteModel()` must be a string ' +\n      'or regexp, got \"' + name + '\"');\n  }\n\n  return this;\n};\n\n/**\n * Returns an array of model names created on this connection.\n * @api public\n * @return {Array}\n */\n\nConnection.prototype.modelNames = function() {\n  return Object.keys(this.models);\n};\n\n/**\n * @brief Returns if the connection requires authentication after it is opened. Generally if a\n * username and password are both provided than authentication is needed, but in some cases a\n * password is not required.\n * @api private\n * @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.\n */\nConnection.prototype.shouldAuthenticate = function() {\n  return this.user != null &&\n    (this.pass != null || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * @brief Returns a boolean value that specifies if the current authentication mechanism needs a\n * password to authenticate according to the auth objects passed into the openUri methods.\n * @api private\n * @return {Boolean} true if the authentication mechanism specified in the options object requires\n *  a password, otherwise false.\n */\nConnection.prototype.authMechanismDoesNotRequirePassword = function() {\n  if (this.options && this.options.auth) {\n    return noPasswordAuthMechanisms.indexOf(this.options.auth.authMechanism) >= 0;\n  }\n  return true;\n};\n\n/**\n * @brief Returns a boolean value that specifies if the provided objects object provides enough\n * data to authenticate with. Generally this is true if the username and password are both specified\n * but in some authentication methods, a password is not required for authentication so only a username\n * is required.\n * @param {Object} [options] the options object passed into the openUri methods.\n * @api private\n * @return {Boolean} true if the provided options object provides enough data to authenticate with,\n *   otherwise false.\n */\nConnection.prototype.optionsProvideAuthenticationData = function(options) {\n  return (options) &&\n      (options.user) &&\n      ((options.pass) || this.authMechanismDoesNotRequirePassword());\n};\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db.\n *\n * @method useDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} New Connection Object\n * @api public\n */\n\n/*!\n * Module exports.\n */\n\nConnection.STATES = STATES;\nmodule.exports = Connection;\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar bodyParser = require('body-parser')\nvar EventEmitter = require('events').EventEmitter;\nvar mixin = require('merge-descriptors');\nvar proto = require('./application');\nvar Route = require('./router/route');\nvar Router = require('./router');\nvar req = require('./request');\nvar res = require('./response');\n\n/**\n * Expose `createApplication()`.\n */\n\nexports = module.exports = createApplication;\n\n/**\n * Create an express application.\n *\n * @return {Function}\n * @api public\n */\n\nfunction createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  };\n\n  mixin(app, EventEmitter.prototype, false);\n  mixin(app, proto, false);\n\n  // expose the prototype that will get set on requests\n  app.request = Object.create(req, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  // expose the prototype that will get set on responses\n  app.response = Object.create(res, {\n    app: { configurable: true, enumerable: true, writable: true, value: app }\n  })\n\n  app.init();\n  return app;\n}\n\n/**\n * Expose the prototypes.\n */\n\nexports.application = proto;\nexports.request = req;\nexports.response = res;\n\n/**\n * Expose constructors.\n */\n\nexports.Route = Route;\nexports.Router = Router;\n\n/**\n * Expose middleware\n */\n\nexports.json = bodyParser.json\nexports.query = require('./middleware/query');\nexports.static = require('serve-static');\nexports.urlencoded = bodyParser.urlencoded\n\n/**\n * Replace removed middleware with an appropriate error message.\n */\n\nvar removedMiddlewares = [\n  'bodyParser',\n  'compress',\n  'cookieSession',\n  'session',\n  'logger',\n  'cookieParser',\n  'favicon',\n  'responseTime',\n  'errorHandler',\n  'timeout',\n  'methodOverride',\n  'vhost',\n  'csrf',\n  'directory',\n  'limit',\n  'multipart',\n  'staticCache'\n]\n\nremovedMiddlewares.forEach(function (name) {\n  Object.defineProperty(exports, name, {\n    get: function () {\n      throw new Error('Most middleware (like ' + name + ') is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.');\n    },\n    configurable: true\n  });\n});\n","/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar deprecate = require('depd')('body-parser')\n\n/**\n * Cache of loaded parsers.\n * @private\n */\n\nvar parsers = Object.create(null)\n\n/**\n * @typedef Parsers\n * @type {function}\n * @property {function} json\n * @property {function} raw\n * @property {function} text\n * @property {function} urlencoded\n */\n\n/**\n * Module exports.\n * @type {Parsers}\n */\n\nexports = module.exports = deprecate.function(bodyParser,\n  'bodyParser: use individual json/urlencoded middlewares')\n\n/**\n * JSON parser.\n * @public\n */\n\nObject.defineProperty(exports, 'json', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('json')\n})\n\n/**\n * Raw parser.\n * @public\n */\n\nObject.defineProperty(exports, 'raw', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('raw')\n})\n\n/**\n * Text parser.\n * @public\n */\n\nObject.defineProperty(exports, 'text', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('text')\n})\n\n/**\n * URL-encoded parser.\n * @public\n */\n\nObject.defineProperty(exports, 'urlencoded', {\n  configurable: true,\n  enumerable: true,\n  get: createParserGetter('urlencoded')\n})\n\n/**\n * Create a middleware to parse json and urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @deprecated\n * @public\n */\n\nfunction bodyParser (options) {\n  var opts = {}\n\n  // exclude type option\n  if (options) {\n    for (var prop in options) {\n      if (prop !== 'type') {\n        opts[prop] = options[prop]\n      }\n    }\n  }\n\n  var _urlencoded = exports.urlencoded(opts)\n  var _json = exports.json(opts)\n\n  return function bodyParser (req, res, next) {\n    _json(req, res, function (err) {\n      if (err) return next(err)\n      _urlencoded(req, res, next)\n    })\n  }\n}\n\n/**\n * Create a getter for loading a parser.\n * @private\n */\n\nfunction createParserGetter (name) {\n  return function get () {\n    return loadParser(name)\n  }\n}\n\n/**\n * Load a parser module.\n * @private\n */\n\nfunction loadParser (parserName) {\n  var parser = parsers[parserName]\n\n  if (parser !== undefined) {\n    return parser\n  }\n\n  // this uses a switch for static require analysis\n  switch (parserName) {\n    case 'json':\n      parser = require('./lib/types/json')\n      break\n    case 'raw':\n      parser = require('./lib/types/raw')\n      break\n    case 'text':\n      parser = require('./lib/types/text')\n      break\n    case 'urlencoded':\n      parser = require('./lib/types/urlencoded')\n      break\n  }\n\n  // store to prevent invoking require()\n  return (parsers[parserName] = parser)\n}\n","/*!\n * depd\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = callSiteToString\n\n/**\n * Format a CallSite file location to a string.\n */\n\nfunction callSiteFileLocation (callSite) {\n  var fileName\n  var fileLocation = ''\n\n  if (callSite.isNative()) {\n    fileLocation = 'native'\n  } else if (callSite.isEval()) {\n    fileName = callSite.getScriptNameOrSourceURL()\n    if (!fileName) {\n      fileLocation = callSite.getEvalOrigin()\n    }\n  } else {\n    fileName = callSite.getFileName()\n  }\n\n  if (fileName) {\n    fileLocation += fileName\n\n    var lineNumber = callSite.getLineNumber()\n    if (lineNumber != null) {\n      fileLocation += ':' + lineNumber\n\n      var columnNumber = callSite.getColumnNumber()\n      if (columnNumber) {\n        fileLocation += ':' + columnNumber\n      }\n    }\n  }\n\n  return fileLocation || 'unknown source'\n}\n\n/**\n * Format a CallSite to a string.\n */\n\nfunction callSiteToString (callSite) {\n  var addSuffix = true\n  var fileLocation = callSiteFileLocation(callSite)\n  var functionName = callSite.getFunctionName()\n  var isConstructor = callSite.isConstructor()\n  var isMethodCall = !(callSite.isToplevel() || isConstructor)\n  var line = ''\n\n  if (isMethodCall) {\n    var methodName = callSite.getMethodName()\n    var typeName = getConstructorName(callSite)\n\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) !== 0) {\n        line += typeName + '.'\n      }\n\n      line += functionName\n\n      if (methodName && functionName.lastIndexOf('.' + methodName) !== functionName.length - methodName.length - 1) {\n        line += ' [as ' + methodName + ']'\n      }\n    } else {\n      line += typeName + '.' + (methodName || '<anonymous>')\n    }\n  } else if (isConstructor) {\n    line += 'new ' + (functionName || '<anonymous>')\n  } else if (functionName) {\n    line += functionName\n  } else {\n    addSuffix = false\n    line += fileLocation\n  }\n\n  if (addSuffix) {\n    line += ' (' + fileLocation + ')'\n  }\n\n  return line\n}\n\n/**\n * Get constructor name of reviver.\n */\n\nfunction getConstructorName (obj) {\n  var receiver = obj.receiver\n  return (receiver.constructor && receiver.constructor.name) || null\n}\n","/*!\n * depd\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = eventListenerCount\n\n/**\n * Get the count of listeners on an event emitter of a specific type.\n */\n\nfunction eventListenerCount (emitter, type) {\n  return emitter.listeners(type).length\n}\n","/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:json')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = json\n\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*(.)/ // eslint-disable-line no-control-regex\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json (options) {\n  var opts = options || {}\n\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var inflate = opts.inflate !== false\n  var reviver = opts.reviver\n  var strict = opts.strict !== false\n  var type = opts.type || 'application/json'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {}\n    }\n\n    if (strict) {\n      var first = firstchar(body)\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation')\n        throw createStrictSyntaxError(body, first)\n      }\n    }\n\n    try {\n      debug('parse json')\n      return JSON.parse(body, reviver)\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      })\n    }\n  }\n\n  return function jsonParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8'\n    if (charset.substr(0, 4) !== 'utf-') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Create strict violation syntax error matching native error.\n *\n * @param {string} str\n * @param {string} char\n * @return {Error}\n * @private\n */\n\nfunction createStrictSyntaxError (str, char) {\n  var index = str.indexOf(char)\n  var partial = str.substring(0, index) + '#'\n\n  try {\n    JSON.parse(partial); /* istanbul ignore next */ throw new SyntaxError('strict violation')\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    })\n  }\n}\n\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @private\n */\n\nfunction firstchar (str) {\n  return FIRST_CHAR_REGEXP.exec(str)[1]\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Normalize a SyntaxError for JSON.parse.\n *\n * @param {SyntaxError} error\n * @param {object} obj\n * @return {SyntaxError}\n */\n\nfunction normalizeJsonSyntaxError (error, obj) {\n  var keys = Object.getOwnPropertyNames(error)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key]\n    }\n  }\n\n  // replace stack before message for Node.js 0.10 and below\n  error.stack = obj.stack.replace(error.message, obj.message)\n  error.message = obj.message\n\n  return error\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n","/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = require('./codes.json')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// status code to message map\nstatus.STATUS_CODES = codes\n\n// array of status codes\nstatus.codes = populateStatusesMap(status, codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Populate the statuses map for given codes.\n * @private\n */\n\nfunction populateStatusesMap (statuses, codes) {\n  var arr = []\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // Populate properties\n    statuses[status] = message\n    statuses[message] = status\n    statuses[message.toLowerCase()] = status\n\n    // Add to array\n    arr.push(status)\n  })\n\n  return arr\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    if (!status[code]) throw new Error('invalid status code: ' + code)\n    return code\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    if (!status[n]) throw new Error('invalid status code: ' + n)\n    return n\n  }\n\n  n = status[code.toLowerCase()]\n  if (!n) throw new Error('invalid status message: \"' + code + '\"')\n  return n\n}\n","/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar createError = require('http-errors')\nvar iconv = require('iconv-lite')\nvar unpipe = require('unpipe')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody\n\n/**\n * Module variables.\n * @private\n */\n\nvar ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder (encoding) {\n  if (!encoding) return null\n\n  try {\n    return iconv.getDecoder(encoding)\n  } catch (e) {\n    // error getting decoder\n    if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', {\n      encoding: encoding,\n      type: 'encoding.unsupported'\n    })\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody (stream, options, callback) {\n  var done = callback\n  var opts = options || {}\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    }\n  }\n\n  if (typeof options === 'function') {\n    done = options\n    opts = {}\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function')\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required')\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true\n    ? opts.encoding\n    : 'utf-8'\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit)\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length)\n    ? parseInt(opts.length, 10)\n    : null\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, done)\n  }\n\n  return new Promise(function executor (resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead (err, buf) {\n      if (err) return reject(err)\n      resolve(buf)\n    })\n  })\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt (stream) {\n  // unpipe everything from the stream\n  unpipe(stream)\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause()\n  }\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream (stream, encoding, length, limit, callback) {\n  var complete = false\n  var sync = true\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', {\n      expected: length,\n      length: length,\n      limit: limit,\n      type: 'entity.too.large'\n    }))\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', {\n      type: 'stream.encoding.set'\n    }))\n  }\n\n  var received = 0\n  var decoder\n\n  try {\n    decoder = getDecoder(encoding)\n  } catch (err) {\n    return done(err)\n  }\n\n  var buffer = decoder\n    ? ''\n    : []\n\n  // attach listeners\n  stream.on('aborted', onAborted)\n  stream.on('close', cleanup)\n  stream.on('data', onData)\n  stream.on('end', onEnd)\n  stream.on('error', onEnd)\n\n  // mark sync section complete\n  sync = false\n\n  function done () {\n    var args = new Array(arguments.length)\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    // mark complete\n    complete = true\n\n    if (sync) {\n      process.nextTick(invokeCallback)\n    } else {\n      invokeCallback()\n    }\n\n    function invokeCallback () {\n      cleanup()\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream)\n      }\n\n      callback.apply(null, args)\n    }\n  }\n\n  function onAborted () {\n    if (complete) return\n\n    done(createError(400, 'request aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received,\n      type: 'request.aborted'\n    }))\n  }\n\n  function onData (chunk) {\n    if (complete) return\n\n    received += chunk.length\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', {\n        limit: limit,\n        received: received,\n        type: 'entity.too.large'\n      }))\n    } else if (decoder) {\n      buffer += decoder.write(chunk)\n    } else {\n      buffer.push(chunk)\n    }\n  }\n\n  function onEnd (err) {\n    if (complete) return\n    if (err) return done(err)\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', {\n        expected: length,\n        length: length,\n        received: received,\n        type: 'request.size.invalid'\n      }))\n    } else {\n      var string = decoder\n        ? buffer + (decoder.end() || '')\n        : Buffer.concat(buffer)\n      done(null, string)\n    }\n  }\n\n  function cleanup () {\n    buffer = null\n\n    stream.removeListener('aborted', onAborted)\n    stream.removeListener('data', onData)\n    stream.removeListener('end', onEnd)\n    stream.removeListener('error', onEnd)\n    stream.removeListener('close', cleanup)\n  }\n}\n","/*!\n * ee-first\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = first\n\n/**\n * Get the first event in a set of event emitters and event pairs.\n *\n * @param {array} stuff\n * @param {function} done\n * @public\n */\n\nfunction first(stuff, done) {\n  if (!Array.isArray(stuff))\n    throw new TypeError('arg must be an array of [ee, events...] arrays')\n\n  var cleanups = []\n\n  for (var i = 0; i < stuff.length; i++) {\n    var arr = stuff[i]\n\n    if (!Array.isArray(arr) || arr.length < 2)\n      throw new TypeError('each array member must be [ee, events...]')\n\n    var ee = arr[0]\n\n    for (var j = 1; j < arr.length; j++) {\n      var event = arr[j]\n      var fn = listener(event, callback)\n\n      // listen to the event\n      ee.on(event, fn)\n      // push this listener to the list of cleanups\n      cleanups.push({\n        ee: ee,\n        event: event,\n        fn: fn,\n      })\n    }\n  }\n\n  function callback() {\n    cleanup()\n    done.apply(null, arguments)\n  }\n\n  function cleanup() {\n    var x\n    for (var i = 0; i < cleanups.length; i++) {\n      x = cleanups[i]\n      x.ee.removeListener(x.event, x.fn)\n    }\n  }\n\n  function thunk(fn) {\n    done = fn\n  }\n\n  thunk.cancel = cleanup\n\n  return thunk\n}\n\n/**\n * Create the event listener.\n * @private\n */\n\nfunction listener(event, done) {\n  return function onevent(arg1) {\n    var args = new Array(arguments.length)\n    var ee = this\n    var err = event === 'error'\n      ? arg1\n      : null\n\n    // copy args to prevent arguments escaping scope\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    done(err, ee, event, args)\n  }\n}\n","/*!\n * media-typer\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 2616 sec 3.7\n *\n * parameter     = token \"=\" ( token | quoted-string )\n * token         = 1*<any CHAR except CTLs or separators>\n * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *               | \",\" | \";\" | \":\" | \"\\\" | <\">\n *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *               | \"{\" | \"}\" | SP | HT\n * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\n * qdtext        = <any TEXT except <\">>\n * quoted-pair   = \"\\\" CHAR\n * CHAR          = <any US-ASCII character (octets 0 - 127)>\n * TEXT          = <any OCTET except CTLs, but including LWS>\n * LWS           = [CRLF] 1*( SP | HT )\n * CRLF          = CR LF\n * CR            = <US-ASCII CR, carriage return (13)>\n * LF            = <US-ASCII LF, linefeed (10)>\n * SP            = <US-ASCII SP, space (32)>\n * SHT           = <US-ASCII HT, horizontal-tab (9)>\n * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\n * OCTET         = <any 8-bit sequence of data>\n */\nvar paramRegExp = /; *([!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+) *= *(\"(?:[ !\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u0020-\\u007e])*\"|[!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+) */g;\nvar textRegExp = /^[\\u0020-\\u007e\\u0080-\\u00ff]+$/\nvar tokenRegExp = /^[!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 2616\n *\n * quoted-pair = \"\\\" CHAR\n * CHAR        = <any US-ASCII character (octets 0 - 127)>\n */\nvar qescRegExp = /\\\\([\\u0000-\\u007f])/g;\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 2616\n */\nvar quoteRegExp = /([\\\\\"])/g;\n\n/**\n * RegExp to match type in RFC 6838\n *\n * type-name = restricted-name\n * subtype-name = restricted-name\n * restricted-name = restricted-name-first *126restricted-name-chars\n * restricted-name-first  = ALPHA / DIGIT\n * restricted-name-chars  = ALPHA / DIGIT / \"!\" / \"#\" /\n *                          \"$\" / \"&\" / \"-\" / \"^\" / \"_\"\n * restricted-name-chars =/ \".\" ; Characters before first dot always\n *                              ; specify a facet name\n * restricted-name-chars =/ \"+\" ; Characters after last plus always\n *                              ; specify a structured syntax suffix\n * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z\n * DIGIT =  %x30-39             ; 0-9\n */\nvar subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/\nvar typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/\nvar typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;\n\n/**\n * Module exports.\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @api public\n */\n\nfunction format(obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var subtype = obj.subtype\n  var suffix = obj.suffix\n  var type = obj.type\n\n  if (!type || !typeNameRegExp.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  if (!subtype || !subtypeNameRegExp.test(subtype)) {\n    throw new TypeError('invalid subtype')\n  }\n\n  // format as type/subtype\n  var string = type + '/' + subtype\n\n  // append +suffix\n  if (suffix) {\n    if (!typeNameRegExp.test(suffix)) {\n      throw new TypeError('invalid suffix')\n    }\n\n    string += '+' + suffix\n  }\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!tokenRegExp.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @api public\n */\n\nfunction parse(string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  if (typeof string === 'object') {\n    string = getcontenttype(string)\n  }\n\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = string.indexOf(';')\n  var type = index !== -1\n    ? string.substr(0, index)\n    : string\n\n  var key\n  var match\n  var obj = splitType(type)\n  var params = {}\n  var value\n\n  paramRegExp.lastIndex = index\n\n  while (match = paramRegExp.exec(string)) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format')\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value\n        .substr(1, value.length - 2)\n        .replace(qescRegExp, '$1')\n    }\n\n    params[key] = value\n  }\n\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format')\n  }\n\n  obj.parameters = params\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @api private\n */\n\nfunction getcontenttype(obj) {\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    return obj.getHeader('content-type')\n  }\n\n  if (typeof obj.headers === 'object') {\n    // req-like\n    return obj.headers && obj.headers['content-type']\n  }\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @api private\n */\n\nfunction qstring(val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (tokenRegExp.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !textRegExp.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(quoteRegExp, '\\\\$1') + '\"'\n}\n\n/**\n * Simply \"type/subtype+siffx\" into parts.\n *\n * @param {string} string\n * @return {Object}\n * @api private\n */\n\nfunction splitType(string) {\n  var match = typeRegExp.exec(string.toLowerCase())\n\n  if (!match) {\n    throw new TypeError('invalid media type')\n  }\n\n  var type = match[1]\n  var subtype = match[2]\n  var suffix\n\n  // suffix after last +\n  var index = subtype.lastIndexOf('+')\n  if (index !== -1) {\n    suffix = subtype.substr(index + 1)\n    subtype = subtype.substr(0, index)\n  }\n\n  var obj = {\n    type: type,\n    subtype: subtype,\n    suffix: suffix\n  }\n\n  return obj\n}\n","/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n/**\n * Module exports.\n */\n\nmodule.exports = require('./db.json')\n","/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar debug = require('debug')('body-parser:raw')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = raw\n\n/**\n * Create a middleware to parse raw bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction raw (options) {\n  var opts = options || {}\n\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/octet-stream'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (buf) {\n    return buf\n  }\n\n  return function rawParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: null,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n","/*!\n * body-parser\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar debug = require('debug')('body-parser:text')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = text\n\n/**\n * Create a middleware to parse text bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @api public\n */\n\nfunction text (options) {\n  var opts = options || {}\n\n  var defaultCharset = opts.defaultCharset || 'utf-8'\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'text/plain'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (buf) {\n    return buf\n  }\n\n  return function textParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // get charset\n    var charset = getCharset(req) || defaultCharset\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n","/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:urlencoded')\nvar deprecate = require('depd')('body-parser')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded\n\n/**\n * Cache of parser modules.\n */\n\nvar parsers = Object.create(null)\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction urlencoded (options) {\n  var opts = options || {}\n\n  // notice because option default will flip in next major\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option')\n  }\n\n  var extended = opts.extended !== false\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/x-www-form-urlencoded'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate query parser\n  var queryparse = extended\n    ? extendedparser(opts)\n    : simpleparser(opts)\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse (body) {\n    return body.length\n      ? queryparse(body)\n      : {}\n  }\n\n  return function urlencodedParser (req, res, next) {\n    if (req._body) {\n      debug('body already parsed')\n      next()\n      return\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body')\n      next()\n      return\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing')\n      next()\n      return\n    }\n\n    // assert charset\n    var charset = getCharset(req) || 'utf-8'\n    if (charset !== 'utf-8') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\nfunction extendedparser (options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('qs')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    var arrayLimit = Math.max(100, paramCount)\n\n    debug('parse extended urlencoding')\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    })\n  }\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset (req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\nfunction parameterCount (body, limit) {\n  var count = 0\n  var index = 0\n\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++\n    index++\n\n    if (count === limit) {\n      return undefined\n    }\n  }\n\n  return count\n}\n\n/**\n * Get parser for module name dynamically.\n *\n * @param {string} name\n * @return {function}\n * @api private\n */\n\nfunction parser (name) {\n  var mod = parsers[name]\n\n  if (mod !== undefined) {\n    return mod.parse\n  }\n\n  // this uses a switch for static require analysis\n  switch (name) {\n    case 'qs':\n      mod = require('qs')\n      break\n    case 'querystring':\n      mod = require('querystring')\n      break\n  }\n\n  // store to prevent invoking require()\n  parsers[name] = mod\n\n  return mod.parse\n}\n\n/**\n * Get the simple query parser.\n *\n * @param {object} options\n */\n\nfunction simpleparser (options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('querystring')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse (body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters', {\n        type: 'parameters.too.many'\n      })\n    }\n\n    debug('parse urlencoding')\n    return parse(body, undefined, undefined, {maxKeys: parameterLimit})\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker (type) {\n  return function checkType (req) {\n    return Boolean(typeis(req, type))\n  }\n}\n","/*!\n * merge-descriptors\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = merge\n\n/**\n * Module variables.\n * @private\n */\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty\n\n/**\n * Merge the property descriptors of `src` into `dest`\n *\n * @param {object} dest Object to add descriptors to\n * @param {object} src Object to clone descriptors from\n * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties\n * @returns {object} Reference to dest\n * @public\n */\n\nfunction merge(dest, src, redefine) {\n  if (!dest) {\n    throw new TypeError('argument dest is required')\n  }\n\n  if (!src) {\n    throw new TypeError('argument src is required')\n  }\n\n  if (redefine === undefined) {\n    // Default to true\n    redefine = true\n  }\n\n  Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {\n    if (!redefine && hasOwnProperty.call(dest, name)) {\n      // Skip desriptor\n      return\n    }\n\n    // Copy descriptor\n    var descriptor = Object.getOwnPropertyDescriptor(src, name)\n    Object.defineProperty(dest, name, descriptor)\n  })\n\n  return dest\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar finalhandler = require('finalhandler');\nvar Router = require('./router');\nvar methods = require('methods');\nvar middleware = require('./middleware/init');\nvar query = require('./middleware/query');\nvar debug = require('debug')('express:application');\nvar View = require('./view');\nvar http = require('http');\nvar compileETag = require('./utils').compileETag;\nvar compileQueryParser = require('./utils').compileQueryParser;\nvar compileTrust = require('./utils').compileTrust;\nvar deprecate = require('depd')('express');\nvar flatten = require('array-flatten');\nvar merge = require('utils-merge');\nvar resolve = require('path').resolve;\nvar setPrototypeOf = require('setprototypeof')\nvar slice = Array.prototype.slice;\n\n/**\n * Application prototype.\n */\n\nvar app = exports = module.exports = {};\n\n/**\n * Variable for trust proxy inheritance back-compat\n * @private\n */\n\nvar trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';\n\n/**\n * Initialize the server.\n *\n *   - setup default configuration\n *   - setup default middleware\n *   - setup route reflection methods\n *\n * @private\n */\n\napp.init = function init() {\n  this.cache = {};\n  this.engines = {};\n  this.settings = {};\n\n  this.defaultConfiguration();\n};\n\n/**\n * Initialize application configuration.\n * @private\n */\n\napp.defaultConfiguration = function defaultConfiguration() {\n  var env = process.env.NODE_ENV || 'development';\n\n  // default settings\n  this.enable('x-powered-by');\n  this.set('etag', 'weak');\n  this.set('env', env);\n  this.set('query parser', 'extended');\n  this.set('subdomain offset', 2);\n  this.set('trust proxy', false);\n\n  // trust proxy inherit back-compat\n  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {\n    configurable: true,\n    value: true\n  });\n\n  debug('booting in %s mode', env);\n\n  this.on('mount', function onmount(parent) {\n    // inherit trust proxy\n    if (this.settings[trustProxyDefaultSymbol] === true\n      && typeof parent.settings['trust proxy fn'] === 'function') {\n      delete this.settings['trust proxy'];\n      delete this.settings['trust proxy fn'];\n    }\n\n    // inherit protos\n    setPrototypeOf(this.request, parent.request)\n    setPrototypeOf(this.response, parent.response)\n    setPrototypeOf(this.engines, parent.engines)\n    setPrototypeOf(this.settings, parent.settings)\n  });\n\n  // setup locals\n  this.locals = Object.create(null);\n\n  // top-most app is mounted at /\n  this.mountpath = '/';\n\n  // default locals\n  this.locals.settings = this.settings;\n\n  // default configuration\n  this.set('view', View);\n  this.set('views', resolve('views'));\n  this.set('jsonp callback name', 'callback');\n\n  if (env === 'production') {\n    this.enable('view cache');\n  }\n\n  Object.defineProperty(this, 'router', {\n    get: function() {\n      throw new Error('\\'app.router\\' is deprecated!\\nPlease see the 3.x to 4.x migration guide for details on how to update your app.');\n    }\n  });\n};\n\n/**\n * lazily adds the base router if it has not yet been added.\n *\n * We cannot add the base router in the defaultConfiguration because\n * it reads app settings which might be set after that has run.\n *\n * @private\n */\napp.lazyrouter = function lazyrouter() {\n  if (!this._router) {\n    this._router = new Router({\n      caseSensitive: this.enabled('case sensitive routing'),\n      strict: this.enabled('strict routing')\n    });\n\n    this._router.use(query(this.get('query parser fn')));\n    this._router.use(middleware.init(this));\n  }\n};\n\n/**\n * Dispatch a req, res pair into the application. Starts pipeline processing.\n *\n * If no callback is provided, then default error handlers will respond\n * in the event of an error bubbling through the stack.\n *\n * @private\n */\n\napp.handle = function handle(req, res, callback) {\n  var router = this._router;\n\n  // final handler\n  var done = callback || finalhandler(req, res, {\n    env: this.get('env'),\n    onerror: logerror.bind(this)\n  });\n\n  // no routes\n  if (!router) {\n    debug('no routes defined on app');\n    done();\n    return;\n  }\n\n  router.handle(req, res, done);\n};\n\n/**\n * Proxy `Router#use()` to add middleware to the app router.\n * See Router#use() documentation for details.\n *\n * If the _fn_ parameter is an express app, then it will be\n * mounted at the _route_ specified.\n *\n * @public\n */\n\napp.use = function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }\n\n    // first arg is the path\n    if (typeof arg !== 'function') {\n      offset = 1;\n      path = fn;\n    }\n  }\n\n  var fns = flatten(slice.call(arguments, offset));\n\n  if (fns.length === 0) {\n    throw new TypeError('app.use() requires a middleware function')\n  }\n\n  // setup router\n  this.lazyrouter();\n  var router = this._router;\n\n  fns.forEach(function (fn) {\n    // non-express app\n    if (!fn || !fn.handle || !fn.set) {\n      return router.use(path, fn);\n    }\n\n    debug('.use app under %s', path);\n    fn.mountpath = path;\n    fn.parent = this;\n\n    // restore .app property on req and res\n    router.use(path, function mounted_app(req, res, next) {\n      var orig = req.app;\n      fn.handle(req, res, function (err) {\n        setPrototypeOf(req, orig.request)\n        setPrototypeOf(res, orig.response)\n        next(err);\n      });\n    });\n\n    // mounted an app\n    fn.emit('mount', this);\n  }, this);\n\n  return this;\n};\n\n/**\n * Proxy to the app `Router#route()`\n * Returns a new `Route` instance for the _path_.\n *\n * Routes are isolated middleware stacks for specific paths.\n * See the Route api docs for details.\n *\n * @public\n */\n\napp.route = function route(path) {\n  this.lazyrouter();\n  return this._router.route(path);\n};\n\n/**\n * Register the given template engine callback `fn`\n * as `ext`.\n *\n * By default will `require()` the engine based on the\n * file extension. For example if you try to render\n * a \"foo.ejs\" file Express will invoke the following internally:\n *\n *     app.engine('ejs', require('ejs').__express);\n *\n * For engines that do not provide `.__express` out of the box,\n * or if you wish to \"map\" a different extension to the template engine\n * you may use this method. For example mapping the EJS template engine to\n * \".html\" files:\n *\n *     app.engine('html', require('ejs').renderFile);\n *\n * In this case EJS provides a `.renderFile()` method with\n * the same signature that Express expects: `(path, options, callback)`,\n * though note that it aliases this method as `ejs.__express` internally\n * so if you're using \".ejs\" extensions you dont need to do anything.\n *\n * Some template engines do not follow this convention, the\n * [Consolidate.js](https://github.com/tj/consolidate.js)\n * library was created to map all of node's popular template\n * engines to follow this convention, thus allowing them to\n * work seamlessly within Express.\n *\n * @param {String} ext\n * @param {Function} fn\n * @return {app} for chaining\n * @public\n */\n\napp.engine = function engine(ext, fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('callback function required');\n  }\n\n  // get file extension\n  var extension = ext[0] !== '.'\n    ? '.' + ext\n    : ext;\n\n  // store engine\n  this.engines[extension] = fn;\n\n  return this;\n};\n\n/**\n * Proxy to `Router#param()` with one added api feature. The _name_ parameter\n * can be an array of names.\n *\n * See the Router#param() docs for more details.\n *\n * @param {String|Array} name\n * @param {Function} fn\n * @return {app} for chaining\n * @public\n */\n\napp.param = function param(name, fn) {\n  this.lazyrouter();\n\n  if (Array.isArray(name)) {\n    for (var i = 0; i < name.length; i++) {\n      this.param(name[i], fn);\n    }\n\n    return this;\n  }\n\n  this._router.param(name, fn);\n\n  return this;\n};\n\n/**\n * Assign `setting` to `val`, or return `setting`'s value.\n *\n *    app.set('foo', 'bar');\n *    app.set('foo');\n *    // => \"bar\"\n *\n * Mounted servers inherit their parent server's settings.\n *\n * @param {String} setting\n * @param {*} [val]\n * @return {Server} for chaining\n * @public\n */\n\napp.set = function set(setting, val) {\n  if (arguments.length === 1) {\n    // app.get(setting)\n    return this.settings[setting];\n  }\n\n  debug('set \"%s\" to %o', setting, val);\n\n  // set value\n  this.settings[setting] = val;\n\n  // trigger matched settings\n  switch (setting) {\n    case 'etag':\n      this.set('etag fn', compileETag(val));\n      break;\n    case 'query parser':\n      this.set('query parser fn', compileQueryParser(val));\n      break;\n    case 'trust proxy':\n      this.set('trust proxy fn', compileTrust(val));\n\n      // trust proxy inherit back-compat\n      Object.defineProperty(this.settings, trustProxyDefaultSymbol, {\n        configurable: true,\n        value: false\n      });\n\n      break;\n  }\n\n  return this;\n};\n\n/**\n * Return the app's absolute pathname\n * based on the parent(s) that have\n * mounted it.\n *\n * For example if the application was\n * mounted as \"/admin\", which itself\n * was mounted as \"/blog\" then the\n * return value would be \"/blog/admin\".\n *\n * @return {String}\n * @private\n */\n\napp.path = function path() {\n  return this.parent\n    ? this.parent.path() + this.mountpath\n    : '';\n};\n\n/**\n * Check if `setting` is enabled (truthy).\n *\n *    app.enabled('foo')\n *    // => false\n *\n *    app.enable('foo')\n *    app.enabled('foo')\n *    // => true\n *\n * @param {String} setting\n * @return {Boolean}\n * @public\n */\n\napp.enabled = function enabled(setting) {\n  return Boolean(this.set(setting));\n};\n\n/**\n * Check if `setting` is disabled.\n *\n *    app.disabled('foo')\n *    // => true\n *\n *    app.enable('foo')\n *    app.disabled('foo')\n *    // => false\n *\n * @param {String} setting\n * @return {Boolean}\n * @public\n */\n\napp.disabled = function disabled(setting) {\n  return !this.set(setting);\n};\n\n/**\n * Enable `setting`.\n *\n * @param {String} setting\n * @return {app} for chaining\n * @public\n */\n\napp.enable = function enable(setting) {\n  return this.set(setting, true);\n};\n\n/**\n * Disable `setting`.\n *\n * @param {String} setting\n * @return {app} for chaining\n * @public\n */\n\napp.disable = function disable(setting) {\n  return this.set(setting, false);\n};\n\n/**\n * Delegate `.VERB(...)` calls to `router.VERB(...)`.\n */\n\nmethods.forEach(function(method){\n  app[method] = function(path){\n    if (method === 'get' && arguments.length === 1) {\n      // app.get(setting)\n      return this.set(path);\n    }\n\n    this.lazyrouter();\n\n    var route = this._router.route(path);\n    route[method].apply(route, slice.call(arguments, 1));\n    return this;\n  };\n});\n\n/**\n * Special-cased \"all\" method, applying the given route `path`,\n * middleware, and callback to _every_ HTTP method.\n *\n * @param {String} path\n * @param {Function} ...\n * @return {app} for chaining\n * @public\n */\n\napp.all = function all(path) {\n  this.lazyrouter();\n\n  var route = this._router.route(path);\n  var args = slice.call(arguments, 1);\n\n  for (var i = 0; i < methods.length; i++) {\n    route[methods[i]].apply(route, args);\n  }\n\n  return this;\n};\n\n// del -> delete alias\n\napp.del = deprecate.function(app.delete, 'app.del: Use app.delete instead');\n\n/**\n * Render the given view `name` name with `options`\n * and a callback accepting an error and the\n * rendered template string.\n *\n * Example:\n *\n *    app.render('email', { name: 'Tobi' }, function(err, html){\n *      // ...\n *    })\n *\n * @param {String} name\n * @param {Object|Function} options or fn\n * @param {Function} callback\n * @public\n */\n\napp.render = function render(name, options, callback) {\n  var cache = this.cache;\n  var done = callback;\n  var engines = this.engines;\n  var opts = options;\n  var renderOptions = {};\n  var view;\n\n  // support callback function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  // merge app.locals\n  merge(renderOptions, this.locals);\n\n  // merge options._locals\n  if (opts._locals) {\n    merge(renderOptions, opts._locals);\n  }\n\n  // merge options\n  merge(renderOptions, opts);\n\n  // set .cache unless explicitly provided\n  if (renderOptions.cache == null) {\n    renderOptions.cache = this.enabled('view cache');\n  }\n\n  // primed cache\n  if (renderOptions.cache) {\n    view = cache[name];\n  }\n\n  // view\n  if (!view) {\n    var View = this.get('view');\n\n    view = new View(name, {\n      defaultEngine: this.get('view engine'),\n      root: this.get('views'),\n      engines: engines\n    });\n\n    if (!view.path) {\n      var dirs = Array.isArray(view.root) && view.root.length > 1\n        ? 'directories \"' + view.root.slice(0, -1).join('\", \"') + '\" or \"' + view.root[view.root.length - 1] + '\"'\n        : 'directory \"' + view.root + '\"'\n      var err = new Error('Failed to lookup view \"' + name + '\" in views ' + dirs);\n      err.view = view;\n      return done(err);\n    }\n\n    // prime the cache\n    if (renderOptions.cache) {\n      cache[name] = view;\n    }\n  }\n\n  // render\n  tryRender(view, renderOptions, done);\n};\n\n/**\n * Listen for connections.\n *\n * A node `http.Server` is returned, with this\n * application (which is a `Function`) as its\n * callback. If you wish to create both an HTTP\n * and HTTPS server you may do so with the \"http\"\n * and \"https\" modules as shown here:\n *\n *    var http = require('http')\n *      , https = require('https')\n *      , express = require('express')\n *      , app = express();\n *\n *    http.createServer(app).listen(80);\n *    https.createServer({ ... }, app).listen(443);\n *\n * @return {http.Server}\n * @public\n */\n\napp.listen = function listen() {\n  var server = http.createServer(this);\n  return server.listen.apply(server, arguments);\n};\n\n/**\n * Log error using console.error.\n *\n * @param {Error} err\n * @private\n */\n\nfunction logerror(err) {\n  /* istanbul ignore next */\n  if (this.get('env') !== 'test') console.error(err.stack || err.toString());\n}\n\n/**\n * Try rendering a view.\n * @private\n */\n\nfunction tryRender(view, options, callback) {\n  try {\n    view.render(options, callback);\n  } catch (err) {\n    callback(err);\n  }\n}\n","/*!\n * finalhandler\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar debug = require('debug')('finalhandler')\nvar encodeUrl = require('encodeurl')\nvar escapeHtml = require('escape-html')\nvar onFinished = require('on-finished')\nvar parseUrl = require('parseurl')\nvar statuses = require('statuses')\nvar unpipe = require('unpipe')\n\n/**\n * Module variables.\n * @private\n */\n\nvar DOUBLE_SPACE_REGEXP = /\\x20{2}/g\nvar NEWLINE_REGEXP = /\\n/g\n\n/* istanbul ignore next */\nvar defer = typeof setImmediate === 'function'\n  ? setImmediate\n  : function (fn) { process.nextTick(fn.bind.apply(fn, arguments)) }\nvar isFinished = onFinished.isFinished\n\n/**\n * Create a minimal HTML document.\n *\n * @param {string} message\n * @private\n */\n\nfunction createHtmlDocument (message) {\n  var body = escapeHtml(message)\n    .replace(NEWLINE_REGEXP, '<br>')\n    .replace(DOUBLE_SPACE_REGEXP, ' &nbsp;')\n\n  return '<!DOCTYPE html>\\n' +\n    '<html lang=\"en\">\\n' +\n    '<head>\\n' +\n    '<meta charset=\"utf-8\">\\n' +\n    '<title>Error</title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '<pre>' + body + '</pre>\\n' +\n    '</body>\\n' +\n    '</html>\\n'\n}\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = finalhandler\n\n/**\n * Create a function to handle the final response.\n *\n * @param {Request} req\n * @param {Response} res\n * @param {Object} [options]\n * @return {Function}\n * @public\n */\n\nfunction finalhandler (req, res, options) {\n  var opts = options || {}\n\n  // get environment\n  var env = opts.env || process.env.NODE_ENV || 'development'\n\n  // get error callback\n  var onerror = opts.onerror\n\n  return function (err) {\n    var headers\n    var msg\n    var status\n\n    // ignore 404 on in-flight response\n    if (!err && headersSent(res)) {\n      debug('cannot 404 after headers sent')\n      return\n    }\n\n    // unhandled error\n    if (err) {\n      // respect status code from error\n      status = getErrorStatusCode(err)\n\n      if (status === undefined) {\n        // fallback to status code on response\n        status = getResponseStatusCode(res)\n      } else {\n        // respect headers from error\n        headers = getErrorHeaders(err)\n      }\n\n      // get error message\n      msg = getErrorMessage(err, status, env)\n    } else {\n      // not found\n      status = 404\n      msg = 'Cannot ' + req.method + ' ' + encodeUrl(getResourceName(req))\n    }\n\n    debug('default %s', status)\n\n    // schedule onerror callback\n    if (err && onerror) {\n      defer(onerror, err, req, res)\n    }\n\n    // cannot actually respond\n    if (headersSent(res)) {\n      debug('cannot %d after headers sent', status)\n      req.socket.destroy()\n      return\n    }\n\n    // send response\n    send(req, res, status, headers, msg)\n  }\n}\n\n/**\n * Get headers from Error object.\n *\n * @param {Error} err\n * @return {object}\n * @private\n */\n\nfunction getErrorHeaders (err) {\n  if (!err.headers || typeof err.headers !== 'object') {\n    return undefined\n  }\n\n  var headers = Object.create(null)\n  var keys = Object.keys(err.headers)\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    headers[key] = err.headers[key]\n  }\n\n  return headers\n}\n\n/**\n * Get message from Error object, fallback to status message.\n *\n * @param {Error} err\n * @param {number} status\n * @param {string} env\n * @return {string}\n * @private\n */\n\nfunction getErrorMessage (err, status, env) {\n  var msg\n\n  if (env !== 'production') {\n    // use err.stack, which typically includes err.message\n    msg = err.stack\n\n    // fallback to err.toString() when possible\n    if (!msg && typeof err.toString === 'function') {\n      msg = err.toString()\n    }\n  }\n\n  return msg || statuses[status]\n}\n\n/**\n * Get status code from Error object.\n *\n * @param {Error} err\n * @return {number}\n * @private\n */\n\nfunction getErrorStatusCode (err) {\n  // check err.status\n  if (typeof err.status === 'number' && err.status >= 400 && err.status < 600) {\n    return err.status\n  }\n\n  // check err.statusCode\n  if (typeof err.statusCode === 'number' && err.statusCode >= 400 && err.statusCode < 600) {\n    return err.statusCode\n  }\n\n  return undefined\n}\n\n/**\n * Get resource name for the request.\n *\n * This is typically just the original pathname of the request\n * but will fallback to \"resource\" is that cannot be determined.\n *\n * @param {IncomingMessage} req\n * @return {string}\n * @private\n */\n\nfunction getResourceName (req) {\n  try {\n    return parseUrl.original(req).pathname\n  } catch (e) {\n    return 'resource'\n  }\n}\n\n/**\n * Get status code from response.\n *\n * @param {OutgoingMessage} res\n * @return {number}\n * @private\n */\n\nfunction getResponseStatusCode (res) {\n  var status = res.statusCode\n\n  // default status code to 500 if outside valid range\n  if (typeof status !== 'number' || status < 400 || status > 599) {\n    status = 500\n  }\n\n  return status\n}\n\n/**\n * Determine if the response headers have been sent.\n *\n * @param {object} res\n * @returns {boolean}\n * @private\n */\n\nfunction headersSent (res) {\n  return typeof res.headersSent !== 'boolean'\n    ? Boolean(res._header)\n    : res.headersSent\n}\n\n/**\n * Send response.\n *\n * @param {IncomingMessage} req\n * @param {OutgoingMessage} res\n * @param {number} status\n * @param {object} headers\n * @param {string} message\n * @private\n */\n\nfunction send (req, res, status, headers, message) {\n  function write () {\n    // response body\n    var body = createHtmlDocument(message)\n\n    // response status\n    res.statusCode = status\n    res.statusMessage = statuses[status]\n\n    // response headers\n    setHeaders(res, headers)\n\n    // security headers\n    res.setHeader('Content-Security-Policy', \"default-src 'self'\")\n    res.setHeader('X-Content-Type-Options', 'nosniff')\n\n    // standard headers\n    res.setHeader('Content-Type', 'text/html; charset=utf-8')\n    res.setHeader('Content-Length', Buffer.byteLength(body, 'utf8'))\n\n    if (req.method === 'HEAD') {\n      res.end()\n      return\n    }\n\n    res.end(body, 'utf8')\n  }\n\n  if (isFinished(req)) {\n    write()\n    return\n  }\n\n  // unpipe everything from the request\n  unpipe(req)\n\n  // flush the request\n  onFinished(req, write)\n  req.resume()\n}\n\n/**\n * Set response headers from an object.\n *\n * @param {OutgoingMessage} res\n * @param {object} headers\n * @private\n */\n\nfunction setHeaders (res, headers) {\n  if (!headers) {\n    return\n  }\n\n  var keys = Object.keys(headers)\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    res.setHeader(key, headers[key])\n  }\n}\n","/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = require('./codes.json')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// status code to message map\nstatus.STATUS_CODES = codes\n\n// array of status codes\nstatus.codes = populateStatusesMap(status, codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Populate the statuses map for given codes.\n * @private\n */\n\nfunction populateStatusesMap (statuses, codes) {\n  var arr = []\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // Populate properties\n    statuses[status] = message\n    statuses[message] = status\n    statuses[message.toLowerCase()] = status\n\n    // Add to array\n    arr.push(status)\n  })\n\n  return arr\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    if (!status[code]) throw new Error('invalid status code: ' + code)\n    return code\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    if (!status[n]) throw new Error('invalid status code: ' + n)\n    return n\n  }\n\n  n = status[code.toLowerCase()]\n  if (!n) throw new Error('invalid status message: \"' + code + '\"')\n  return n\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar setPrototypeOf = require('setprototypeof')\n\n/**\n * Initialization middleware, exposing the\n * request and response to each other, as well\n * as defaulting the X-Powered-By header field.\n *\n * @param {Function} app\n * @return {Function}\n * @api private\n */\n\nexports.init = function(app){\n  return function expressInit(req, res, next){\n    if (app.enabled('x-powered-by')) res.setHeader('X-Powered-By', 'Express');\n    req.res = res;\n    res.req = req;\n    req.next = next;\n\n    setPrototypeOf(req, app.request)\n    setPrototypeOf(res, app.response)\n\n    res.locals = res.locals || Object.create(null);\n\n    next();\n  };\n};\n\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar debug = require('debug')('express:view');\nvar path = require('path');\nvar fs = require('fs');\n\n/**\n * Module variables.\n * @private\n */\n\nvar dirname = path.dirname;\nvar basename = path.basename;\nvar extname = path.extname;\nvar join = path.join;\nvar resolve = path.resolve;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = View;\n\n/**\n * Initialize a new `View` with the given `name`.\n *\n * Options:\n *\n *   - `defaultEngine` the default template engine name\n *   - `engines` template engine require() cache\n *   - `root` root path for view lookup\n *\n * @param {string} name\n * @param {object} options\n * @public\n */\n\nfunction View(name, options) {\n  var opts = options || {};\n\n  this.defaultEngine = opts.defaultEngine;\n  this.ext = extname(name);\n  this.name = name;\n  this.root = opts.root;\n\n  if (!this.ext && !this.defaultEngine) {\n    throw new Error('No default engine was specified and no extension was provided.');\n  }\n\n  var fileName = name;\n\n  if (!this.ext) {\n    // get extension from default engine name\n    this.ext = this.defaultEngine[0] !== '.'\n      ? '.' + this.defaultEngine\n      : this.defaultEngine;\n\n    fileName += this.ext;\n  }\n\n  if (!opts.engines[this.ext]) {\n    // load engine\n    var mod = this.ext.substr(1)\n    debug('require \"%s\"', mod)\n\n    // default engine export\n    var fn = require(mod).__express\n\n    if (typeof fn !== 'function') {\n      throw new Error('Module \"' + mod + '\" does not provide a view engine.')\n    }\n\n    opts.engines[this.ext] = fn\n  }\n\n  // store loaded engine\n  this.engine = opts.engines[this.ext];\n\n  // lookup path\n  this.path = this.lookup(fileName);\n}\n\n/**\n * Lookup view by the given `name`\n *\n * @param {string} name\n * @private\n */\n\nView.prototype.lookup = function lookup(name) {\n  var path;\n  var roots = [].concat(this.root);\n\n  debug('lookup \"%s\"', name);\n\n  for (var i = 0; i < roots.length && !path; i++) {\n    var root = roots[i];\n\n    // resolve the path\n    var loc = resolve(root, name);\n    var dir = dirname(loc);\n    var file = basename(loc);\n\n    // resolve the file\n    path = this.resolve(dir, file);\n  }\n\n  return path;\n};\n\n/**\n * Render with the given options.\n *\n * @param {object} options\n * @param {function} callback\n * @private\n */\n\nView.prototype.render = function render(options, callback) {\n  debug('render \"%s\"', this.path);\n  this.engine(this.path, options, callback);\n};\n\n/**\n * Resolve the file within the given directory.\n *\n * @param {string} dir\n * @param {string} file\n * @private\n */\n\nView.prototype.resolve = function resolve(dir, file) {\n  var ext = this.ext;\n\n  // <path>.<ext>\n  var path = join(dir, file);\n  var stat = tryStat(path);\n\n  if (stat && stat.isFile()) {\n    return path;\n  }\n\n  // <path>/index.<ext>\n  path = join(dir, basename(file, ext), 'index' + ext);\n  stat = tryStat(path);\n\n  if (stat && stat.isFile()) {\n    return path;\n  }\n};\n\n/**\n * Return a stat, maybe.\n *\n * @param {string} path\n * @return {fs.Stats}\n * @private\n */\n\nfunction tryStat(path) {\n  debug('stat \"%s\"', path);\n\n  try {\n    return fs.statSync(path);\n  } catch (e) {\n    return undefined;\n  }\n}\n","/*!\n * destroy\n * Copyright(c) 2014 Jonathan Ong\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar ReadStream = require('fs').ReadStream\nvar Stream = require('stream')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = destroy\n\n/**\n * Destroy a stream.\n *\n * @param {object} stream\n * @public\n */\n\nfunction destroy(stream) {\n  if (stream instanceof ReadStream) {\n    return destroyReadStream(stream)\n  }\n\n  if (!(stream instanceof Stream)) {\n    return stream\n  }\n\n  if (typeof stream.destroy === 'function') {\n    stream.destroy()\n  }\n\n  return stream\n}\n\n/**\n * Destroy a ReadStream.\n *\n * @param {object} stream\n * @private\n */\n\nfunction destroyReadStream(stream) {\n  stream.destroy()\n\n  if (typeof stream.close === 'function') {\n    // node.js core bug work-around\n    stream.on('open', onOpenClose)\n  }\n\n  return stream\n}\n\n/**\n * On open handler to close stream.\n * @private\n */\n\nfunction onOpenClose() {\n  if (typeof this.fd === 'number') {\n    // actually close down the fd\n    this.close()\n  }\n}\n","/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = require('./codes.json')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// status code to message map\nstatus.STATUS_CODES = codes\n\n// array of status codes\nstatus.codes = populateStatusesMap(status, codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Populate the statuses map for given codes.\n * @private\n */\n\nfunction populateStatusesMap (statuses, codes) {\n  var arr = []\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // Populate properties\n    statuses[status] = message\n    statuses[message] = status\n    statuses[message.toLowerCase()] = status\n\n    // Add to array\n    arr.push(status)\n  })\n\n  return arr\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    if (!status[code]) throw new Error('invalid status code: ' + code)\n    return code\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    if (!status[n]) throw new Error('invalid status code: ' + n)\n    return n\n  }\n\n  n = status[code.toLowerCase()]\n  if (!n) throw new Error('invalid status message: \"' + code + '\"')\n  return n\n}\n","/*!\n * forwarded\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = forwarded\n\n/**\n * Get all addresses in the request, using the `X-Forwarded-For` header.\n *\n * @param {object} req\n * @return {array}\n * @public\n */\n\nfunction forwarded (req) {\n  if (!req) {\n    throw new TypeError('argument req is required')\n  }\n\n  // simple header parsing\n  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '')\n  var socketAddr = req.connection.remoteAddress\n  var addrs = [socketAddr].concat(proxyAddrs)\n\n  // return all addresses\n  return addrs\n}\n\n/**\n * Parse the X-Forwarded-For header.\n *\n * @param {string} header\n * @private\n */\n\nfunction parse (header) {\n  var end = header.length\n  var list = []\n  var start = header.length\n\n  // gather addresses, backwards\n  for (var i = header.length - 1; i >= 0; i--) {\n    switch (header.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i\n        }\n        break\n      case 0x2c: /* , */\n        if (start !== end) {\n          list.push(header.substring(start, end))\n        }\n        start = end = i\n        break\n      default:\n        start = i\n        break\n    }\n  }\n\n  // final address\n  if (start !== end) {\n    list.push(header.substring(start, end))\n  }\n\n  return list\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2013 Roman Shtylman\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar accepts = require('accepts');\nvar deprecate = require('depd')('express');\nvar isIP = require('net').isIP;\nvar typeis = require('type-is');\nvar http = require('http');\nvar fresh = require('fresh');\nvar parseRange = require('range-parser');\nvar parse = require('parseurl');\nvar proxyaddr = require('proxy-addr');\n\n/**\n * Request prototype.\n * @public\n */\n\nvar req = Object.create(http.IncomingMessage.prototype)\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = req\n\n/**\n * Return request header.\n *\n * The `Referrer` header field is special-cased,\n * both `Referrer` and `Referer` are interchangeable.\n *\n * Examples:\n *\n *     req.get('Content-Type');\n *     // => \"text/plain\"\n *\n *     req.get('content-type');\n *     // => \"text/plain\"\n *\n *     req.get('Something');\n *     // => undefined\n *\n * Aliased as `req.header()`.\n *\n * @param {String} name\n * @return {String}\n * @public\n */\n\nreq.get =\nreq.header = function header(name) {\n  if (!name) {\n    throw new TypeError('name argument is required to req.get');\n  }\n\n  if (typeof name !== 'string') {\n    throw new TypeError('name must be a string to req.get');\n  }\n\n  var lc = name.toLowerCase();\n\n  switch (lc) {\n    case 'referer':\n    case 'referrer':\n      return this.headers.referrer\n        || this.headers.referer;\n    default:\n      return this.headers[lc];\n  }\n};\n\n/**\n * To do: update docs.\n *\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single MIME type string\n * such as \"application/json\", an extension name\n * such as \"json\", a comma-delimited list such as \"json, html, text/plain\",\n * an argument list such as `\"json\", \"html\", \"text/plain\"`,\n * or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given, the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     req.accepts('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     req.accepts('html');\n *     // => \"html\"\n *     req.accepts('text/html');\n *     // => \"text/html\"\n *     req.accepts('json, text');\n *     // => \"json\"\n *     req.accepts('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     req.accepts('image/png');\n *     req.accepts('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     req.accepts(['html', 'json']);\n *     req.accepts('html', 'json');\n *     req.accepts('html, json');\n *     // => \"json\"\n *\n * @param {String|Array} type(s)\n * @return {String|Array|Boolean}\n * @public\n */\n\nreq.accepts = function(){\n  var accept = accepts(this);\n  return accept.types.apply(accept, arguments);\n};\n\n/**\n * Check if the given `encoding`s are accepted.\n *\n * @param {String} ...encoding\n * @return {String|Array}\n * @public\n */\n\nreq.acceptsEncodings = function(){\n  var accept = accepts(this);\n  return accept.encodings.apply(accept, arguments);\n};\n\nreq.acceptsEncoding = deprecate.function(req.acceptsEncodings,\n  'req.acceptsEncoding: Use acceptsEncodings instead');\n\n/**\n * Check if the given `charset`s are acceptable,\n * otherwise you should respond with 406 \"Not Acceptable\".\n *\n * @param {String} ...charset\n * @return {String|Array}\n * @public\n */\n\nreq.acceptsCharsets = function(){\n  var accept = accepts(this);\n  return accept.charsets.apply(accept, arguments);\n};\n\nreq.acceptsCharset = deprecate.function(req.acceptsCharsets,\n  'req.acceptsCharset: Use acceptsCharsets instead');\n\n/**\n * Check if the given `lang`s are acceptable,\n * otherwise you should respond with 406 \"Not Acceptable\".\n *\n * @param {String} ...lang\n * @return {String|Array}\n * @public\n */\n\nreq.acceptsLanguages = function(){\n  var accept = accepts(this);\n  return accept.languages.apply(accept, arguments);\n};\n\nreq.acceptsLanguage = deprecate.function(req.acceptsLanguages,\n  'req.acceptsLanguage: Use acceptsLanguages instead');\n\n/**\n * Parse Range header field, capping to the given `size`.\n *\n * Unspecified ranges such as \"0-\" require knowledge of your resource length. In\n * the case of a byte range this is of course the total number of bytes. If the\n * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,\n * and `-2` when syntactically invalid.\n *\n * When ranges are returned, the array has a \"type\" property which is the type of\n * range that is required (most commonly, \"bytes\"). Each array element is an object\n * with a \"start\" and \"end\" property for the portion of the range.\n *\n * The \"combine\" option can be set to `true` and overlapping & adjacent ranges\n * will be combined into a single range.\n *\n * NOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\n * should respond with 4 users when available, not 3.\n *\n * @param {number} size\n * @param {object} [options]\n * @param {boolean} [options.combine=false]\n * @return {number|array}\n * @public\n */\n\nreq.range = function range(size, options) {\n  var range = this.get('Range');\n  if (!range) return;\n  return parseRange(size, range, options);\n};\n\n/**\n * Return the value of param `name` when present or `defaultValue`.\n *\n *  - Checks route placeholders, ex: _/user/:id_\n *  - Checks body params, ex: id=12, {\"id\":12}\n *  - Checks query string params, ex: ?id=12\n *\n * To utilize request bodies, `req.body`\n * should be an object. This can be done by using\n * the `bodyParser()` middleware.\n *\n * @param {String} name\n * @param {Mixed} [defaultValue]\n * @return {String}\n * @public\n */\n\nreq.param = function param(name, defaultValue) {\n  var params = this.params || {};\n  var body = this.body || {};\n  var query = this.query || {};\n\n  var args = arguments.length === 1\n    ? 'name'\n    : 'name, default';\n  deprecate('req.param(' + args + '): Use req.params, req.body, or req.query instead');\n\n  if (null != params[name] && params.hasOwnProperty(name)) return params[name];\n  if (null != body[name]) return body[name];\n  if (null != query[name]) return query[name];\n\n  return defaultValue;\n};\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains the give mime `type`.\n *\n * Examples:\n *\n *      // With Content-Type: text/html; charset=utf-8\n *      req.is('html');\n *      req.is('text/html');\n *      req.is('text/*');\n *      // => true\n *\n *      // When Content-Type is application/json\n *      req.is('json');\n *      req.is('application/json');\n *      req.is('application/*');\n *      // => true\n *\n *      req.is('html');\n *      // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nreq.is = function is(types) {\n  var arr = types;\n\n  // support flattened arguments\n  if (!Array.isArray(types)) {\n    arr = new Array(arguments.length);\n    for (var i = 0; i < arr.length; i++) {\n      arr[i] = arguments[i];\n    }\n  }\n\n  return typeis(this, arr);\n};\n\n/**\n * Return the protocol string \"http\" or \"https\"\n * when requested with TLS. When the \"trust proxy\"\n * setting trusts the socket address, the\n * \"X-Forwarded-Proto\" header field will be trusted\n * and used if present.\n *\n * If you're running behind a reverse proxy that\n * supplies https for you this may be enabled.\n *\n * @return {String}\n * @public\n */\n\ndefineGetter(req, 'protocol', function protocol(){\n  var proto = this.connection.encrypted\n    ? 'https'\n    : 'http';\n  var trust = this.app.get('trust proxy fn');\n\n  if (!trust(this.connection.remoteAddress, 0)) {\n    return proto;\n  }\n\n  // Note: X-Forwarded-Proto is normally only ever a\n  //       single value, but this is to be safe.\n  var header = this.get('X-Forwarded-Proto') || proto\n  var index = header.indexOf(',')\n\n  return index !== -1\n    ? header.substring(0, index).trim()\n    : header.trim()\n});\n\n/**\n * Short-hand for:\n *\n *    req.protocol === 'https'\n *\n * @return {Boolean}\n * @public\n */\n\ndefineGetter(req, 'secure', function secure(){\n  return this.protocol === 'https';\n});\n\n/**\n * Return the remote address from the trusted proxy.\n *\n * The is the remote address on the socket unless\n * \"trust proxy\" is set.\n *\n * @return {String}\n * @public\n */\n\ndefineGetter(req, 'ip', function ip(){\n  var trust = this.app.get('trust proxy fn');\n  return proxyaddr(this, trust);\n});\n\n/**\n * When \"trust proxy\" is set, trusted proxy addresses + client.\n *\n * For example if the value were \"client, proxy1, proxy2\"\n * you would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\n * where \"proxy2\" is the furthest down-stream and \"proxy1\" and\n * \"proxy2\" were trusted.\n *\n * @return {Array}\n * @public\n */\n\ndefineGetter(req, 'ips', function ips() {\n  var trust = this.app.get('trust proxy fn');\n  var addrs = proxyaddr.all(this, trust);\n\n  // reverse the order (to farthest -> closest)\n  // and remove socket address\n  addrs.reverse().pop()\n\n  return addrs\n});\n\n/**\n * Return subdomains as an array.\n *\n * Subdomains are the dot-separated parts of the host before the main domain of\n * the app. By default, the domain of the app is assumed to be the last two\n * parts of the host. This can be changed by setting \"subdomain offset\".\n *\n * For example, if the domain is \"tobi.ferrets.example.com\":\n * If \"subdomain offset\" is not set, req.subdomains is `[\"ferrets\", \"tobi\"]`.\n * If \"subdomain offset\" is 3, req.subdomains is `[\"tobi\"]`.\n *\n * @return {Array}\n * @public\n */\n\ndefineGetter(req, 'subdomains', function subdomains() {\n  var hostname = this.hostname;\n\n  if (!hostname) return [];\n\n  var offset = this.app.get('subdomain offset');\n  var subdomains = !isIP(hostname)\n    ? hostname.split('.').reverse()\n    : [hostname];\n\n  return subdomains.slice(offset);\n});\n\n/**\n * Short-hand for `url.parse(req.url).pathname`.\n *\n * @return {String}\n * @public\n */\n\ndefineGetter(req, 'path', function path() {\n  return parse(this).pathname;\n});\n\n/**\n * Parse the \"Host\" header field to a hostname.\n *\n * When the \"trust proxy\" setting trusts the socket\n * address, the \"X-Forwarded-Host\" header field will\n * be trusted.\n *\n * @return {String}\n * @public\n */\n\ndefineGetter(req, 'hostname', function hostname(){\n  var trust = this.app.get('trust proxy fn');\n  var host = this.get('X-Forwarded-Host');\n\n  if (!host || !trust(this.connection.remoteAddress, 0)) {\n    host = this.get('Host');\n  }\n\n  if (!host) return;\n\n  // IPv6 literal support\n  var offset = host[0] === '['\n    ? host.indexOf(']') + 1\n    : 0;\n  var index = host.indexOf(':', offset);\n\n  return index !== -1\n    ? host.substring(0, index)\n    : host;\n});\n\n// TODO: change req.host to return host in next major\n\ndefineGetter(req, 'host', deprecate.function(function host(){\n  return this.hostname;\n}, 'req.host: Use req.hostname instead'));\n\n/**\n * Check if the request is fresh, aka\n * Last-Modified and/or the ETag\n * still match.\n *\n * @return {Boolean}\n * @public\n */\n\ndefineGetter(req, 'fresh', function(){\n  var method = this.method;\n  var res = this.res\n  var status = res.statusCode\n\n  // GET or HEAD for weak freshness validation only\n  if ('GET' !== method && 'HEAD' !== method) return false;\n\n  // 2xx or 304 as per rfc2616 14.26\n  if ((status >= 200 && status < 300) || 304 === status) {\n    return fresh(this.headers, {\n      'etag': res.get('ETag'),\n      'last-modified': res.get('Last-Modified')\n    })\n  }\n\n  return false;\n});\n\n/**\n * Check if the request is stale, aka\n * \"Last-Modified\" and / or the \"ETag\" for the\n * resource has changed.\n *\n * @return {Boolean}\n * @public\n */\n\ndefineGetter(req, 'stale', function stale(){\n  return !this.fresh;\n});\n\n/**\n * Check if the request was an _XMLHttpRequest_.\n *\n * @return {Boolean}\n * @public\n */\n\ndefineGetter(req, 'xhr', function xhr(){\n  var val = this.get('X-Requested-With') || '';\n  return val.toLowerCase() === 'xmlhttprequest';\n});\n\n/**\n * Helper function for creating a getter on an object.\n *\n * @param {Object} obj\n * @param {String} name\n * @param {Function} getter\n * @private\n */\nfunction defineGetter(obj, name, getter) {\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: true,\n    get: getter\n  });\n}\n","/*!\n * accepts\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Negotiator = require('negotiator')\nvar mime = require('mime-types')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Accepts\n\n/**\n * Create a new Accepts object for the given req.\n *\n * @param {object} req\n * @public\n */\n\nfunction Accepts (req) {\n  if (!(this instanceof Accepts)) {\n    return new Accepts(req)\n  }\n\n  this.headers = req.headers\n  this.negotiator = new Negotiator(req)\n}\n\n/**\n * Check if the given `type(s)` is acceptable, returning\n * the best match when true, otherwise `undefined`, in which\n * case you should respond with 406 \"Not Acceptable\".\n *\n * The `type` value may be a single mime type string\n * such as \"application/json\", the extension name\n * such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list\n * or array is given the _best_ match, if any is returned.\n *\n * Examples:\n *\n *     // Accept: text/html\n *     this.types('html');\n *     // => \"html\"\n *\n *     // Accept: text/*, application/json\n *     this.types('html');\n *     // => \"html\"\n *     this.types('text/html');\n *     // => \"text/html\"\n *     this.types('json', 'text');\n *     // => \"json\"\n *     this.types('application/json');\n *     // => \"application/json\"\n *\n *     // Accept: text/*, application/json\n *     this.types('image/png');\n *     this.types('png');\n *     // => undefined\n *\n *     // Accept: text/*;q=.5, application/json\n *     this.types(['html', 'json']);\n *     this.types('html', 'json');\n *     // => \"json\"\n *\n * @param {String|Array} types...\n * @return {String|Array|Boolean}\n * @public\n */\n\nAccepts.prototype.type =\nAccepts.prototype.types = function (types_) {\n  var types = types_\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length)\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i]\n    }\n  }\n\n  // no types, return all requested types\n  if (!types || types.length === 0) {\n    return this.negotiator.mediaTypes()\n  }\n\n  // no accept header, return first given type\n  if (!this.headers.accept) {\n    return types[0]\n  }\n\n  var mimes = types.map(extToMime)\n  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime))\n  var first = accepts[0]\n\n  return first\n    ? types[mimes.indexOf(first)]\n    : false\n}\n\n/**\n * Return accepted encodings or best fit based on `encodings`.\n *\n * Given `Accept-Encoding: gzip, deflate`\n * an array sorted by quality is returned:\n *\n *     ['gzip', 'deflate']\n *\n * @param {String|Array} encodings...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.encoding =\nAccepts.prototype.encodings = function (encodings_) {\n  var encodings = encodings_\n\n  // support flattened arguments\n  if (encodings && !Array.isArray(encodings)) {\n    encodings = new Array(arguments.length)\n    for (var i = 0; i < encodings.length; i++) {\n      encodings[i] = arguments[i]\n    }\n  }\n\n  // no encodings, return all requested encodings\n  if (!encodings || encodings.length === 0) {\n    return this.negotiator.encodings()\n  }\n\n  return this.negotiator.encodings(encodings)[0] || false\n}\n\n/**\n * Return accepted charsets or best fit based on `charsets`.\n *\n * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n * an array sorted by quality is returned:\n *\n *     ['utf-8', 'utf-7', 'iso-8859-1']\n *\n * @param {String|Array} charsets...\n * @return {String|Array}\n * @public\n */\n\nAccepts.prototype.charset =\nAccepts.prototype.charsets = function (charsets_) {\n  var charsets = charsets_\n\n  // support flattened arguments\n  if (charsets && !Array.isArray(charsets)) {\n    charsets = new Array(arguments.length)\n    for (var i = 0; i < charsets.length; i++) {\n      charsets[i] = arguments[i]\n    }\n  }\n\n  // no charsets, return all requested charsets\n  if (!charsets || charsets.length === 0) {\n    return this.negotiator.charsets()\n  }\n\n  return this.negotiator.charsets(charsets)[0] || false\n}\n\n/**\n * Return accepted languages or best fit based on `langs`.\n *\n * Given `Accept-Language: en;q=0.8, es, pt`\n * an array sorted by quality is returned:\n *\n *     ['es', 'pt', 'en']\n *\n * @param {String|Array} langs...\n * @return {Array|String}\n * @public\n */\n\nAccepts.prototype.lang =\nAccepts.prototype.langs =\nAccepts.prototype.language =\nAccepts.prototype.languages = function (languages_) {\n  var languages = languages_\n\n  // support flattened arguments\n  if (languages && !Array.isArray(languages)) {\n    languages = new Array(arguments.length)\n    for (var i = 0; i < languages.length; i++) {\n      languages[i] = arguments[i]\n    }\n  }\n\n  // no languages, return all requested languages\n  if (!languages || languages.length === 0) {\n    return this.negotiator.languages()\n  }\n\n  return this.negotiator.languages(languages)[0] || false\n}\n\n/**\n * Convert extnames to mime.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction extToMime (type) {\n  return type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type\n}\n\n/**\n * Check if mime is valid.\n *\n * @param {String} type\n * @return {String}\n * @private\n */\n\nfunction validMime (type) {\n  return typeof type === 'string'\n}\n","/*!\n * negotiator\n * Copyright(c) 2012 Federico Romero\n * Copyright(c) 2012-2014 Isaac Z. Schlueter\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Cached loaded submodules.\n * @private\n */\n\nvar modules = Object.create(null);\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = Negotiator;\nmodule.exports.Negotiator = Negotiator;\n\n/**\n * Create a Negotiator instance from a request.\n * @param {object} request\n * @public\n */\n\nfunction Negotiator(request) {\n  if (!(this instanceof Negotiator)) {\n    return new Negotiator(request);\n  }\n\n  this.request = request;\n}\n\nNegotiator.prototype.charset = function charset(available) {\n  var set = this.charsets(available);\n  return set && set[0];\n};\n\nNegotiator.prototype.charsets = function charsets(available) {\n  var preferredCharsets = loadModule('charset').preferredCharsets;\n  return preferredCharsets(this.request.headers['accept-charset'], available);\n};\n\nNegotiator.prototype.encoding = function encoding(available) {\n  var set = this.encodings(available);\n  return set && set[0];\n};\n\nNegotiator.prototype.encodings = function encodings(available) {\n  var preferredEncodings = loadModule('encoding').preferredEncodings;\n  return preferredEncodings(this.request.headers['accept-encoding'], available);\n};\n\nNegotiator.prototype.language = function language(available) {\n  var set = this.languages(available);\n  return set && set[0];\n};\n\nNegotiator.prototype.languages = function languages(available) {\n  var preferredLanguages = loadModule('language').preferredLanguages;\n  return preferredLanguages(this.request.headers['accept-language'], available);\n};\n\nNegotiator.prototype.mediaType = function mediaType(available) {\n  var set = this.mediaTypes(available);\n  return set && set[0];\n};\n\nNegotiator.prototype.mediaTypes = function mediaTypes(available) {\n  var preferredMediaTypes = loadModule('mediaType').preferredMediaTypes;\n  return preferredMediaTypes(this.request.headers.accept, available);\n};\n\n// Backwards compatibility\nNegotiator.prototype.preferredCharset = Negotiator.prototype.charset;\nNegotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;\nNegotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;\nNegotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;\nNegotiator.prototype.preferredLanguage = Negotiator.prototype.language;\nNegotiator.prototype.preferredLanguages = Negotiator.prototype.languages;\nNegotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;\nNegotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;\n\n/**\n * Load the given module.\n * @private\n */\n\nfunction loadModule(moduleName) {\n  var module = modules[moduleName];\n\n  if (module !== undefined) {\n    return module;\n  }\n\n  // This uses a switch for static require analysis\n  switch (moduleName) {\n    case 'charset':\n      module = require('./lib/charset');\n      break;\n    case 'encoding':\n      module = require('./lib/encoding');\n      break;\n    case 'language':\n      module = require('./lib/language');\n      break;\n    case 'mediaType':\n      module = require('./lib/mediaType');\n      break;\n    default:\n      throw new Error('Cannot find module \\'' + moduleName + '\\'');\n  }\n\n  // Store to prevent invoking require()\n  modules[moduleName] = module;\n\n  return module;\n}\n","/*!\n * express\n * Copyright(c) 2009-2013 TJ Holowaychuk\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar Buffer = require('safe-buffer').Buffer\nvar contentDisposition = require('content-disposition');\nvar deprecate = require('depd')('express');\nvar encodeUrl = require('encodeurl');\nvar escapeHtml = require('escape-html');\nvar http = require('http');\nvar isAbsolute = require('./utils').isAbsolute;\nvar onFinished = require('on-finished');\nvar path = require('path');\nvar statuses = require('statuses')\nvar merge = require('utils-merge');\nvar sign = require('cookie-signature').sign;\nvar normalizeType = require('./utils').normalizeType;\nvar normalizeTypes = require('./utils').normalizeTypes;\nvar setCharset = require('./utils').setCharset;\nvar cookie = require('cookie');\nvar send = require('send');\nvar extname = path.extname;\nvar mime = send.mime;\nvar resolve = path.resolve;\nvar vary = require('vary');\n\n/**\n * Response prototype.\n * @public\n */\n\nvar res = Object.create(http.ServerResponse.prototype)\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = res\n\n/**\n * Module variables.\n * @private\n */\n\nvar charsetRegExp = /;\\s*charset\\s*=/;\n\n/**\n * Set status `code`.\n *\n * @param {Number} code\n * @return {ServerResponse}\n * @public\n */\n\nres.status = function status(code) {\n  this.statusCode = code;\n  return this;\n};\n\n/**\n * Set Link header field with the given `links`.\n *\n * Examples:\n *\n *    res.links({\n *      next: 'http://api.example.com/users?page=2',\n *      last: 'http://api.example.com/users?page=5'\n *    });\n *\n * @param {Object} links\n * @return {ServerResponse}\n * @public\n */\n\nres.links = function(links){\n  var link = this.get('Link') || '';\n  if (link) link += ', ';\n  return this.set('Link', link + Object.keys(links).map(function(rel){\n    return '<' + links[rel] + '>; rel=\"' + rel + '\"';\n  }).join(', '));\n};\n\n/**\n * Send a response.\n *\n * Examples:\n *\n *     res.send(Buffer.from('wahoo'));\n *     res.send({ some: 'json' });\n *     res.send('<p>some html</p>');\n *\n * @param {string|number|boolean|object|Buffer} body\n * @public\n */\n\nres.send = function send(body) {\n  var chunk = body;\n  var encoding;\n  var req = this.req;\n  var type;\n\n  // settings\n  var app = this.app;\n\n  // allow status / body\n  if (arguments.length === 2) {\n    // res.send(body, status) backwards compat\n    if (typeof arguments[0] !== 'number' && typeof arguments[1] === 'number') {\n      deprecate('res.send(body, status): Use res.status(status).send(body) instead');\n      this.statusCode = arguments[1];\n    } else {\n      deprecate('res.send(status, body): Use res.status(status).send(body) instead');\n      this.statusCode = arguments[0];\n      chunk = arguments[1];\n    }\n  }\n\n  // disambiguate res.send(status) and res.send(status, num)\n  if (typeof chunk === 'number' && arguments.length === 1) {\n    // res.send(status) will set status message as text string\n    if (!this.get('Content-Type')) {\n      this.type('txt');\n    }\n\n    deprecate('res.send(status): Use res.sendStatus(status) instead');\n    this.statusCode = chunk;\n    chunk = statuses[chunk]\n  }\n\n  switch (typeof chunk) {\n    // string defaulting to html\n    case 'string':\n      if (!this.get('Content-Type')) {\n        this.type('html');\n      }\n      break;\n    case 'boolean':\n    case 'number':\n    case 'object':\n      if (chunk === null) {\n        chunk = '';\n      } else if (Buffer.isBuffer(chunk)) {\n        if (!this.get('Content-Type')) {\n          this.type('bin');\n        }\n      } else {\n        return this.json(chunk);\n      }\n      break;\n  }\n\n  // write strings in utf-8\n  if (typeof chunk === 'string') {\n    encoding = 'utf8';\n    type = this.get('Content-Type');\n\n    // reflect this in content-type\n    if (typeof type === 'string') {\n      this.set('Content-Type', setCharset(type, 'utf-8'));\n    }\n  }\n\n  // determine if ETag should be generated\n  var etagFn = app.get('etag fn')\n  var generateETag = !this.get('ETag') && typeof etagFn === 'function'\n\n  // populate Content-Length\n  var len\n  if (chunk !== undefined) {\n    if (Buffer.isBuffer(chunk)) {\n      // get length of Buffer\n      len = chunk.length\n    } else if (!generateETag && chunk.length < 1000) {\n      // just calculate length when no ETag + small chunk\n      len = Buffer.byteLength(chunk, encoding)\n    } else {\n      // convert chunk to Buffer and calculate\n      chunk = Buffer.from(chunk, encoding)\n      encoding = undefined;\n      len = chunk.length\n    }\n\n    this.set('Content-Length', len);\n  }\n\n  // populate ETag\n  var etag;\n  if (generateETag && len !== undefined) {\n    if ((etag = etagFn(chunk, encoding))) {\n      this.set('ETag', etag);\n    }\n  }\n\n  // freshness\n  if (req.fresh) this.statusCode = 304;\n\n  // strip irrelevant headers\n  if (204 === this.statusCode || 304 === this.statusCode) {\n    this.removeHeader('Content-Type');\n    this.removeHeader('Content-Length');\n    this.removeHeader('Transfer-Encoding');\n    chunk = '';\n  }\n\n  if (req.method === 'HEAD') {\n    // skip body for HEAD\n    this.end();\n  } else {\n    // respond\n    this.end(chunk, encoding);\n  }\n\n  return this;\n};\n\n/**\n * Send JSON response.\n *\n * Examples:\n *\n *     res.json(null);\n *     res.json({ user: 'tj' });\n *\n * @param {string|number|boolean|object} obj\n * @public\n */\n\nres.json = function json(obj) {\n  var val = obj;\n\n  // allow status / body\n  if (arguments.length === 2) {\n    // res.json(body, status) backwards compat\n    if (typeof arguments[1] === 'number') {\n      deprecate('res.json(obj, status): Use res.status(status).json(obj) instead');\n      this.statusCode = arguments[1];\n    } else {\n      deprecate('res.json(status, obj): Use res.status(status).json(obj) instead');\n      this.statusCode = arguments[0];\n      val = arguments[1];\n    }\n  }\n\n  // settings\n  var app = this.app;\n  var escape = app.get('json escape')\n  var replacer = app.get('json replacer');\n  var spaces = app.get('json spaces');\n  var body = stringify(val, replacer, spaces, escape)\n\n  // content-type\n  if (!this.get('Content-Type')) {\n    this.set('Content-Type', 'application/json');\n  }\n\n  return this.send(body);\n};\n\n/**\n * Send JSON response with JSONP callback support.\n *\n * Examples:\n *\n *     res.jsonp(null);\n *     res.jsonp({ user: 'tj' });\n *\n * @param {string|number|boolean|object} obj\n * @public\n */\n\nres.jsonp = function jsonp(obj) {\n  var val = obj;\n\n  // allow status / body\n  if (arguments.length === 2) {\n    // res.json(body, status) backwards compat\n    if (typeof arguments[1] === 'number') {\n      deprecate('res.jsonp(obj, status): Use res.status(status).json(obj) instead');\n      this.statusCode = arguments[1];\n    } else {\n      deprecate('res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead');\n      this.statusCode = arguments[0];\n      val = arguments[1];\n    }\n  }\n\n  // settings\n  var app = this.app;\n  var escape = app.get('json escape')\n  var replacer = app.get('json replacer');\n  var spaces = app.get('json spaces');\n  var body = stringify(val, replacer, spaces, escape)\n  var callback = this.req.query[app.get('jsonp callback name')];\n\n  // content-type\n  if (!this.get('Content-Type')) {\n    this.set('X-Content-Type-Options', 'nosniff');\n    this.set('Content-Type', 'application/json');\n  }\n\n  // fixup callback\n  if (Array.isArray(callback)) {\n    callback = callback[0];\n  }\n\n  // jsonp\n  if (typeof callback === 'string' && callback.length !== 0) {\n    this.set('X-Content-Type-Options', 'nosniff');\n    this.set('Content-Type', 'text/javascript');\n\n    // restrict callback charset\n    callback = callback.replace(/[^\\[\\]\\w$.]/g, '');\n\n    // replace chars not allowed in JavaScript that are in JSON\n    body = body\n      .replace(/\\u2028/g, '\\\\u2028')\n      .replace(/\\u2029/g, '\\\\u2029');\n\n    // the /**/ is a specific security mitigation for \"Rosetta Flash JSONP abuse\"\n    // the typeof check is just to reduce client error noise\n    body = '/**/ typeof ' + callback + ' === \\'function\\' && ' + callback + '(' + body + ');';\n  }\n\n  return this.send(body);\n};\n\n/**\n * Send given HTTP status code.\n *\n * Sets the response status to `statusCode` and the body of the\n * response to the standard description from node's http.STATUS_CODES\n * or the statusCode number if no description.\n *\n * Examples:\n *\n *     res.sendStatus(200);\n *\n * @param {number} statusCode\n * @public\n */\n\nres.sendStatus = function sendStatus(statusCode) {\n  var body = statuses[statusCode] || String(statusCode)\n\n  this.statusCode = statusCode;\n  this.type('txt');\n\n  return this.send(body);\n};\n\n/**\n * Transfer the file at the given `path`.\n *\n * Automatically sets the _Content-Type_ response header field.\n * The callback `callback(err)` is invoked when the transfer is complete\n * or when an error occurs. Be sure to check `res.sentHeader`\n * if you wish to attempt responding, as the header and some data\n * may have already been transferred.\n *\n * Options:\n *\n *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n *   - `root`     root directory for relative filenames\n *   - `headers`  object of headers to serve with file\n *   - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n *\n * Other options are passed along to `send`.\n *\n * Examples:\n *\n *  The following example illustrates how `res.sendFile()` may\n *  be used as an alternative for the `static()` middleware for\n *  dynamic situations. The code backing `res.sendFile()` is actually\n *  the same code, so HTTP cache support etc is identical.\n *\n *     app.get('/user/:uid/photos/:file', function(req, res){\n *       var uid = req.params.uid\n *         , file = req.params.file;\n *\n *       req.user.mayViewFilesFrom(uid, function(yes){\n *         if (yes) {\n *           res.sendFile('/uploads/' + uid + '/' + file);\n *         } else {\n *           res.send(403, 'Sorry! you cant see that.');\n *         }\n *       });\n *     });\n *\n * @public\n */\n\nres.sendFile = function sendFile(path, options, callback) {\n  var done = callback;\n  var req = this.req;\n  var res = this;\n  var next = req.next;\n  var opts = options || {};\n\n  if (!path) {\n    throw new TypeError('path argument is required to res.sendFile');\n  }\n\n  // support function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  if (!opts.root && !isAbsolute(path)) {\n    throw new TypeError('path must be absolute or specify root to res.sendFile');\n  }\n\n  // create file stream\n  var pathname = encodeURI(path);\n  var file = send(req, pathname, opts);\n\n  // transfer\n  sendfile(res, file, opts, function (err) {\n    if (done) return done(err);\n    if (err && err.code === 'EISDIR') return next();\n\n    // next() all but write errors\n    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {\n      next(err);\n    }\n  });\n};\n\n/**\n * Transfer the file at the given `path`.\n *\n * Automatically sets the _Content-Type_ response header field.\n * The callback `callback(err)` is invoked when the transfer is complete\n * or when an error occurs. Be sure to check `res.sentHeader`\n * if you wish to attempt responding, as the header and some data\n * may have already been transferred.\n *\n * Options:\n *\n *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n *   - `root`     root directory for relative filenames\n *   - `headers`  object of headers to serve with file\n *   - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n *\n * Other options are passed along to `send`.\n *\n * Examples:\n *\n *  The following example illustrates how `res.sendfile()` may\n *  be used as an alternative for the `static()` middleware for\n *  dynamic situations. The code backing `res.sendfile()` is actually\n *  the same code, so HTTP cache support etc is identical.\n *\n *     app.get('/user/:uid/photos/:file', function(req, res){\n *       var uid = req.params.uid\n *         , file = req.params.file;\n *\n *       req.user.mayViewFilesFrom(uid, function(yes){\n *         if (yes) {\n *           res.sendfile('/uploads/' + uid + '/' + file);\n *         } else {\n *           res.send(403, 'Sorry! you cant see that.');\n *         }\n *       });\n *     });\n *\n * @public\n */\n\nres.sendfile = function (path, options, callback) {\n  var done = callback;\n  var req = this.req;\n  var res = this;\n  var next = req.next;\n  var opts = options || {};\n\n  // support function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  // create file stream\n  var file = send(req, path, opts);\n\n  // transfer\n  sendfile(res, file, opts, function (err) {\n    if (done) return done(err);\n    if (err && err.code === 'EISDIR') return next();\n\n    // next() all but write errors\n    if (err && err.code !== 'ECONNABORTED' && err.syscall !== 'write') {\n      next(err);\n    }\n  });\n};\n\nres.sendfile = deprecate.function(res.sendfile,\n  'res.sendfile: Use res.sendFile instead');\n\n/**\n * Transfer the file at the given `path` as an attachment.\n *\n * Optionally providing an alternate attachment `filename`,\n * and optional callback `callback(err)`. The callback is invoked\n * when the data transfer is complete, or when an error has\n * ocurred. Be sure to check `res.headersSent` if you plan to respond.\n *\n * Optionally providing an `options` object to use with `res.sendFile()`.\n * This function will set the `Content-Disposition` header, overriding\n * any `Content-Disposition` header passed as header options in order\n * to set the attachment and filename.\n *\n * This method uses `res.sendFile()`.\n *\n * @public\n */\n\nres.download = function download (path, filename, options, callback) {\n  var done = callback;\n  var name = filename;\n  var opts = options || null\n\n  // support function as second or third arg\n  if (typeof filename === 'function') {\n    done = filename;\n    name = null;\n    opts = null\n  } else if (typeof options === 'function') {\n    done = options\n    opts = null\n  }\n\n  // set Content-Disposition when file is sent\n  var headers = {\n    'Content-Disposition': contentDisposition(name || path)\n  };\n\n  // merge user-provided headers\n  if (opts && opts.headers) {\n    var keys = Object.keys(opts.headers)\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]\n      if (key.toLowerCase() !== 'content-disposition') {\n        headers[key] = opts.headers[key]\n      }\n    }\n  }\n\n  // merge user-provided options\n  opts = Object.create(opts)\n  opts.headers = headers\n\n  // Resolve the full path for sendFile\n  var fullPath = resolve(path);\n\n  // send file\n  return this.sendFile(fullPath, opts, done)\n};\n\n/**\n * Set _Content-Type_ response header with `type` through `mime.lookup()`\n * when it does not contain \"/\", or set the Content-Type to `type` otherwise.\n *\n * Examples:\n *\n *     res.type('.html');\n *     res.type('html');\n *     res.type('json');\n *     res.type('application/json');\n *     res.type('png');\n *\n * @param {String} type\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.contentType =\nres.type = function contentType(type) {\n  var ct = type.indexOf('/') === -1\n    ? mime.lookup(type)\n    : type;\n\n  return this.set('Content-Type', ct);\n};\n\n/**\n * Respond to the Acceptable formats using an `obj`\n * of mime-type callbacks.\n *\n * This method uses `req.accepted`, an array of\n * acceptable types ordered by their quality values.\n * When \"Accept\" is not present the _first_ callback\n * is invoked, otherwise the first match is used. When\n * no match is performed the server responds with\n * 406 \"Not Acceptable\".\n *\n * Content-Type is set for you, however if you choose\n * you may alter this within the callback using `res.type()`\n * or `res.set('Content-Type', ...)`.\n *\n *    res.format({\n *      'text/plain': function(){\n *        res.send('hey');\n *      },\n *\n *      'text/html': function(){\n *        res.send('<p>hey</p>');\n *      },\n *\n *      'appliation/json': function(){\n *        res.send({ message: 'hey' });\n *      }\n *    });\n *\n * In addition to canonicalized MIME types you may\n * also use extnames mapped to these types:\n *\n *    res.format({\n *      text: function(){\n *        res.send('hey');\n *      },\n *\n *      html: function(){\n *        res.send('<p>hey</p>');\n *      },\n *\n *      json: function(){\n *        res.send({ message: 'hey' });\n *      }\n *    });\n *\n * By default Express passes an `Error`\n * with a `.status` of 406 to `next(err)`\n * if a match is not made. If you provide\n * a `.default` callback it will be invoked\n * instead.\n *\n * @param {Object} obj\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.format = function(obj){\n  var req = this.req;\n  var next = req.next;\n\n  var fn = obj.default;\n  if (fn) delete obj.default;\n  var keys = Object.keys(obj);\n\n  var key = keys.length > 0\n    ? req.accepts(keys)\n    : false;\n\n  this.vary(\"Accept\");\n\n  if (key) {\n    this.set('Content-Type', normalizeType(key).value);\n    obj[key](req, this, next);\n  } else if (fn) {\n    fn();\n  } else {\n    var err = new Error('Not Acceptable');\n    err.status = err.statusCode = 406;\n    err.types = normalizeTypes(keys).map(function(o){ return o.value });\n    next(err);\n  }\n\n  return this;\n};\n\n/**\n * Set _Content-Disposition_ header to _attachment_ with optional `filename`.\n *\n * @param {String} filename\n * @return {ServerResponse}\n * @public\n */\n\nres.attachment = function attachment(filename) {\n  if (filename) {\n    this.type(extname(filename));\n  }\n\n  this.set('Content-Disposition', contentDisposition(filename));\n\n  return this;\n};\n\n/**\n * Append additional header `field` with value `val`.\n *\n * Example:\n *\n *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);\n *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');\n *    res.append('Warning', '199 Miscellaneous warning');\n *\n * @param {String} field\n * @param {String|Array} val\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.append = function append(field, val) {\n  var prev = this.get(field);\n  var value = val;\n\n  if (prev) {\n    // concat the new and prev vals\n    value = Array.isArray(prev) ? prev.concat(val)\n      : Array.isArray(val) ? [prev].concat(val)\n      : [prev, val];\n  }\n\n  return this.set(field, value);\n};\n\n/**\n * Set header `field` to `val`, or pass\n * an object of header fields.\n *\n * Examples:\n *\n *    res.set('Foo', ['bar', 'baz']);\n *    res.set('Accept', 'application/json');\n *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n *\n * Aliased as `res.header()`.\n *\n * @param {String|Object} field\n * @param {String|Array} val\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.set =\nres.header = function header(field, val) {\n  if (arguments.length === 2) {\n    var value = Array.isArray(val)\n      ? val.map(String)\n      : String(val);\n\n    // add charset to content-type\n    if (field.toLowerCase() === 'content-type') {\n      if (Array.isArray(value)) {\n        throw new TypeError('Content-Type cannot be set to an Array');\n      }\n      if (!charsetRegExp.test(value)) {\n        var charset = mime.charsets.lookup(value.split(';')[0]);\n        if (charset) value += '; charset=' + charset.toLowerCase();\n      }\n    }\n\n    this.setHeader(field, value);\n  } else {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n  }\n  return this;\n};\n\n/**\n * Get value for header `field`.\n *\n * @param {String} field\n * @return {String}\n * @public\n */\n\nres.get = function(field){\n  return this.getHeader(field);\n};\n\n/**\n * Clear cookie `name`.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.clearCookie = function clearCookie(name, options) {\n  var opts = merge({ expires: new Date(1), path: '/' }, options);\n\n  return this.cookie(name, '', opts);\n};\n\n/**\n * Set cookie `name` to `value`, with the given `options`.\n *\n * Options:\n *\n *    - `maxAge`   max-age in milliseconds, converted to `expires`\n *    - `signed`   sign the cookie\n *    - `path`     defaults to \"/\"\n *\n * Examples:\n *\n *    // \"Remember Me\" for 15 minutes\n *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });\n *\n *    // save as above\n *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })\n *\n * @param {String} name\n * @param {String|Object} value\n * @param {Object} [options]\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.cookie = function (name, value, options) {\n  var opts = merge({}, options);\n  var secret = this.req.secret;\n  var signed = opts.signed;\n\n  if (signed && !secret) {\n    throw new Error('cookieParser(\"secret\") required for signed cookies');\n  }\n\n  var val = typeof value === 'object'\n    ? 'j:' + JSON.stringify(value)\n    : String(value);\n\n  if (signed) {\n    val = 's:' + sign(val, secret);\n  }\n\n  if ('maxAge' in opts) {\n    opts.expires = new Date(Date.now() + opts.maxAge);\n    opts.maxAge /= 1000;\n  }\n\n  if (opts.path == null) {\n    opts.path = '/';\n  }\n\n  this.append('Set-Cookie', cookie.serialize(name, String(val), opts));\n\n  return this;\n};\n\n/**\n * Set the location header to `url`.\n *\n * The given `url` can also be \"back\", which redirects\n * to the _Referrer_ or _Referer_ headers or \"/\".\n *\n * Examples:\n *\n *    res.location('/foo/bar').;\n *    res.location('http://example.com');\n *    res.location('../login');\n *\n * @param {String} url\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.location = function location(url) {\n  var loc = url;\n\n  // \"back\" is an alias for the referrer\n  if (url === 'back') {\n    loc = this.req.get('Referrer') || '/';\n  }\n\n  // set location\n  return this.set('Location', encodeUrl(loc));\n};\n\n/**\n * Redirect to the given `url` with optional response `status`\n * defaulting to 302.\n *\n * The resulting `url` is determined by `res.location()`, so\n * it will play nicely with mounted apps, relative paths,\n * `\"back\"` etc.\n *\n * Examples:\n *\n *    res.redirect('/foo/bar');\n *    res.redirect('http://example.com');\n *    res.redirect(301, 'http://example.com');\n *    res.redirect('../login'); // /blog/post/1 -> /blog/login\n *\n * @public\n */\n\nres.redirect = function redirect(url) {\n  var address = url;\n  var body;\n  var status = 302;\n\n  // allow status / url\n  if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number') {\n      status = arguments[0];\n      address = arguments[1];\n    } else {\n      deprecate('res.redirect(url, status): Use res.redirect(status, url) instead');\n      status = arguments[1];\n    }\n  }\n\n  // Set location header\n  address = this.location(address).get('Location');\n\n  // Support text/{plain,html} by default\n  this.format({\n    text: function(){\n      body = statuses[status] + '. Redirecting to ' + address\n    },\n\n    html: function(){\n      var u = escapeHtml(address);\n      body = '<p>' + statuses[status] + '. Redirecting to <a href=\"' + u + '\">' + u + '</a></p>'\n    },\n\n    default: function(){\n      body = '';\n    }\n  });\n\n  // Respond\n  this.statusCode = status;\n  this.set('Content-Length', Buffer.byteLength(body));\n\n  if (this.req.method === 'HEAD') {\n    this.end();\n  } else {\n    this.end(body);\n  }\n};\n\n/**\n * Add `field` to Vary. If already present in the Vary set, then\n * this call is simply ignored.\n *\n * @param {Array|String} field\n * @return {ServerResponse} for chaining\n * @public\n */\n\nres.vary = function(field){\n  // checks for back-compat\n  if (!field || (Array.isArray(field) && !field.length)) {\n    deprecate('res.vary(): Provide a field name');\n    return this;\n  }\n\n  vary(this, field);\n\n  return this;\n};\n\n/**\n * Render `view` with the given `options` and optional callback `fn`.\n * When a callback function is given a response will _not_ be made\n * automatically, otherwise a response of _200_ and _text/html_ is given.\n *\n * Options:\n *\n *  - `cache`     boolean hinting to the engine it should cache\n *  - `filename`  filename of the view being rendered\n *\n * @public\n */\n\nres.render = function render(view, options, callback) {\n  var app = this.req.app;\n  var done = callback;\n  var opts = options || {};\n  var req = this.req;\n  var self = this;\n\n  // support callback function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {};\n  }\n\n  // merge res.locals\n  opts._locals = self.locals;\n\n  // default callback to respond\n  done = done || function (err, str) {\n    if (err) return req.next(err);\n    self.send(str);\n  };\n\n  // render\n  app.render(view, opts, done);\n};\n\n// pipe the send file stream\nfunction sendfile(res, file, options, callback) {\n  var done = false;\n  var streaming;\n\n  // request aborted\n  function onaborted() {\n    if (done) return;\n    done = true;\n\n    var err = new Error('Request aborted');\n    err.code = 'ECONNABORTED';\n    callback(err);\n  }\n\n  // directory\n  function ondirectory() {\n    if (done) return;\n    done = true;\n\n    var err = new Error('EISDIR, read');\n    err.code = 'EISDIR';\n    callback(err);\n  }\n\n  // errors\n  function onerror(err) {\n    if (done) return;\n    done = true;\n    callback(err);\n  }\n\n  // ended\n  function onend() {\n    if (done) return;\n    done = true;\n    callback();\n  }\n\n  // file\n  function onfile() {\n    streaming = false;\n  }\n\n  // finished\n  function onfinish(err) {\n    if (err && err.code === 'ECONNRESET') return onaborted();\n    if (err) return onerror(err);\n    if (done) return;\n\n    setImmediate(function () {\n      if (streaming !== false && !done) {\n        onaborted();\n        return;\n      }\n\n      if (done) return;\n      done = true;\n      callback();\n    });\n  }\n\n  // streaming\n  function onstream() {\n    streaming = true;\n  }\n\n  file.on('directory', ondirectory);\n  file.on('end', onend);\n  file.on('error', onerror);\n  file.on('file', onfile);\n  file.on('stream', onstream);\n  onFinished(res, onfinish);\n\n  if (options.headers) {\n    // set headers on successful transfer\n    file.on('headers', function headers(res) {\n      var obj = options.headers;\n      var keys = Object.keys(obj);\n\n      for (var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n        res.setHeader(k, obj[k]);\n      }\n    });\n  }\n\n  // pipe\n  file.pipe(res);\n}\n\n/**\n * Stringify JSON, like JSON.stringify, but v8 optimized, with the\n * ability to escape characters that can trigger HTML sniffing.\n *\n * @param {*} value\n * @param {function} replaces\n * @param {number} spaces\n * @param {boolean} escape\n * @returns {string}\n * @private\n */\n\nfunction stringify (value, replacer, spaces, escape) {\n  // v8 checks arguments.length for optimizing simple call\n  // https://bugs.chromium.org/p/v8/issues/detail?id=4730\n  var json = replacer || spaces\n    ? JSON.stringify(value, replacer, spaces)\n    : JSON.stringify(value);\n\n  if (escape) {\n    json = json.replace(/[<>&]/g, function (c) {\n      switch (c.charCodeAt(0)) {\n        case 0x3c:\n          return '\\\\u003c'\n        case 0x3e:\n          return '\\\\u003e'\n        case 0x26:\n          return '\\\\u0026'\n        default:\n          return c\n      }\n    })\n  }\n\n  return json\n}\n","/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = require('./codes.json')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// status code to message map\nstatus.STATUS_CODES = codes\n\n// array of status codes\nstatus.codes = populateStatusesMap(status, codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Populate the statuses map for given codes.\n * @private\n */\n\nfunction populateStatusesMap (statuses, codes) {\n  var arr = []\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // Populate properties\n    statuses[status] = message\n    statuses[message] = status\n    statuses[message.toLowerCase()] = status\n\n    // Add to array\n    arr.push(status)\n  })\n\n  return arr\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    if (!status[code]) throw new Error('invalid status code: ' + code)\n    return code\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    if (!status[n]) throw new Error('invalid status code: ' + n)\n    return n\n  }\n\n  n = status[code.toLowerCase()]\n  if (!n) throw new Error('invalid status message: \"' + code + '\"')\n  return n\n}\n","/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar pairSplitRegExp = /; */;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var pairs = str.split(pairSplitRegExp);\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var eq_idx = pair.indexOf('=');\n\n    // skip things that don't look like key=value\n    if (eq_idx < 0) {\n      continue;\n    }\n\n    var key = pair.substr(0, eq_idx).trim()\n    var val = pair.substr(++eq_idx, pair.length).trim();\n\n    // quoted values\n    if ('\"' == val[0]) {\n      val = val.slice(1, -1);\n    }\n\n    // only assign once\n    if (undefined == obj[key]) {\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n","/*!\n * vary\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = vary\nmodule.exports.append = append\n\n/**\n * RegExp to match field-name in RFC 7230 sec 3.2\n *\n * field-name    = token\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n */\n\nvar FIELD_NAME_REGEXP = /^[!#$%&'*+\\-.^_`|~0-9A-Za-z]+$/\n\n/**\n * Append a field to a vary header.\n *\n * @param {String} header\n * @param {String|Array} field\n * @return {String}\n * @public\n */\n\nfunction append (header, field) {\n  if (typeof header !== 'string') {\n    throw new TypeError('header argument is required')\n  }\n\n  if (!field) {\n    throw new TypeError('field argument is required')\n  }\n\n  // get fields array\n  var fields = !Array.isArray(field)\n    ? parse(String(field))\n    : field\n\n  // assert on invalid field names\n  for (var j = 0; j < fields.length; j++) {\n    if (!FIELD_NAME_REGEXP.test(fields[j])) {\n      throw new TypeError('field argument contains an invalid header name')\n    }\n  }\n\n  // existing, unspecified vary\n  if (header === '*') {\n    return header\n  }\n\n  // enumerate current values\n  var val = header\n  var vals = parse(header.toLowerCase())\n\n  // unspecified vary\n  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {\n    return '*'\n  }\n\n  for (var i = 0; i < fields.length; i++) {\n    var fld = fields[i].toLowerCase()\n\n    // append value (case-preserving)\n    if (vals.indexOf(fld) === -1) {\n      vals.push(fld)\n      val = val\n        ? val + ', ' + fields[i]\n        : fields[i]\n    }\n  }\n\n  return val\n}\n\n/**\n * Parse a vary header into an array.\n *\n * @param {String} header\n * @return {Array}\n * @private\n */\n\nfunction parse (header) {\n  var end = 0\n  var list = []\n  var start = 0\n\n  // gather tokens\n  for (var i = 0, len = header.length; i < len; i++) {\n    switch (header.charCodeAt(i)) {\n      case 0x20: /*   */\n        if (start === end) {\n          start = end = i + 1\n        }\n        break\n      case 0x2c: /* , */\n        list.push(header.substring(start, end))\n        start = end = i + 1\n        break\n      default:\n        end = i + 1\n        break\n    }\n  }\n\n  // final token\n  list.push(header.substring(start, end))\n\n  return list\n}\n\n/**\n * Mark that a request is varied on a header field.\n *\n * @param {Object} res\n * @param {String|Array} field\n * @public\n */\n\nfunction vary (res, field) {\n  if (!res || !res.getHeader || !res.setHeader) {\n    // quack quack\n    throw new TypeError('res argument is required')\n  }\n\n  // get existing header\n  var val = res.getHeader('Vary') || ''\n  var header = Array.isArray(val)\n    ? val.join(', ')\n    : String(val)\n\n  // set new header\n  if ((val = append(header, field))) {\n    res.setHeader('Vary', val)\n  }\n}\n","/*!\n * serve-static\n * Copyright(c) 2010 Sencha Inc.\n * Copyright(c) 2011 TJ Holowaychuk\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar encodeUrl = require('encodeurl')\nvar escapeHtml = require('escape-html')\nvar parseUrl = require('parseurl')\nvar resolve = require('path').resolve\nvar send = require('send')\nvar url = require('url')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = serveStatic\nmodule.exports.mime = send.mime\n\n/**\n * @param {string} root\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction serveStatic (root, options) {\n  if (!root) {\n    throw new TypeError('root path required')\n  }\n\n  if (typeof root !== 'string') {\n    throw new TypeError('root path must be a string')\n  }\n\n  // copy options object\n  var opts = Object.create(options || null)\n\n  // fall-though\n  var fallthrough = opts.fallthrough !== false\n\n  // default redirect\n  var redirect = opts.redirect !== false\n\n  // headers listener\n  var setHeaders = opts.setHeaders\n\n  if (setHeaders && typeof setHeaders !== 'function') {\n    throw new TypeError('option setHeaders must be function')\n  }\n\n  // setup options for send\n  opts.maxage = opts.maxage || opts.maxAge || 0\n  opts.root = resolve(root)\n\n  // construct directory listener\n  var onDirectory = redirect\n    ? createRedirectDirectoryListener()\n    : createNotFoundDirectoryListener()\n\n  return function serveStatic (req, res, next) {\n    if (req.method !== 'GET' && req.method !== 'HEAD') {\n      if (fallthrough) {\n        return next()\n      }\n\n      // method not allowed\n      res.statusCode = 405\n      res.setHeader('Allow', 'GET, HEAD')\n      res.setHeader('Content-Length', '0')\n      res.end()\n      return\n    }\n\n    var forwardError = !fallthrough\n    var originalUrl = parseUrl.original(req)\n    var path = parseUrl(req).pathname\n\n    // make sure redirect occurs at mount\n    if (path === '/' && originalUrl.pathname.substr(-1) !== '/') {\n      path = ''\n    }\n\n    // create send stream\n    var stream = send(req, path, opts)\n\n    // add directory handler\n    stream.on('directory', onDirectory)\n\n    // add headers listener\n    if (setHeaders) {\n      stream.on('headers', setHeaders)\n    }\n\n    // add file listener for fallthrough\n    if (fallthrough) {\n      stream.on('file', function onFile () {\n        // once file is determined, always forward error\n        forwardError = true\n      })\n    }\n\n    // forward errors\n    stream.on('error', function error (err) {\n      if (forwardError || !(err.statusCode < 500)) {\n        next(err)\n        return\n      }\n\n      next()\n    })\n\n    // pipe\n    stream.pipe(res)\n  }\n}\n\n/**\n * Collapse all leading slashes into a single slash\n * @private\n */\nfunction collapseLeadingSlashes (str) {\n  for (var i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) !== 0x2f /* / */) {\n      break\n    }\n  }\n\n  return i > 1\n    ? '/' + str.substr(i)\n    : str\n}\n\n /**\n * Create a minimal HTML document.\n *\n * @param {string} title\n * @param {string} body\n * @private\n */\n\nfunction createHtmlDocument (title, body) {\n  return '<!DOCTYPE html>\\n' +\n    '<html lang=\"en\">\\n' +\n    '<head>\\n' +\n    '<meta charset=\"utf-8\">\\n' +\n    '<title>' + title + '</title>\\n' +\n    '</head>\\n' +\n    '<body>\\n' +\n    '<pre>' + body + '</pre>\\n' +\n    '</body>\\n' +\n    '</html>\\n'\n}\n\n/**\n * Create a directory listener that just 404s.\n * @private\n */\n\nfunction createNotFoundDirectoryListener () {\n  return function notFound () {\n    this.error(404)\n  }\n}\n\n/**\n * Create a directory listener that performs a redirect.\n * @private\n */\n\nfunction createRedirectDirectoryListener () {\n  return function redirect (res) {\n    if (this.hasTrailingSlash()) {\n      this.error(404)\n      return\n    }\n\n    // get original URL\n    var originalUrl = parseUrl.original(this.req)\n\n    // append trailing slash\n    originalUrl.path = null\n    originalUrl.pathname = collapseLeadingSlashes(originalUrl.pathname + '/')\n\n    // reformat the URL\n    var loc = encodeUrl(url.format(originalUrl))\n    var doc = createHtmlDocument('Redirecting', 'Redirecting to <a href=\"' + escapeHtml(loc) + '\">' +\n      escapeHtml(loc) + '</a>')\n\n    // send redirect response\n    res.statusCode = 301\n    res.setHeader('Content-Type', 'text/html; charset=UTF-8')\n    res.setHeader('Content-Length', Buffer.byteLength(doc))\n    res.setHeader('Content-Security-Policy', \"default-src 'self'\")\n    res.setHeader('X-Content-Type-Options', 'nosniff')\n    res.setHeader('Location', loc)\n    res.end(doc)\n  }\n}\n","/** @license React v16.6.1\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';var k=require(\"object-assign\"),n=\"function\"===typeof Symbol&&Symbol.for,p=n?Symbol.for(\"react.element\"):60103,q=n?Symbol.for(\"react.portal\"):60106,r=n?Symbol.for(\"react.fragment\"):60107,t=n?Symbol.for(\"react.strict_mode\"):60108,u=n?Symbol.for(\"react.profiler\"):60114,v=n?Symbol.for(\"react.provider\"):60109,w=n?Symbol.for(\"react.context\"):60110,x=n?Symbol.for(\"react.concurrent_mode\"):60111,y=n?Symbol.for(\"react.forward_ref\"):60112,z=n?Symbol.for(\"react.suspense\"):60113,A=n?Symbol.for(\"react.memo\"):\n60115,B=n?Symbol.for(\"react.lazy\"):60116,C=\"function\"===typeof Symbol&&Symbol.iterator;function aa(a,b,e,c,d,g,h,f){if(!a){a=void 0;if(void 0===b)a=Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");else{var l=[e,c,d,g,h,f],m=0;a=Error(b.replace(/%s/g,function(){return l[m++]}));a.name=\"Invariant Violation\"}a.framesToPop=1;throw a;}}\nfunction D(a){for(var b=arguments.length-1,e=\"https://reactjs.org/docs/error-decoder.html?invariant=\"+a,c=0;c<b;c++)e+=\"&args[]=\"+encodeURIComponent(arguments[c+1]);aa(!1,\"Minified React error #\"+a+\"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. \",e)}var E={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},F={};\nfunction G(a,b,e){this.props=a;this.context=b;this.refs=F;this.updater=e||E}G.prototype.isReactComponent={};G.prototype.setState=function(a,b){\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a?D(\"85\"):void 0;this.updater.enqueueSetState(this,a,b,\"setState\")};G.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};function H(){}H.prototype=G.prototype;function I(a,b,e){this.props=a;this.context=b;this.refs=F;this.updater=e||E}var J=I.prototype=new H;\nJ.constructor=I;k(J,G.prototype);J.isPureReactComponent=!0;var K={current:null,currentDispatcher:null},L=Object.prototype.hasOwnProperty,M={key:!0,ref:!0,__self:!0,__source:!0};\nfunction N(a,b,e){var c=void 0,d={},g=null,h=null;if(null!=b)for(c in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(g=\"\"+b.key),b)L.call(b,c)&&!M.hasOwnProperty(c)&&(d[c]=b[c]);var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){for(var l=Array(f),m=0;m<f;m++)l[m]=arguments[m+2];d.children=l}if(a&&a.defaultProps)for(c in f=a.defaultProps,f)void 0===d[c]&&(d[c]=f[c]);return{$$typeof:p,type:a,key:g,ref:h,props:d,_owner:K.current}}\nfunction ba(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+(\"\"+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g,Q=[];function R(a,b,e,c){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=e;d.context=c;d.count=0;return d}return{result:a,keyPrefix:b,func:e,context:c,count:0}}\nfunction S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a)}\nfunction T(a,b,e,c){var d=typeof a;if(\"undefined\"===d||\"boolean\"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case \"string\":case \"number\":g=!0;break;case \"object\":switch(a.$$typeof){case p:case q:g=!0}}if(g)return e(c,a,\"\"===b?\".\"+U(a,0):b),1;g=0;b=\"\"===b?\".\":b+\":\";if(Array.isArray(a))for(var h=0;h<a.length;h++){d=a[h];var f=b+U(d,h);g+=T(d,f,e,c)}else if(null===a||\"object\"!==typeof a?f=null:(f=C&&a[C]||a[\"@@iterator\"],f=\"function\"===typeof f?f:null),\"function\"===typeof f)for(a=f.call(a),h=\n0;!(d=a.next()).done;)d=d.value,f=b+U(d,h++),g+=T(d,f,e,c);else\"object\"===d&&(e=\"\"+a,D(\"31\",\"[object Object]\"===e?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":e,\"\"));return g}function V(a,b,e){return null==a?0:T(a,\"\",b,e)}function U(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function ca(a,b){a.func.call(a.context,b,a.count++)}\nfunction da(a,b,e){var c=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?W(a,c,e,function(a){return a}):null!=a&&(O(a)&&(a=ba(a,d+(!a.key||b&&b.key===a.key?\"\":(\"\"+a.key).replace(P,\"$&/\")+\"/\")+e)),c.push(a))}function W(a,b,e,c,d){var g=\"\";null!=e&&(g=(\"\"+e).replace(P,\"$&/\")+\"/\");b=R(b,g,c,d);V(a,da,b);S(b)}\nvar X={Children:{map:function(a,b,e){if(null==a)return a;var c=[];W(a,c,null,b,e);return c},forEach:function(a,b,e){if(null==a)return a;b=R(null,null,b,e);V(a,ca,b);S(b)},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];W(a,b,null,function(a){return a});return b},only:function(a){O(a)?void 0:D(\"143\");return a}},createRef:function(){return{current:null}},Component:G,PureComponent:I,createContext:function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,\n_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a},forwardRef:function(a){return{$$typeof:y,render:a}},lazy:function(a){return{$$typeof:B,_ctor:a,_status:-1,_result:null}},memo:function(a,b){return{$$typeof:A,type:a,compare:void 0===b?null:b}},Fragment:r,StrictMode:t,Suspense:z,createElement:N,cloneElement:function(a,b,e){null===a||void 0===a?D(\"267\",a):void 0;var c=void 0,d=k({},a.props),g=a.key,h=a.ref,f=a._owner;\nif(null!=b){void 0!==b.ref&&(h=b.ref,f=K.current);void 0!==b.key&&(g=\"\"+b.key);var l=void 0;a.type&&a.type.defaultProps&&(l=a.type.defaultProps);for(c in b)L.call(b,c)&&!M.hasOwnProperty(c)&&(d[c]=void 0===b[c]&&void 0!==l?l[c]:b[c])}c=arguments.length-2;if(1===c)d.children=e;else if(1<c){l=Array(c);for(var m=0;m<c;m++)l[m]=arguments[m+2];d.children=l}return{$$typeof:p,type:a.type,key:g,ref:h,props:d,_owner:f}},createFactory:function(a){var b=N.bind(null,a);b.type=a;return b},isValidElement:O,version:\"16.6.3\",\n__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:K,assign:k}};X.unstable_ConcurrentMode=x;X.unstable_Profiler=u;var Y={default:X},Z=Y&&X||Y;module.exports=Z.default||Z;\n","/** @license React v16.6.1\n * react-dom-server.node.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';var p=require(\"object-assign\"),q=require(\"react\"),aa=require(\"stream\");function ba(a,b,f,c,e,d,h,g){if(!a){a=void 0;if(void 0===b)a=Error(\"Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.\");else{var B=[f,c,e,d,h,g],A=0;a=Error(b.replace(/%s/g,function(){return B[A++]}));a.name=\"Invariant Violation\"}a.framesToPop=1;throw a;}}\nfunction u(a){for(var b=arguments.length-1,f=\"https://reactjs.org/docs/error-decoder.html?invariant=\"+a,c=0;c<b;c++)f+=\"&args[]=\"+encodeURIComponent(arguments[c+1]);ba(!1,\"Minified React error #\"+a+\"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. \",f)}\nvar w=\"function\"===typeof Symbol&&Symbol.for,y=w?Symbol.for(\"react.portal\"):60106,z=w?Symbol.for(\"react.fragment\"):60107,C=w?Symbol.for(\"react.strict_mode\"):60108,D=w?Symbol.for(\"react.profiler\"):60114,E=w?Symbol.for(\"react.provider\"):60109,F=w?Symbol.for(\"react.context\"):60110,G=w?Symbol.for(\"react.concurrent_mode\"):60111,H=w?Symbol.for(\"react.forward_ref\"):60112,I=w?Symbol.for(\"react.suspense\"):60113,J=w?Symbol.for(\"react.memo\"):60115,ca=w?Symbol.for(\"react.lazy\"):60116;\nfunction L(a){if(null==a)return null;if(\"function\"===typeof a)return a.displayName||a.name||null;if(\"string\"===typeof a)return a;switch(a){case G:return\"ConcurrentMode\";case z:return\"Fragment\";case y:return\"Portal\";case D:return\"Profiler\";case C:return\"StrictMode\";case I:return\"Suspense\"}if(\"object\"===typeof a)switch(a.$$typeof){case F:return\"Context.Consumer\";case E:return\"Context.Provider\";case H:var b=a.render;b=b.displayName||b.name||\"\";return a.displayName||(\"\"!==b?\"ForwardRef(\"+b+\")\":\"ForwardRef\");\ncase J:return L(a.type);case ca:if(a=1===a._status?a._result:null)return L(a)}return null}var da=q.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,ea={};function M(a,b){for(var f=a._threadCount;f<=b;f++)a[f]=a._currentValue2,a._threadCount=f+1}function fa(a,b,f){var c=a.contextType;if(\"object\"===typeof c&&null!==c)return M(c,f),c[f];if(a=a.contextTypes){f={};for(var e in a)f[e]=b[e];b=f}else b=ea;return b}for(var N=new Uint16Array(16),O=0;15>O;O++)N[O]=O+1;N[15]=0;\nvar ha=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,ia=Object.prototype.hasOwnProperty,ja={},ka={};\nfunction la(a){if(ia.call(ka,a))return!0;if(ia.call(ja,a))return!1;if(ha.test(a))return ka[a]=!0;ja[a]=!0;return!1}function ma(a,b,f,c){if(null!==f&&0===f.type)return!1;switch(typeof b){case \"function\":case \"symbol\":return!0;case \"boolean\":if(c)return!1;if(null!==f)return!f.acceptsBooleans;a=a.toLowerCase().slice(0,5);return\"data-\"!==a&&\"aria-\"!==a;default:return!1}}\nfunction na(a,b,f,c){if(null===b||\"undefined\"===typeof b||ma(a,b,f,c))return!0;if(c)return!1;if(null!==f)switch(f.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function P(a,b,f,c,e){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=c;this.attributeNamespace=e;this.mustUseProperty=f;this.propertyName=a;this.type=b}var Q={};\n\"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style\".split(\" \").forEach(function(a){Q[a]=new P(a,0,!1,a,null)});[[\"acceptCharset\",\"accept-charset\"],[\"className\",\"class\"],[\"htmlFor\",\"for\"],[\"httpEquiv\",\"http-equiv\"]].forEach(function(a){var b=a[0];Q[b]=new P(b,1,!1,a[1],null)});[\"contentEditable\",\"draggable\",\"spellCheck\",\"value\"].forEach(function(a){Q[a]=new P(a,2,!1,a.toLowerCase(),null)});\n[\"autoReverse\",\"externalResourcesRequired\",\"focusable\",\"preserveAlpha\"].forEach(function(a){Q[a]=new P(a,2,!1,a,null)});\"allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope\".split(\" \").forEach(function(a){Q[a]=new P(a,3,!1,a.toLowerCase(),null)});[\"checked\",\"multiple\",\"muted\",\"selected\"].forEach(function(a){Q[a]=new P(a,3,!0,a,null)});\n[\"capture\",\"download\"].forEach(function(a){Q[a]=new P(a,4,!1,a,null)});[\"cols\",\"rows\",\"size\",\"span\"].forEach(function(a){Q[a]=new P(a,6,!1,a,null)});[\"rowSpan\",\"start\"].forEach(function(a){Q[a]=new P(a,5,!1,a.toLowerCase(),null)});var R=/[\\-:]([a-z])/g;function S(a){return a[1].toUpperCase()}\n\"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height\".split(\" \").forEach(function(a){var b=a.replace(R,\nS);Q[b]=new P(b,1,!1,a,null)});\"xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type\".split(\" \").forEach(function(a){var b=a.replace(R,S);Q[b]=new P(b,1,!1,a,\"http://www.w3.org/1999/xlink\")});[\"xml:base\",\"xml:lang\",\"xml:space\"].forEach(function(a){var b=a.replace(R,S);Q[b]=new P(b,1,!1,a,\"http://www.w3.org/XML/1998/namespace\")});Q.tabIndex=new P(\"tabIndex\",1,!1,\"tabindex\",null);var oa=/[\"'&<>]/;\nfunction T(a){if(\"boolean\"===typeof a||\"number\"===typeof a)return\"\"+a;a=\"\"+a;var b=oa.exec(a);if(b){var f=\"\",c,e=0;for(c=b.index;c<a.length;c++){switch(a.charCodeAt(c)){case 34:b=\"&quot;\";break;case 38:b=\"&amp;\";break;case 39:b=\"&#x27;\";break;case 60:b=\"&lt;\";break;case 62:b=\"&gt;\";break;default:continue}e!==c&&(f+=a.substring(e,c));e=c+1;f+=b}a=e!==c?f+a.substring(e,c):f}return a}var pa=!1;function qa(a,b,f,c){for(;pa;)pa=!1,f=a(b,c);return f}\nvar U=0,ra={readContext:function(a){var b=U;M(a,b);return a[b]}},sa={html:\"http://www.w3.org/1999/xhtml\",mathml:\"http://www.w3.org/1998/Math/MathML\",svg:\"http://www.w3.org/2000/svg\"};function ta(a){switch(a){case \"svg\":return\"http://www.w3.org/2000/svg\";case \"math\":return\"http://www.w3.org/1998/Math/MathML\";default:return\"http://www.w3.org/1999/xhtml\"}}\nvar ua={area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0},va=p({menuitem:!0},ua),V={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,\ngridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},wa=[\"Webkit\",\"ms\",\"Moz\",\"O\"];Object.keys(V).forEach(function(a){wa.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);V[b]=V[a]})});\nvar xa=/([A-Z])/g,ya=/^ms-/,W=q.Children.toArray,X=da.ReactCurrentOwner,za={listing:!0,pre:!0,textarea:!0},Aa=/^[a-zA-Z][a-zA-Z:_\\.\\-\\d]*$/,Ba={},Y={};function Ca(a){if(void 0===a||null===a)return a;var b=\"\";q.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}var Da=Object.prototype.hasOwnProperty,Ea={children:null,dangerouslySetInnerHTML:null,suppressContentEditableWarning:null,suppressHydrationWarning:null};function Fa(a,b){void 0===a&&u(\"152\",L(b)||\"Component\")}\nfunction Ga(a,b,f){function c(e,c){var d=fa(c,b,f),g=[],h=!1,l={isMounted:function(){return!1},enqueueForceUpdate:function(){if(null===g)return null},enqueueReplaceState:function(a,b){h=!0;g=[b]},enqueueSetState:function(a,b){if(null===g)return null;g.push(b)}},k=void 0;if(c.prototype&&c.prototype.isReactComponent){if(k=new c(e.props,d,l),\"function\"===typeof c.getDerivedStateFromProps){var r=c.getDerivedStateFromProps.call(null,e.props,k.state);null!=r&&(k.state=p({},k.state,r))}}else if(k=c(e.props,\nd,l),k=qa(c,e.props,k,d),null==k||null==k.render){a=k;Fa(a,c);return}k.props=e.props;k.context=d;k.updater=l;l=k.state;void 0===l&&(k.state=l=null);if(\"function\"===typeof k.UNSAFE_componentWillMount||\"function\"===typeof k.componentWillMount)if(\"function\"===typeof k.componentWillMount&&\"function\"!==typeof c.getDerivedStateFromProps&&k.componentWillMount(),\"function\"===typeof k.UNSAFE_componentWillMount&&\"function\"!==typeof c.getDerivedStateFromProps&&k.UNSAFE_componentWillMount(),g.length){l=g;var m=\nh;g=null;h=!1;if(m&&1===l.length)k.state=l[0];else{r=m?l[0]:k.state;var t=!0;for(m=m?1:0;m<l.length;m++){var v=l[m];v=\"function\"===typeof v?v.call(k,r,e.props,d):v;null!=v&&(t?(t=!1,r=p({},r,v)):p(r,v))}k.state=r}}else g=null;a=k.render();Fa(a,c);e=void 0;if(\"function\"===typeof k.getChildContext&&(d=c.childContextTypes,\"object\"===typeof d)){e=k.getChildContext();for(var K in e)K in d?void 0:u(\"108\",L(c)||\"Unknown\",K)}e&&(b=p({},b,e))}for(;q.isValidElement(a);){var e=a,d=e.type;if(\"function\"!==typeof d)break;\nc(e,d)}return{child:a,context:b}}\nvar Z=function(){function a(b,f){if(!(this instanceof a))throw new TypeError(\"Cannot call a class as a function\");q.isValidElement(b)?b.type!==z?b=[b]:(b=b.props.children,b=q.isValidElement(b)?[b]:W(b)):b=W(b);b={type:null,domNamespace:sa.html,children:b,childIndex:0,context:ea,footer:\"\"};var c=N[0];if(0===c){var e=N;c=e.length;var d=2*c;65536>=d?void 0:u(\"304\");var h=new Uint16Array(d);h.set(e);N=h;N[0]=c+1;for(e=c;e<d-1;e++)N[e]=e+1;N[d-1]=0}else N[0]=N[c];this.threadID=c;this.stack=[b];this.exhausted=\n!1;this.currentSelectValue=null;this.previousWasTextNode=!1;this.makeStaticMarkup=f;this.suspenseDepth=0;this.contextIndex=-1;this.contextStack=[];this.contextValueStack=[]}a.prototype.destroy=function(){if(!this.exhausted){this.exhausted=!0;var a=this.threadID;N[a]=N[0];N[0]=a}};a.prototype.pushProvider=function(a){var b=++this.contextIndex,c=a.type._context,e=this.threadID;M(c,e);var d=c[e];this.contextStack[b]=c;this.contextValueStack[b]=d;c[e]=a.props.value};a.prototype.popProvider=function(){var a=\nthis.contextIndex,f=this.contextStack[a],c=this.contextValueStack[a];this.contextStack[a]=null;this.contextValueStack[a]=null;this.contextIndex--;f[this.threadID]=c};a.prototype.read=function(a){if(this.exhausted)return null;var b=U;U=this.threadID;var c=X.currentDispatcher;X.currentDispatcher=ra;try{for(var e=[\"\"],d=!1;e[0].length<a;){if(0===this.stack.length){this.exhausted=!0;var h=this.threadID;N[h]=N[0];N[0]=h;break}var g=this.stack[this.stack.length-1];if(d||g.childIndex>=g.children.length){var B=\ng.footer;\"\"!==B&&(this.previousWasTextNode=!1);this.stack.pop();if(\"select\"===g.type)this.currentSelectValue=null;else if(null!=g.type&&null!=g.type.type&&g.type.type.$$typeof===E)this.popProvider(g.type);else if(g.type===I){this.suspenseDepth--;var A=e.pop();if(d){d=!1;var n=g.fallbackFrame;n?void 0:u(\"303\");this.stack.push(n);continue}else e[this.suspenseDepth]+=A}e[this.suspenseDepth]+=B}else{var l=g.children[g.childIndex++],k=\"\";try{k+=this.render(l,g.context,g.domNamespace)}catch(r){throw r;\n}finally{}e.length<=this.suspenseDepth&&e.push(\"\");e[this.suspenseDepth]+=k}}return e[0]}finally{X.currentDispatcher=c,U=b}};a.prototype.render=function(a,f,c){if(\"string\"===typeof a||\"number\"===typeof a){c=\"\"+a;if(\"\"===c)return\"\";if(this.makeStaticMarkup)return T(c);if(this.previousWasTextNode)return\"\\x3c!-- --\\x3e\"+T(c);this.previousWasTextNode=!0;return T(c)}f=Ga(a,f,this.threadID);a=f.child;f=f.context;if(null===a||!1===a)return\"\";if(!q.isValidElement(a)){if(null!=a&&null!=a.$$typeof){var b=a.$$typeof;\nb===y?u(\"257\"):void 0;u(\"258\",b.toString())}a=W(a);this.stack.push({type:null,domNamespace:c,children:a,childIndex:0,context:f,footer:\"\"});return\"\"}b=a.type;if(\"string\"===typeof b)return this.renderDOM(a,f,c);switch(b){case C:case G:case D:case z:return a=W(a.props.children),this.stack.push({type:null,domNamespace:c,children:a,childIndex:0,context:f,footer:\"\"}),\"\";case I:u(\"294\")}if(\"object\"===typeof b&&null!==b)switch(b.$$typeof){case H:var d=b.render(a.props,a.ref);d=qa(b.render,a.props,d,a.ref);\nd=W(d);this.stack.push({type:null,domNamespace:c,children:d,childIndex:0,context:f,footer:\"\"});return\"\";case J:return a=[q.createElement(b.type,p({ref:a.ref},a.props))],this.stack.push({type:null,domNamespace:c,children:a,childIndex:0,context:f,footer:\"\"}),\"\";case E:return b=W(a.props.children),c={type:a,domNamespace:c,children:b,childIndex:0,context:f,footer:\"\"},this.pushProvider(a),this.stack.push(c),\"\";case F:b=a.type;d=a.props;var h=this.threadID;M(b,h);b=W(d.children(b[h]));this.stack.push({type:a,\ndomNamespace:c,children:b,childIndex:0,context:f,footer:\"\"});return\"\";case ca:u(\"295\")}u(\"130\",null==b?b:typeof b,\"\")};a.prototype.renderDOM=function(a,f,c){var b=a.type.toLowerCase();c===sa.html&&ta(b);Ba.hasOwnProperty(b)||(Aa.test(b)?void 0:u(\"65\",b),Ba[b]=!0);var d=a.props;if(\"input\"===b)d=p({type:void 0},d,{defaultChecked:void 0,defaultValue:void 0,value:null!=d.value?d.value:d.defaultValue,checked:null!=d.checked?d.checked:d.defaultChecked});else if(\"textarea\"===b){var h=d.value;if(null==h){h=\nd.defaultValue;var g=d.children;null!=g&&(null!=h?u(\"92\"):void 0,Array.isArray(g)&&(1>=g.length?void 0:u(\"93\"),g=g[0]),h=\"\"+g);null==h&&(h=\"\")}d=p({},d,{value:void 0,children:\"\"+h})}else if(\"select\"===b)this.currentSelectValue=null!=d.value?d.value:d.defaultValue,d=p({},d,{value:void 0});else if(\"option\"===b){g=this.currentSelectValue;var B=Ca(d.children);if(null!=g){var A=null!=d.value?d.value+\"\":B;h=!1;if(Array.isArray(g))for(var n=0;n<g.length;n++){if(\"\"+g[n]===A){h=!0;break}}else h=\"\"+g===A;d=\np({selected:void 0,children:void 0},d,{selected:h,children:B})}}if(h=d)va[b]&&(null!=h.children||null!=h.dangerouslySetInnerHTML?u(\"137\",b,\"\"):void 0),null!=h.dangerouslySetInnerHTML&&(null!=h.children?u(\"60\"):void 0,\"object\"===typeof h.dangerouslySetInnerHTML&&\"__html\"in h.dangerouslySetInnerHTML?void 0:u(\"61\")),null!=h.style&&\"object\"!==typeof h.style?u(\"62\",\"\"):void 0;h=d;g=this.makeStaticMarkup;B=1===this.stack.length;A=\"<\"+a.type;for(x in h)if(Da.call(h,x)){var l=h[x];if(null!=l){if(\"style\"===\nx){n=void 0;var k=\"\",r=\"\";for(n in l)if(l.hasOwnProperty(n)){var m=0===n.indexOf(\"--\"),t=l[n];if(null!=t){var v=n;if(Y.hasOwnProperty(v))v=Y[v];else{var K=v.replace(xa,\"-$1\").toLowerCase().replace(ya,\"-ms-\");v=Y[v]=K}k+=r+v+\":\";r=n;m=null==t||\"boolean\"===typeof t||\"\"===t?\"\":m||\"number\"!==typeof t||0===t||V.hasOwnProperty(r)&&V[r]?(\"\"+t).trim():t+\"px\";k+=m;r=\";\"}}l=k||null}n=null;b:if(m=b,t=h,-1===m.indexOf(\"-\"))m=\"string\"===typeof t.is;else switch(m){case \"annotation-xml\":case \"color-profile\":case \"font-face\":case \"font-face-src\":case \"font-face-uri\":case \"font-face-format\":case \"font-face-name\":case \"missing-glyph\":m=\n!1;break b;default:m=!0}if(m)Ea.hasOwnProperty(x)||(n=x,n=la(n)&&null!=l?n+\"=\"+('\"'+T(l)+'\"'):\"\");else{m=x;n=l;l=Q.hasOwnProperty(m)?Q[m]:null;if(t=\"style\"!==m)t=null!==l?0===l.type:!(2<m.length)||\"o\"!==m[0]&&\"O\"!==m[0]||\"n\"!==m[1]&&\"N\"!==m[1]?!1:!0;t||na(m,n,l,!1)?n=\"\":null!==l?(m=l.attributeName,l=l.type,n=3===l||4===l&&!0===n?m+'=\"\"':m+\"=\"+('\"'+T(n)+'\"')):n=la(m)?m+\"=\"+('\"'+T(n)+'\"'):\"\"}n&&(A+=\" \"+n)}}g||B&&(A+=' data-reactroot=\"\"');var x=A;h=\"\";ua.hasOwnProperty(b)?x+=\"/>\":(x+=\">\",h=\"</\"+a.type+\n\">\");a:{g=d.dangerouslySetInnerHTML;if(null!=g){if(null!=g.__html){g=g.__html;break a}}else if(g=d.children,\"string\"===typeof g||\"number\"===typeof g){g=T(g);break a}g=null}null!=g?(d=[],za[b]&&\"\\n\"===g.charAt(0)&&(x+=\"\\n\"),x+=g):d=W(d.children);a=a.type;c=null==c||\"http://www.w3.org/1999/xhtml\"===c?ta(a):\"http://www.w3.org/2000/svg\"===c&&\"foreignObject\"===a?\"http://www.w3.org/1999/xhtml\":c;this.stack.push({domNamespace:c,type:b,children:d,childIndex:0,context:f,footer:h});this.previousWasTextNode=\n!1;return x};return a}();function Ha(a,b){if(\"function\"!==typeof b&&null!==b)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof b);a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}});b&&(Object.setPrototypeOf?Object.setPrototypeOf(a,b):a.__proto__=b)}\nvar Ia=function(a){function b(f,c){if(!(this instanceof b))throw new TypeError(\"Cannot call a class as a function\");var e=a.call(this,{});if(!this)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");e=!e||\"object\"!==typeof e&&\"function\"!==typeof e?this:e;e.partialRenderer=new Z(f,c);return e}Ha(b,a);b.prototype._destroy=function(){this.partialRenderer.destroy()};b.prototype._read=function(a){try{this.push(this.partialRenderer.read(a))}catch(c){this.destroy(c)}};return b}(aa.Readable),\nJa={renderToString:function(a){a=new Z(a,!1);try{return a.read(Infinity)}finally{a.destroy()}},renderToStaticMarkup:function(a){a=new Z(a,!0);try{return a.read(Infinity)}finally{a.destroy()}},renderToNodeStream:function(a){return new Ia(a,!1)},renderToStaticNodeStream:function(a){return new Ia(a,!0)},version:\"16.6.3\"},Ka={default:Ja},La=Ka&&Ja||Ka;module.exports=La.default||La;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nif (global.MONGOOSE_DRIVER_PATH) {\n  require('./driver').set(require(global.MONGOOSE_DRIVER_PATH));\n} else {\n  require('./driver').set(require('./drivers/node-mongodb-native'));\n}\n\nconst Schema = require('./schema');\nconst SchemaType = require('./schematype');\nconst SchemaTypes = require('./schema/index');\nconst VirtualType = require('./virtualtype');\nconst STATES = require('./connectionstate');\nconst Types = require('./types');\nconst Query = require('./query');\nconst Model = require('./model');\nconst Document = require('./document');\nconst legacyPluralize = require('mongoose-legacy-pluralize');\nconst utils = require('./utils');\nconst pkg = require('../package.json');\n\nconst removeSubdocs = require('./plugins/removeSubdocs');\nconst saveSubdocs = require('./plugins/saveSubdocs');\nconst validateBeforeSave = require('./plugins/validateBeforeSave');\n\nconst Aggregate = require('./aggregate');\nconst PromiseProvider = require('./promise_provider');\nconst shardingPlugin = require('./plugins/sharding');\n\nconst defaultMongooseSymbol = Symbol.for('mongoose:default');\n\nrequire('./helpers/printJestWarning');\n\n/**\n * Mongoose constructor.\n *\n * The exports object of the `mongoose` module is an instance of this class.\n * Most apps will only use this one instance.\n *\n * @api public\n */\n\nfunction Mongoose(options) {\n  this.connections = [];\n  this.models = {};\n  this.modelSchemas = {};\n  // default global options\n  this.options = {\n    pluralization: true\n  };\n  const conn = this.createConnection(); // default connection\n  conn.models = this.models;\n\n  this._pluralize = legacyPluralize;\n\n  // If a user creates their own Mongoose instance, give them a separate copy\n  // of the `Schema` constructor so they get separate custom types. (gh-6933)\n  if (!options || !options[defaultMongooseSymbol]) {\n    const _this = this;\n    this.Schema = function() {\n      this.base = _this;\n      return Schema.apply(this, arguments);\n    };\n    this.Schema.prototype = Object.create(Schema.prototype);\n\n    Object.assign(this.Schema, Schema);\n    this.Schema.base = this;\n    this.Schema.Types = Object.assign({}, Schema.Types);\n  }\n  this.Schema.prototype.base = this;\n\n  Object.defineProperty(this, 'plugins', {\n    configurable: false,\n    enumerable: true,\n    writable: false,\n    value: [\n      [saveSubdocs, { deduplicate: true }],\n      [validateBeforeSave, { deduplicate: true }],\n      [shardingPlugin, { deduplicate: true }],\n      [removeSubdocs, { deduplicate: true }]\n    ]\n  });\n}\n\n/**\n * Expose connection states for user-land\n *\n * @memberOf Mongoose\n * @property STATES\n * @api public\n */\nMongoose.prototype.STATES = STATES;\n\n/**\n * Sets mongoose options\n *\n * ####Example:\n *\n *     mongoose.set('test', value) // sets the 'test' option to `value`\n *\n *     mongoose.set('debug', true) // enable logging collection methods + arguments to the console\n *\n *     mongoose.set('debug', function(collectionName, methodName, arg1, arg2...) {}); // use custom function to log collection methods + arguments\n *\n * Currently supported options are:\n * - 'debug': prints the operations mongoose sends to MongoDB to the console\n * - 'bufferCommands': enable/disable mongoose's buffering mechanism for all connections and models\n * - 'useCreateIndex': false by default. Set to `true` to make Mongoose's default index build use `createIndex()` instead of `ensureIndex()` to avoid deprecation warnings from the MongoDB driver.\n * - 'useFindAndModify': true by default. Set to `false` to make `findOneAndUpdate()` and `findOneAndRemove()` use native `findOneAndUpdate()` rather than `findAndModify()`.\n * - 'useNewUrlParser': false by default. Set to `true` to make all connections set the `useNewUrlParser` option by default\n * - 'cloneSchemas': false by default. Set to `true` to `clone()` all schemas before compiling into a model.\n * - 'applyPluginsToDiscriminators': false by default. Set to true to apply global plugins to discriminator schemas. This typically isn't necessary because plugins are applied to the base schema and discriminators copy all middleware, methods, statics, and properties from the base schema.\n * - 'objectIdGetter': true by default. Mongoose adds a getter to MongoDB ObjectId's called `_id` that returns `this` for convenience with populate. Set this to false to remove the getter.\n * - 'runValidators': false by default. Set to true to enable [update validators](/docs/validation.html#update-validators) for all validators by default.\n * - 'toObject': `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toObject()`](/docs/api.html#document_Document-toObject)\n * - 'toJSON': `{ transform: true, flattenDecimals: true }` by default. Overwrites default objects to [`toJSON()`](/docs/api.html#document_Document-toJSON), for determining how Mongoose documents get serialized by `JSON.stringify()`\n * - 'strict': true by default, may be `false`, `true`, or `'throw'`. Sets the default strict mode for schemas.\n * - 'selectPopulatedPaths': true by default. Set to false to opt out of Mongoose adding all fields that you `populate()` to your `select()`. The schema-level option `selectPopulatedPaths` overwrites this one.\n *\n * @param {String} key\n * @param {String|Function|Boolean} value\n * @api public\n */\n\nMongoose.prototype.set = function(key, value) {\n  if (arguments.length === 1) {\n    return this.options[key];\n  }\n\n  this.options[key] = value;\n\n  if (key === 'objectIdGetter') {\n    if (value) {\n      Object.defineProperty(mongoose.Types.ObjectId.prototype, '_id', {\n        enumerable: false,\n        configurable: true,\n        get: function() {\n          return this;\n        }\n      });\n    } else {\n      delete mongoose.Types.ObjectId.prototype._id;\n    }\n  }\n\n  return this;\n};\n\n/**\n * Gets mongoose options\n *\n * ####Example:\n *\n *     mongoose.get('test') // returns the 'test' value\n *\n * @param {String} key\n * @method get\n * @api public\n */\n\nMongoose.prototype.get = Mongoose.prototype.set;\n\n/**\n * Creates a Connection instance.\n *\n * Each `connection` instance maps to a single database. This method is helpful when mangaging multiple db connections.\n *\n *\n * _Options passed take precedence over options included in connection strings._\n *\n * ####Example:\n *\n *     // with mongodb:// URI\n *     db = mongoose.createConnection('mongodb://user:pass@localhost:port/database');\n *\n *     // and options\n *     var opts = { db: { native_parser: true }}\n *     db = mongoose.createConnection('mongodb://user:pass@localhost:port/database', opts);\n *\n *     // replica sets\n *     db = mongoose.createConnection('mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database');\n *\n *     // and options\n *     var opts = { replset: { strategy: 'ping', rs_name: 'testSet' }}\n *     db = mongoose.createConnection('mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/database', opts);\n *\n *     // and options\n *     var opts = { server: { auto_reconnect: false }, user: 'username', pass: 'mypassword' }\n *     db = mongoose.createConnection('localhost', 'database', port, opts)\n *\n *     // initialize now, connect later\n *     db = mongoose.createConnection();\n *     db.open('localhost', 'database', port, [opts]);\n *\n * @param {String} [uri] a mongodb:// URI\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html), except for 4 mongoose-specific options explained below.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](http://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @return {Connection} the created Connection object. Connections are thenable, so you can do `await mongoose.createConnection()`\n * @api public\n */\n\nMongoose.prototype.createConnection = function(uri, options, callback) {\n  const conn = new Connection(this);\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  this.connections.push(conn);\n\n  if (arguments.length > 0) {\n    return conn.openUri(uri, options, callback);\n  }\n\n  return conn;\n};\n\n/**\n * Opens the default mongoose connection.\n *\n * ####Example:\n *\n *     mongoose.connect('mongodb://user:pass@localhost:port/database');\n *\n *     // replica sets\n *     var uri = 'mongodb://user:pass@localhost:port,anotherhost:port,yetanother:port/mydatabase';\n *     mongoose.connect(uri);\n *\n *     // with options\n *     mongoose.connect(uri, options);\n *\n *     // optional callback that gets fired when initial connection completed\n *     var uri = 'mongodb://nonexistent.domain:27000';\n *     mongoose.connect(uri, function(error) {\n *       // if error is truthy, the initial connection failed.\n *     })\n *\n * @param {String} uri(s)\n * @param {Object} [options] passed down to the [MongoDB driver's `connect()` function](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html), except for 4 mongoose-specific options explained below.\n * @param {String} [options.dbName] The name of the database we want to use. If not provided, use database name from connection string.\n * @param {String} [options.user] username for authentication, equivalent to `options.auth.user`. Maintained for backwards compatibility.\n * @param {String} [options.pass] password for authentication, equivalent to `options.auth.password`. Maintained for backwards compatibility.\n * @param {Boolean} [options.autoIndex=true] Mongoose-specific option. Set to false to disable automatic index creation for all models associated with this connection.\n * @param {Boolean} [options.bufferCommands=true] Mongoose specific option. Set to false to [disable buffering](http://mongoosejs.com/docs/faq.html#callback_never_executes) on all models associated with this connection.\n * @param {Boolean} [options.useCreateIndex=true] Mongoose-specific option. If `true`, this connection will use [`createIndex()` instead of `ensureIndex()`](/docs/deprecations.html#-ensureindex-) for automatic index builds via [`Model.init()`](/docs/api.html#model_Model.init).\n * @param {Boolean} [options.useFindAndModify=true] True by default. Set to `false` to make `findOneAndUpdate()` and `findOneAndRemove()` use native `findOneAndUpdate()` rather than `findAndModify()`.\n * @param {Boolean} [options.useNewUrlParser=false] False by default. Set to `true` to make all connections set the `useNewUrlParser` option by default.\n * @param {Function} [callback]\n * @see Mongoose#createConnection #index_Mongoose-createConnection\n * @api public\n * @return {Promise} resolves to `this` if connection succeeded\n */\n\nMongoose.prototype.connect = function() {\n  const conn = this.connection;\n  return conn.openUri(arguments[0], arguments[1], arguments[2]).then(() => this);\n};\n\n/**\n * Runs `.close()` on all connections in parallel.\n *\n * @param {Function} [callback] called after all connection close, or when first error occurred.\n * @return {Promise} resolves when all connections are closed, or rejects with the first error that occurred.\n * @api public\n */\n\nMongoose.prototype.disconnect = function(callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    let remaining = this.connections.length;\n    if (remaining <= 0) {\n      return cb(null);\n    }\n    this.connections.forEach(conn => {\n      conn.close(function(error) {\n        if (error) {\n          return cb(error);\n        }\n        if (!--remaining) {\n          cb(null);\n        }\n      });\n    });\n  });\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),\n * and [transactions](http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `mongoose.startSession()` is equivalent to calling `mongoose.connection.startSession()`.\n * Sessions are scoped to a connection, so calling `mongoose.startSession()`\n * starts a session on the [default mongoose connection](/docs/api.html#mongoose_Mongoose-connection).\n *\n * @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @param {Function} [callback]\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nMongoose.prototype.startSession = function() {\n  return this.connection.startSession.apply(this.connection, arguments);\n};\n\n/**\n * Getter/setter around function for pluralizing collection names.\n *\n * @param {Function|null} [fn] overwrites the function used to pluralize collection names\n * @return {Function|null} the current function used to pluralize collection names, defaults to the legacy function from `mongoose-legacy-pluralize`.\n * @api public\n */\n\nMongoose.prototype.pluralize = function(fn) {\n  if (arguments.length > 0) {\n    this._pluralize = fn;\n  }\n  return this._pluralize;\n};\n\n/**\n * Defines a model or retrieves it.\n *\n * Models defined on the `mongoose` instance are available to all connection created by the same `mongoose` instance.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *\n *     // define an Actor model with this mongoose instance\n *     mongoose.model('Actor', new Schema({ name: String }));\n *\n *     // create a new connection\n *     var conn = mongoose.createConnection(..);\n *\n *     // retrieve the Actor model\n *     var Actor = conn.model('Actor');\n *\n * _When no `collection` argument is passed, Mongoose uses the model name. If you don't like this behavior, either pass a collection name, use `mongoose.pluralize()`, or set your schemas collection name option._\n *\n * ####Example:\n *\n *     var schema = new Schema({ name: String }, { collection: 'actor' });\n *\n *     // or\n *\n *     schema.set('collection', 'actor');\n *\n *     // or\n *\n *     var collectionName = 'actor'\n *     var M = mongoose.model('Actor', schema, collectionName)\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} [schema]\n * @param {String} [collection] name (optional, inferred from model name)\n * @param {Boolean} [skipInit] whether to skip initialization (defaults to false)\n * @return {Model}\n * @api public\n */\n\nMongoose.prototype.model = function(name, schema, collection, skipInit) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = model.name;\n    if (!(model.prototype instanceof Model)) {\n      throw new mongoose.Error('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  if (typeof schema === 'string') {\n    collection = schema;\n    schema = false;\n  }\n\n  if (utils.isObject(schema) && !(schema.instanceOfSchema)) {\n    schema = new Schema(schema);\n  }\n  if (schema && !schema.instanceOfSchema) {\n    throw new Error('The 2nd parameter to `mongoose.model()` should be a ' +\n      'schema or a POJO');\n  }\n\n  if (typeof collection === 'boolean') {\n    skipInit = collection;\n    collection = null;\n  }\n\n  // handle internal options from connection.model()\n  let options;\n  if (skipInit && utils.isObject(skipInit)) {\n    options = skipInit;\n    skipInit = true;\n  } else {\n    options = {};\n  }\n\n  // look up schema for the collection.\n  if (!this.modelSchemas[name]) {\n    if (schema) {\n      // cache it so we only apply plugins once\n      this.modelSchemas[name] = schema;\n    } else {\n      throw new mongoose.Error.MissingSchemaError(name);\n    }\n  }\n\n  const originalSchema = schema;\n  if (schema) {\n    if (this.get('cloneSchemas')) {\n      schema = schema.clone();\n    }\n    this._applyPlugins(schema);\n  }\n\n  let sub;\n\n  // connection.model() may be passing a different schema for\n  // an existing model name. in this case don't read from cache.\n  if (this.models[name] && options.cache !== false) {\n    if (originalSchema && originalSchema.instanceOfSchema && originalSchema !== this.models[name].schema) {\n      throw new mongoose.Error.OverwriteModelError(name);\n    }\n\n    if (collection) {\n      // subclass current model with alternate collection\n      model = this.models[name];\n      schema = model.prototype.schema;\n      sub = model.__subclass(this.connection, schema, collection);\n      // do not cache the sub model\n      return sub;\n    }\n\n    return this.models[name];\n  }\n\n  // ensure a schema exists\n  if (!schema) {\n    schema = this.modelSchemas[name];\n    if (!schema) {\n      throw new mongoose.Error.MissingSchemaError(name);\n    }\n  }\n\n  // Apply relevant \"global\" options to the schema\n  if (!('pluralization' in schema.options)) {\n    schema.options.pluralization = this.options.pluralization;\n  }\n\n  if (!collection) {\n    collection = schema.get('collection') ||\n      utils.toCollectionName(name, this.pluralize());\n  }\n\n  const connection = options.connection || this.connection;\n  model = this.Model.compile(model || name, schema, collection, connection, this);\n\n  if (!skipInit) {\n    // Errors handled internally, so safe to ignore error\n    model.init(function $modelInitNoop() {});\n  }\n\n  if (options.cache === false) {\n    return model;\n  }\n\n  this.models[name] = model;\n  return this.models[name];\n};\n\n/**\n * Removes the model named `name` from the default connection, if it exists.\n * You can use this function to clean up any models you created in your tests to\n * prevent OverwriteModelErrors.\n *\n * Equivalent to `mongoose.connection.deleteModel(name)`.\n *\n * ####Example:\n *\n *     mongoose.model('User', new Schema({ name: String }));\n *     console.log(mongoose.model('User')); // Model object\n *     mongoose.deleteModel('User');\n *     console.log(mongoose.model('User')); // undefined\n *\n *     // Usually useful in a Mocha `afterEach()` hook\n *     afterEach(function() {\n *       mongoose.deleteModel(/.+/); // Delete every model\n *     });\n *\n * @api public\n * @param {String|RegExp} name if string, the name of the model to remove. If regexp, removes all models whose name matches the regexp.\n * @return {Mongoose} this\n */\n\nMongoose.prototype.deleteModel = function(name) {\n  this.connection.deleteModel(name);\n  return this;\n};\n\n/**\n * Returns an array of model names created on this instance of Mongoose.\n *\n * ####Note:\n *\n * _Does not include names of models created using `connection.model()`._\n *\n * @api public\n * @return {Array}\n */\n\nMongoose.prototype.modelNames = function() {\n  const names = Object.keys(this.models);\n  return names;\n};\n\n/**\n * Applies global plugins to `schema`.\n *\n * @param {Schema} schema\n * @api private\n */\n\nMongoose.prototype._applyPlugins = function(schema) {\n  if (schema.$globalPluginsApplied) {\n    return;\n  }\n  let i;\n  let len;\n  for (i = 0, len = this.plugins.length; i < len; ++i) {\n    schema.plugin(this.plugins[i][0], this.plugins[i][1]);\n  }\n  schema.$globalPluginsApplied = true;\n  for (i = 0, len = schema.childSchemas.length; i < len; ++i) {\n    this._applyPlugins(schema.childSchemas[i].schema);\n  }\n};\n\n/**\n * Declares a global plugin executed on all Schemas.\n *\n * Equivalent to calling `.plugin(fn)` on each Schema you create.\n *\n * @param {Function} fn plugin callback\n * @param {Object} [opts] optional options\n * @return {Mongoose} this\n * @see plugins ./plugins.html\n * @api public\n */\n\nMongoose.prototype.plugin = function(fn, opts) {\n  this.plugins.push([fn, opts]);\n  return this;\n};\n\n/**\n * The default connection of the mongoose module.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     mongoose.connect(...);\n *     mongoose.connection.on('error', cb);\n *\n * This is the connection used by default for every model created using [mongoose.model](#index_Mongoose-model).\n *\n * @memberOf Mongoose\n * @instance\n * @property connection\n * @return {Connection}\n * @api public\n */\n\nMongoose.prototype.__defineGetter__('connection', function() {\n  return this.connections[0];\n});\n\nMongoose.prototype.__defineSetter__('connection', function(v) {\n  if (v instanceof Connection) {\n    this.connections[0] = v;\n    this.models = v.models;\n  }\n});\n\n/*!\n * Driver dependent APIs\n */\n\nconst driver = global.MONGOOSE_DRIVER_PATH || './drivers/node-mongodb-native';\n\n/*!\n * Connection\n */\n\nconst Connection = require(driver + '/connection');\n\n/*!\n * Collection\n */\n\nconst Collection = require(driver + '/collection');\n\n/**\n * The Mongoose Aggregate constructor\n *\n * @method Aggregate\n * @api public\n */\n\nMongoose.prototype.Aggregate = Aggregate;\n\n/**\n * The Mongoose Collection constructor\n *\n * @method Collection\n * @api public\n */\n\nMongoose.prototype.Collection = Collection;\n\n/**\n * The Mongoose [Connection](#connection_Connection) constructor\n *\n * @memberOf Mongoose\n * @instance\n * @method Connection\n * @api public\n */\n\nMongoose.prototype.Connection = Connection;\n\n/**\n * The Mongoose version\n *\n * #### Example\n *\n *     console.log(mongoose.version); // '5.x.x'\n *\n * @property version\n * @api public\n */\n\nMongoose.prototype.version = pkg.version;\n\n/**\n * The Mongoose constructor\n *\n * The exports of the mongoose module is an instance of this class.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var mongoose2 = new mongoose.Mongoose();\n *\n * @method Mongoose\n * @api public\n */\n\nMongoose.prototype.Mongoose = Mongoose;\n\n/**\n * The Mongoose [Schema](#schema_Schema) constructor\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var Schema = mongoose.Schema;\n *     var CatSchema = new Schema(..);\n *\n * @method Schema\n * @api public\n */\n\nMongoose.prototype.Schema = Schema;\n\n/**\n * The Mongoose [SchemaType](#schematype_SchemaType) constructor\n *\n * @method SchemaType\n * @api public\n */\n\nMongoose.prototype.SchemaType = SchemaType;\n\n/**\n * The various Mongoose SchemaTypes.\n *\n * ####Note:\n *\n * _Alias of mongoose.Schema.Types for backwards compatibility._\n *\n * @property SchemaTypes\n * @see Schema.SchemaTypes #schema_Schema.Types\n * @api public\n */\n\nMongoose.prototype.SchemaTypes = Schema.Types;\n\n/**\n * The Mongoose [VirtualType](#virtualtype_VirtualType) constructor\n *\n * @method VirtualType\n * @api public\n */\n\nMongoose.prototype.VirtualType = VirtualType;\n\n/**\n * The various Mongoose Types.\n *\n * ####Example:\n *\n *     var mongoose = require('mongoose');\n *     var array = mongoose.Types.Array;\n *\n * ####Types:\n *\n * - [ObjectId](#types-objectid-js)\n * - [Buffer](#types-buffer-js)\n * - [SubDocument](#types-embedded-js)\n * - [Array](#types-array-js)\n * - [DocumentArray](#types-documentarray-js)\n *\n * Using this exposed access to the `ObjectId` type, we can construct ids on demand.\n *\n *     var ObjectId = mongoose.Types.ObjectId;\n *     var id1 = new ObjectId;\n *\n * @property Types\n * @api public\n */\n\nMongoose.prototype.Types = Types;\n\n/**\n * The Mongoose [Query](#query_Query) constructor.\n *\n * @method Query\n * @api public\n */\n\nMongoose.prototype.Query = Query;\n\n/**\n * The Mongoose [Promise](#promise_Promise) constructor.\n *\n * @memberOf Mongoose\n * @instance\n * @property Promise\n * @api public\n */\n\nObject.defineProperty(Mongoose.prototype, 'Promise', {\n  get: function() {\n    return PromiseProvider.get();\n  },\n  set: function(lib) {\n    PromiseProvider.set(lib);\n  }\n});\n\n/**\n * Storage layer for mongoose promises\n *\n * @method PromiseProvider\n * @api public\n */\n\nMongoose.prototype.PromiseProvider = PromiseProvider;\n\n/**\n * The Mongoose [Model](#model_Model) constructor.\n *\n * @method Model\n * @api public\n */\n\nMongoose.prototype.Model = Model;\n\n/**\n * The Mongoose [Document](#document-js) constructor.\n *\n * @method Document\n * @api public\n */\n\nMongoose.prototype.Document = Document;\n\n/**\n * The Mongoose DocumentProvider constructor. Mongoose users should not have to\n * use this directly\n *\n * @method DocumentProvider\n * @api public\n */\n\nMongoose.prototype.DocumentProvider = require('./document_provider');\n\n/**\n * The Mongoose ObjectId [SchemaType](/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [MongoDB ObjectIds](https://docs.mongodb.com/manual/reference/method/ObjectId/).\n * Do not use this to create a new ObjectId instance, use `mongoose.Types.ObjectId`\n * instead.\n *\n * ####Example:\n *\n *     const childSchema = new Schema({ parentId: mongoose.ObjectId });\n *\n * @property ObjectId\n * @api public\n */\n\nMongoose.prototype.ObjectId = SchemaTypes.ObjectId;\n\n/**\n * The Mongoose Decimal128 [SchemaType](/docs/schematypes.html). Used for\n * declaring paths in your schema that should be\n * [128-bit decimal floating points](http://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-decimal.html).\n * Do not use this to create a new Decimal128 instance, use `mongoose.Types.Decimal128`\n * instead.\n *\n * ####Example:\n *\n *     const vehicleSchema = new Schema({ fuelLevel: mongoose.Decimal128 });\n *\n * @property Decimal128\n * @api public\n */\n\nMongoose.prototype.Decimal128 = SchemaTypes.Decimal128;\n\n/**\n * The Mongoose Mixed [SchemaType](/docs/schematypes.html). Used for\n * declaring paths in your schema that Mongoose's change tracking, casting,\n * and validation should ignore.\n *\n * ####Example:\n *\n *     const schema = new Schema({ arbitrary: mongoose.Mixed });\n *\n * @property Mixed\n * @api public\n */\n\nMongoose.prototype.Mixed = SchemaTypes.Mixed;\n\n/**\n * The [MongooseError](#error_MongooseError) constructor.\n *\n * @method Error\n * @api public\n */\n\nMongoose.prototype.Error = require('./error');\n\n/**\n * Mongoose uses this function to get the current time when setting\n * [timestamps](/docs/guide.html#timestamps). You may stub out this function\n * using a tool like [Sinon](https://www.npmjs.com/package/sinon) for testing.\n *\n * @method now\n * @returns Date the current time\n * @api public\n */\n\nMongoose.prototype.now = function now() { return new Date(); };\n\n/**\n * The Mongoose CastError constructor\n *\n * @method CastError\n * @param {String} type The name of the type\n * @param {Any} value The value that failed to cast\n * @param {String} path The path `a.b.c` in the doc where this cast error occurred\n * @param {Error} [reason] The original error that was thrown\n * @api public\n */\n\nMongoose.prototype.CastError = require('./error/cast');\n\n/**\n * The [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) driver Mongoose uses.\n *\n * @property mongo\n * @api public\n */\n\nMongoose.prototype.mongo = require('mongodb');\n\n/**\n * The [mquery](https://github.com/aheckmann/mquery) query builder Mongoose uses.\n *\n * @property mquery\n * @api public\n */\n\nMongoose.prototype.mquery = require('mquery');\n\n/*!\n * The exports object is an instance of Mongoose.\n *\n * @api public\n */\n\nconst mongoose = module.exports = exports = new Mongoose({\n  [defaultMongooseSymbol]: true\n});\n","/*!\n * Module exports.\n */\n\n'use strict';\n\nexports.Binary = require('./binary');\nexports.Collection = require('./collection');\nexports.Decimal128 = require('./decimal128');\nexports.ObjectId = require('./objectid');\nexports.ReadPreference = require('./ReadPreference');\n","\n/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst Binary = require('mongodb').Binary;\n\nmodule.exports = exports = Binary;\n","// Make sure Map exists for old Node.js versions\nvar Map = global.Map != null ? global.Map : function() {};\n\n// These properties are special and can open client libraries to security\n// issues\nvar ignoreProperties = ['__proto__', 'constructor', 'prototype'];\n\n/**\n * Returns the value of object `o` at the given `path`.\n *\n * ####Example:\n *\n *     var obj = {\n *         comments: [\n *             { title: 'exciting!', _doc: { title: 'great!' }}\n *           , { title: 'number dos' }\n *         ]\n *     }\n *\n *     mpath.get('comments.0.title', o)         // 'exciting!'\n *     mpath.get('comments.0.title', o, '_doc') // 'great!'\n *     mpath.get('comments.title', o)           // ['exciting!', 'number dos']\n *\n *     // summary\n *     mpath.get(path, o)\n *     mpath.get(path, o, special)\n *     mpath.get(path, o, map)\n *     mpath.get(path, o, special, map)\n *\n * @param {String} path\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which receives each individual found value. The value returned from `map` is used in the original values place.\n */\n\nexports.get = function (path, o, special, map) {\n  var lookup;\n\n  if ('function' == typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n\n  var parts = 'string' == typeof path\n    ? path.split('.')\n    : path\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var obj = o\n    , part;\n\n  for (var i = 0; i < parts.length; ++i) {\n    part = parts[i];\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      // reading a property from the array items\n      var paths = parts.slice(i);\n\n      return obj.map(function (item) {\n        return item\n          ? exports.get(paths, item, special || lookup, map)\n          : map(undefined);\n      });\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      var _from = special && obj[special] ? obj[special] : obj;\n      obj = _from instanceof Map ?\n        _from.get(part) :\n        _from[part];\n    }\n\n    if (!obj) return map(obj);\n  }\n\n  return map(obj);\n};\n\n/**\n * Returns true if `in` returns true for every piece of the path\n *\n * @param {String} path\n * @param {Object} o\n */\n\nexports.has = function (path, o) {\n  var parts = typeof path === 'string' ?\n    path.split('.') :\n    path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var len = parts.length;\n  var cur = o;\n  for (var i = 0; i < len; ++i) {\n    if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n      return false;\n    }\n    cur = cur[parts[i]];\n  }\n\n  return true;\n};\n\n/**\n * Deletes the last piece of `path`\n *\n * @param {String} path\n * @param {Object} o\n */\n\nexports.unset = function (path, o) {\n  var parts = typeof path === 'string' ?\n    path.split('.') :\n    path;\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  var len = parts.length;\n  var cur = o;\n  for (var i = 0; i < len; ++i) {\n    if (cur == null || typeof cur !== 'object' || !(parts[i] in cur)) {\n      return false;\n    }\n    // Disallow any updates to __proto__ or special properties.\n    if (ignoreProperties.indexOf(parts[i]) !== -1) {\n      return false;\n    }\n    if (i === len - 1) {\n      delete cur[parts[i]];\n      return true;\n    }\n    cur = cur instanceof Map ? cur.get(parts[i]) : cur[parts[i]];\n  }\n\n  return true;\n};\n\n/**\n * Sets the `val` at the given `path` of object `o`.\n *\n * @param {String} path\n * @param {Anything} val\n * @param {Object} o\n * @param {String} [special] When this property name is present on any object in the path, walking will continue on the value of this property.\n * @param {Function} [map] Optional function which is passed each individual value before setting it. The value returned from `map` is used in the original values place.\n */\n\nexports.set = function (path, val, o, special, map, _copying) {\n  var lookup;\n\n  if ('function' == typeof special) {\n    if (special.length < 2) {\n      map = special;\n      special = undefined;\n    } else {\n      lookup = special;\n      special = undefined;\n    }\n  }\n\n  map || (map = K);\n\n  var parts = 'string' == typeof path\n    ? path.split('.')\n    : path\n\n  if (!Array.isArray(parts)) {\n    throw new TypeError('Invalid `path`. Must be either string or array');\n  }\n\n  if (null == o) return;\n\n  for (var i = 0; i < parts.length; ++i) {\n    // Silently ignore any updates to `__proto__`, these are potentially\n    // dangerous if using mpath with unsanitized data.\n    if (ignoreProperties.indexOf(parts[i]) !== -1) {\n      return;\n    }\n  }\n\n  // the existance of $ in a path tells us if the user desires\n  // the copying of an array instead of setting each value of\n  // the array to the one by one to matching positions of the\n  // current array. Unless the user explicitly opted out by passing\n  // false, see Automattic/mongoose#6273\n  var copy = _copying || (/\\$/.test(path) && _copying !== false)\n    , obj = o\n    , part\n\n  for (var i = 0, len = parts.length - 1; i < len; ++i) {\n    part = parts[i];\n\n    if ('$' == part) {\n      if (i == len - 1) {\n        break;\n      } else {\n        continue;\n      }\n    }\n\n    if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n      var paths = parts.slice(i);\n      if (!copy && Array.isArray(val)) {\n        for (var j = 0; j < obj.length && j < val.length; ++j) {\n          // assignment of single values of array\n          exports.set(paths, val[j], obj[j], special || lookup, map, copy);\n        }\n      } else {\n        for (var j = 0; j < obj.length; ++j) {\n          // assignment of entire value\n          exports.set(paths, val, obj[j], special || lookup, map, copy);\n        }\n      }\n      return;\n    }\n\n    if (lookup) {\n      obj = lookup(obj, part);\n    } else {\n      var _to = special && obj[special] ? obj[special] : obj;\n      obj = _to instanceof Map ?\n        _to.get(part) :\n        _to[part];\n    }\n\n    if (!obj) return;\n  }\n\n  // process the last property of the path\n\n  part = parts[len];\n\n  // use the special property if exists\n  if (special && obj[special]) {\n    obj = obj[special];\n  }\n\n  // set the value on the last branch\n  if (Array.isArray(obj) && !/^\\d+$/.test(part)) {\n    if (!copy && Array.isArray(val)) {\n      for (var item, j = 0; j < obj.length && j < val.length; ++j) {\n        item = obj[j];\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val[j]));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val[j]);\n          }\n        }\n      }\n    } else {\n      for (var j = 0; j < obj.length; ++j) {\n        item = obj[j];\n        if (item) {\n          if (lookup) {\n            lookup(item, part, map(val));\n          } else {\n            if (item[special]) item = item[special];\n            item[part] = map(val);\n          }\n        }\n      }\n    }\n  } else {\n    if (lookup) {\n      lookup(obj, part, map(val));\n    } else if (obj instanceof Map) {\n      obj.set(part, map(val));\n    } else {\n      obj[part] = map(val);\n    }\n  }\n}\n\n/*!\n * Returns the value passed to it.\n */\n\nfunction K (v) {\n  return v;\n}\n","/*!\n * Dependencies\n */\n\n'use strict';\n\nconst StateMachine = require('./statemachine');\nconst ActiveRoster = StateMachine.ctor('require', 'modify', 'init', 'default', 'ignore');\n\nmodule.exports = exports = InternalCache;\n\nfunction InternalCache() {\n  this.strictMode = undefined;\n  this.selected = undefined;\n  this.shardval = undefined;\n  this.saveError = undefined;\n  this.validationError = undefined;\n  this.adhocPaths = undefined;\n  this.removing = undefined;\n  this.inserting = undefined;\n  this.saving = undefined;\n  this.version = undefined;\n  this.getters = {};\n  this._id = undefined;\n  this.populate = undefined; // what we want to populate in this doc\n  this.populated = undefined;// the _ids that have been populated\n  this.wasPopulated = false; // if this doc was the result of a population\n  this.scope = undefined;\n  this.activePaths = new ActiveRoster;\n  this.pathsToScopes = {};\n  this.cachedRequired = {};\n  this.session = null;\n\n  // embedded docs\n  this.ownerDocument = undefined;\n  this.fullPath = undefined;\n}\n","\n/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst utils = require('./utils');\n\n/*!\n * StateMachine represents a minimal `interface` for the\n * constructors it builds via StateMachine.ctor(...).\n *\n * @api private\n */\n\nconst StateMachine = module.exports = exports = function StateMachine() {\n};\n\n/*!\n * StateMachine.ctor('state1', 'state2', ...)\n * A factory method for subclassing StateMachine.\n * The arguments are a list of states. For each state,\n * the constructor's prototype gets state transition\n * methods named after each state. These transition methods\n * place their path argument into the given state.\n *\n * @param {String} state\n * @param {String} [state]\n * @return {Function} subclass constructor\n * @private\n */\n\nStateMachine.ctor = function() {\n  const states = utils.args(arguments);\n\n  const ctor = function() {\n    StateMachine.apply(this, arguments);\n    this.paths = {};\n    this.states = {};\n    this.stateNames = states;\n\n    let i = states.length,\n        state;\n\n    while (i--) {\n      state = states[i];\n      this.states[state] = {};\n    }\n  };\n\n  ctor.prototype = new StateMachine();\n\n  states.forEach(function(state) {\n    // Changes the `path`'s state to `state`.\n    ctor.prototype[state] = function(path) {\n      this._changeState(path, state);\n    };\n  });\n\n  return ctor;\n};\n\n/*!\n * This function is wrapped by the state change functions:\n *\n * - `require(path)`\n * - `modify(path)`\n * - `init(path)`\n *\n * @api private\n */\n\nStateMachine.prototype._changeState = function _changeState(path, nextState) {\n  const prevBucket = this.states[this.paths[path]];\n  if (prevBucket) delete prevBucket[path];\n\n  this.paths[path] = nextState;\n  this.states[nextState][path] = true;\n};\n\n/*!\n * ignore\n */\n\nStateMachine.prototype.clear = function clear(state) {\n  const keys = Object.keys(this.states[state]);\n  let i = keys.length;\n  let path;\n\n  while (i--) {\n    path = keys[i];\n    delete this.states[state][path];\n    delete this.paths[path];\n  }\n};\n\n/*!\n * Checks to see if at least one path is in the states passed in via `arguments`\n * e.g., this.some('required', 'inited')\n *\n * @param {String} state that we want to check for.\n * @private\n */\n\nStateMachine.prototype.some = function some() {\n  const _this = this;\n  const what = arguments.length ? arguments : this.stateNames;\n  return Array.prototype.some.call(what, function(state) {\n    return Object.keys(_this.states[state]).length;\n  });\n};\n\n/*!\n * This function builds the functions that get assigned to `forEach` and `map`,\n * since both of those methods share a lot of the same logic.\n *\n * @param {String} iterMethod is either 'forEach' or 'map'\n * @return {Function}\n * @api private\n */\n\nStateMachine.prototype._iter = function _iter(iterMethod) {\n  return function() {\n    const numArgs = arguments.length;\n    let states = utils.args(arguments, 0, numArgs - 1);\n    const callback = arguments[numArgs - 1];\n\n    if (!states.length) states = this.stateNames;\n\n    const _this = this;\n\n    const paths = states.reduce(function(paths, state) {\n      return paths.concat(Object.keys(_this.states[state]));\n    }, []);\n\n    return paths[iterMethod](function(path, i, paths) {\n      return callback(path, i, paths);\n    });\n  };\n};\n\n/*!\n * Iterates over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @private\n */\n\nStateMachine.prototype.forEach = function forEach() {\n  this.forEach = this._iter('forEach');\n  return this.forEach.apply(this, arguments);\n};\n\n/*!\n * Maps over the paths that belong to one of the parameter states.\n *\n * The function profile can look like:\n * this.forEach(state1, fn);         // iterates over all paths in state1\n * this.forEach(state1, state2, fn); // iterates over all paths in state1 or state2\n * this.forEach(fn);                 // iterates over all paths in all states\n *\n * @param {String} [state]\n * @param {String} [state]\n * @param {Function} callback\n * @return {Array}\n * @private\n */\n\nStateMachine.prototype.map = function map() {\n  this.map = this._iter('map');\n  return this.map.apply(this, arguments);\n};\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = require('./');\nconst util = require('util');\n\n/*!\n * OverwriteModel Error constructor.\n *\n * @inherits MongooseError\n */\n\nfunction DocumentNotFoundError(query) {\n  let msg;\n  const messages = MongooseError.messages;\n  if (messages.DocumentNotFoundError != null) {\n    msg = typeof messages.DocumentNotFoundError === 'function' ?\n      messages.DocumentNotFoundError(query) :\n      messages.DocumentNotFoundError;\n  } else {\n    msg = 'No document found for query \"' + util.inspect(query) + '\"';\n  }\n\n  MongooseError.call(this, msg);\n\n  this.name = 'DocumentNotFoundError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n\n  this.query = query;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nDocumentNotFoundError.prototype = Object.create(MongooseError.prototype);\nDocumentNotFoundError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = DocumentNotFoundError;\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('./');\n\n/**\n * Schema validator error\n *\n * @param {Object} properties\n * @inherits MongooseError\n * @api private\n */\n\nfunction ValidatorError(properties) {\n  let msg = properties.message;\n  if (!msg) {\n    msg = MongooseError.messages.general.default;\n  }\n\n  const message = this.formatMessage(msg, properties);\n  MongooseError.call(this, message);\n\n  properties = Object.assign({}, properties, { message: message });\n  this.name = 'ValidatorError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n  this.properties = properties;\n  this.kind = properties.type;\n  this.path = properties.path;\n  this.value = properties.value;\n  this.reason = properties.reason;\n}\n\n/*!\n * Inherits from MongooseError\n */\n\nValidatorError.prototype = Object.create(MongooseError.prototype);\nValidatorError.prototype.constructor = MongooseError;\n\n/*!\n * The object used to define this validator. Not enumerable to hide\n * it from `require('util').inspect()` output re: gh-3925\n */\n\nObject.defineProperty(ValidatorError.prototype, 'properties', {\n  enumerable: false,\n  writable: true,\n  value: null\n});\n\n/*!\n * Formats error messages\n */\n\nValidatorError.prototype.formatMessage = function(msg, properties) {\n  if (typeof msg === 'function') {\n    return msg(properties);\n  }\n  const propertyNames = Object.keys(properties);\n  for (let i = 0; i < propertyNames.length; ++i) {\n    const propertyName = propertyNames[i];\n    if (propertyName === 'message') {\n      continue;\n    }\n    msg = msg.replace('{' + propertyName.toUpperCase() + '}', properties[propertyName]);\n  }\n  return msg;\n};\n\n/*!\n * toString helper\n */\n\nValidatorError.prototype.toString = function() {\n  return this.message;\n};\n\n/*!\n * exports\n */\n\nmodule.exports = ValidatorError;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = require('./');\n\n/**\n * Version Error constructor.\n *\n * @inherits MongooseError\n * @api private\n */\n\nfunction VersionError(doc, currentVersion, modifiedPaths) {\n  const modifiedPathsStr = modifiedPaths.join(', ');\n  MongooseError.call(this, 'No matching document found for id \"' + doc._id +\n    '\" version ' + currentVersion + ' modifiedPaths \"' + modifiedPathsStr + '\"');\n  this.name = 'VersionError';\n  this.version = currentVersion;\n  this.modifiedPaths = modifiedPaths;\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nVersionError.prototype = Object.create(MongooseError.prototype);\nVersionError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = VersionError;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst MongooseError = require('./');\n\n/**\n * ParallelSave Error constructor.\n *\n * @inherits MongooseError\n * @api private\n */\n\nfunction ParallelSaveError(doc) {\n  const msg = 'Can\\'t save() the same doc multiple times in parallel. Document: ';\n  MongooseError.call(this, msg + doc.id);\n  this.name = 'ParallelSaveError';\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nParallelSaveError.prototype = Object.create(MongooseError.prototype);\nParallelSaveError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = ParallelSaveError;\n","\n/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('./');\n\n/*!\n * OverwriteModel Error constructor.\n *\n * @inherits MongooseError\n */\n\nfunction OverwriteModelError(name) {\n  MongooseError.call(this, 'Cannot overwrite `' + name + '` model once compiled.');\n  this.name = 'OverwriteModelError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nOverwriteModelError.prototype = Object.create(MongooseError.prototype);\nOverwriteModelError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = OverwriteModelError;\n","\n/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('./');\n\n/*!\n * MissingSchema Error constructor.\n *\n * @inherits MongooseError\n */\n\nfunction MissingSchemaError(name) {\n  const msg = 'Schema hasn\\'t been registered for model \"' + name + '\".\\n'\n          + 'Use mongoose.model(name, schema)';\n  MongooseError.call(this, msg);\n  this.name = 'MissingSchemaError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nMissingSchemaError.prototype = Object.create(MongooseError.prototype);\nMissingSchemaError.prototype.constructor = MongooseError;\n\n/*!\n * exports\n */\n\nmodule.exports = MissingSchemaError;\n","\n/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('./');\n\n/*!\n * DivergentArrayError constructor.\n *\n * @inherits MongooseError\n */\n\nfunction DivergentArrayError(paths) {\n  const msg = 'For your own good, using `document.save()` to update an array '\n          + 'which was selected using an $elemMatch projection OR '\n          + 'populated using skip, limit, query conditions, or exclusion of '\n          + 'the _id field when the operation results in a $pop or $set of '\n          + 'the entire array is not supported. The following '\n          + 'path(s) would have been modified unsafely:\\n'\n          + '  ' + paths.join('\\n  ') + '\\n'\n          + 'Use Model.update() to update these arrays instead.';\n  // TODO write up a docs page (FAQ) and link to it\n\n  MongooseError.call(this, msg);\n  this.name = 'DivergentArrayError';\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this);\n  } else {\n    this.stack = new Error().stack;\n  }\n}\n\n/*!\n * Inherits from MongooseError.\n */\n\nDivergentArrayError.prototype = Object.create(MongooseError.prototype);\nDivergentArrayError.prototype.constructor = MongooseError;\n\n\n/*!\n * exports\n */\n\nmodule.exports = DivergentArrayError;\n","'use strict';\n\nconst get = require('lodash.get');\n\n/*!\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = path.split('.');\n  let schema = null;\n  let type = 'adhocOrUndefined';\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schema = doc.schema.path(subpath);\n    if (schema == null) {\n      continue;\n    }\n    type = doc.schema.pathType(subpath);\n    if ((schema.$isSingleNested || schema.$isMongooseDocumentArrayElement) &&\n        schema.schema.discriminators != null) {\n      const discriminators = schema.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' +\n        get(schema, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      schema = discriminators[discriminatorKey].path(rest);\n      if (schema != null) {\n        type = discriminators[discriminatorKey].pathType(rest);\n        break;\n      }\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schema;\n};\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schema) {\n  // ensure the documents receive an id getter unless disabled\n  const autoIdGetter = !schema.paths['id'] &&\n    (!schema.options.noVirtualId && schema.options.id);\n  if (!autoIdGetter) {\n    return;\n  }\n\n  schema.virtual('id').get(idGetter);\n};\n\n/*!\n * Returns this documents _id cast to a string.\n */\n\nfunction idGetter() {\n  if (this._id != null) {\n    return String(this._id);\n  }\n\n  return null;\n}\n","'use strict';\n\nconst isDefiningProjection = require('./isDefiningProjection');\n\n/*!\n * ignore\n */\n\nmodule.exports = function isExclusive(projection) {\n  const keys = Object.keys(projection);\n  let ki = keys.length;\n  let exclude = null;\n\n  if (ki === 1 && keys[0] === '_id') {\n    exclude = !!projection[keys[ki]];\n  } else {\n    while (ki--) {\n      // Does this projection explicitly define inclusion/exclusion?\n      // Explicitly avoid `$meta` and `$slice`\n      if (keys[ki] !== '_id' && isDefiningProjection(projection[keys[ki]])) {\n        exclude = !projection[keys[ki]];\n        break;\n      }\n    }\n  }\n\n  return exclude;\n};\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst NodeJSDocument = require('./document');\nconst EventEmitter = require('events').EventEmitter;\nconst MongooseError = require('./error');\nconst Schema = require('./schema');\nconst ObjectId = require('./types/objectid');\nconst ValidationError = MongooseError.ValidationError;\nconst applyHooks = require('./helpers/model/applyHooks');\nconst utils = require('./utils');\n\n/**\n * Document constructor.\n *\n * @param {Object} obj the values to set\n * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data\n * @param {Boolean} [skipId] bool, should we auto create an ObjectId _id\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `init`: Emitted on a document after it has was retrieved from the db and fully hydrated by Mongoose.\n * @event `save`: Emitted when the document is successfully saved\n * @api private\n */\n\nfunction Document(obj, schema, fields, skipId, skipInit) {\n  if (!(this instanceof Document)) {\n    return new Document(obj, schema, fields, skipId, skipInit);\n  }\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n\n  // When creating EmbeddedDocument, it already has the schema and he doesn't need the _id\n  schema = this.schema || schema;\n\n  // Generate ObjectId if it is missing, but it requires a scheme\n  if (!this.schema && schema.options._id) {\n    obj = obj || {};\n\n    if (obj._id === undefined) {\n      obj._id = new ObjectId();\n    }\n  }\n\n  if (!schema) {\n    throw new MongooseError.MissingSchemaError();\n  }\n\n  this.$__setSchema(schema);\n\n  NodeJSDocument.call(this, obj, fields, skipId, skipInit);\n\n  applyHooks(this, schema, { decorateDoc: true });\n\n  // apply methods\n  for (const m in schema.methods) {\n    this[m] = schema.methods[m];\n  }\n  // apply statics\n  for (const s in schema.statics) {\n    this[s] = schema.statics[s];\n  }\n}\n\n/*!\n * Inherit from the NodeJS document\n */\n\nDocument.prototype = Object.create(NodeJSDocument.prototype);\nDocument.prototype.constructor = Document;\n\n/*!\n * Browser doc exposes the event emitter API\n */\n\nDocument.$emitter = new EventEmitter();\n\nutils.each(\n  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',\n    'removeAllListeners', 'addListener'],\n  function(emitterFn) {\n    Document[emitterFn] = function() {\n      return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);\n    };\n  });\n\n/*!\n * Module exports.\n */\n\nDocument.ValidationError = ValidationError;\nmodule.exports = exports = Document;\n","'use strict';\n\nconst get = require('lodash.get');\nconst utils = require('../../utils');\n\n/*!\n * Gather all indexes defined in the schema, including single nested,\n * document arrays, and embedded discriminators.\n */\n\nmodule.exports = function getIndexes(schema) {\n  let indexes = [];\n  const schemaStack = new WeakMap();\n  const indexTypes = schema.constructor.indexTypes;\n\n  const collectIndexes = function(schema, prefix) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.has(schema)) {\n      return;\n    }\n    schemaStack.set(schema, true);\n\n    prefix = prefix || '';\n    const keys = Object.keys(schema.paths);\n    const length = keys.length;\n\n    for (let i = 0; i < length; ++i) {\n      const key = keys[i];\n      const path = schema.paths[key];\n\n      if (path.$isMongooseDocumentArray || path.$isSingleNested) {\n        if (get(path, 'options.excludeIndexes') !== true &&\n            get(path, 'schemaOptions.excludeIndexes') !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n\n        if (path.schema.discriminators != null) {\n          const discriminators = path.schema.discriminators;\n          const discriminatorKeys = Object.keys(discriminators);\n          for (const discriminatorKey of discriminatorKeys) {\n            collectIndexes(discriminators[discriminatorKey]._originalSchema,\n              prefix + key + '.');\n          }\n        }\n\n        // Retained to minimize risk of backwards breaking changes due to\n        // gh-6113\n        if (path.$isMongooseDocumentArray) {\n          continue;\n        }\n      }\n\n      const index = path._index || (path.caster && path.caster._index);\n\n      if (index !== false && index !== null && index !== undefined) {\n        const field = {};\n        const isObject = utils.isObject(index);\n        const options = isObject ? index : {};\n        const type = typeof index === 'string' ? index :\n          isObject ? index.type :\n            false;\n\n        if (type && indexTypes.indexOf(type) !== -1) {\n          field[prefix + key] = type;\n        } else if (options.text) {\n          field[prefix + key] = 'text';\n          delete options.text;\n        } else {\n          field[prefix + key] = 1;\n        }\n\n        delete options.type;\n        if (!('background' in options)) {\n          options.background = true;\n        }\n\n        indexes.push([field, options]);\n      }\n    }\n\n    schemaStack.delete(schema);\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        if (!('background' in index[1])) {\n          index[1].background = true;\n        }\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  };\n\n  collectIndexes(schema);\n  return indexes;\n\n  /*!\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    const subindexes = schema._indexes;\n    const len = subindexes.length;\n    for (let i = 0; i < len; ++i) {\n      const indexObj = subindexes[i][0];\n      const keys = Object.keys(indexObj);\n      const klen = keys.length;\n      const newindex = {};\n\n      // use forward iteration, order matters\n      for (let j = 0; j < klen; ++j) {\n        const key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      indexes.push([newindex, subindexes[i][1]]);\n    }\n  }\n};\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ArrayType = require('./array');\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaType = require('../schematype');\nconst discriminator = require('../helpers/model/discriminator');\nconst util = require('util');\nconst utils = require('../utils');\nconst getDiscriminatorByValue = require('../queryhelpers').getDiscriminatorByValue;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @inherits SchemaArray\n * @api public\n */\n\nfunction DocumentArray(key, schema, options, schemaOptions) {\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  ArrayType.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn !== void 0) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (!Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDocumentArray.schemaName = 'DocumentArray';\n\n/*!\n * Inherits from ArrayType.\n */\nDocumentArray.prototype = Object.create(ArrayType.prototype);\nDocumentArray.prototype.constructor = DocumentArray;\n\n/*!\n * Ignore\n */\n\nfunction _createConstructor(schema, options) {\n  Subdocument || (Subdocument = require('../types/embedded'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n\n    this.$session(this.ownerDocument().$session());\n  }\n\n  EmbeddedDocument.prototype = Object.create(Subdocument.prototype);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/*!\n * Ignore\n */\n\nDocumentArray.prototype.discriminator = function(name, schema) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema);\n\n  const EmbeddedDocument = _createConstructor(schema);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    err.$isArrayValidatorError = true;\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      err.$isArrayValidatorError = true;\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!array.isMongooseDocumentArray) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n        if (error.name !== 'ValidationError') {\n          error.$isArrayValidatorError = true;\n        }\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        doc = array[i] = new _this.casterConstructor(doc, array, undefined,\n          undefined, i);\n      }\n\n      doc.$__validate(callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * ####Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nDocumentArray.prototype.doValidateSync = function(array, scope) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    schemaTypeError.$isArrayValidatorError = true;\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // only first error\n    if (resultError) {\n      break;\n    }\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      doc = array[i] = new this.casterConstructor(doc, array, undefined,\n        undefined, i);\n    }\n\n    const subdocValidateError = doc.validateSync();\n\n    if (subdocValidateError) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentarray'));\n\n  let selected;\n  let subdoc;\n  let i;\n  const _opts = { transform: false, virtuals: false };\n\n  if (!Array.isArray(value)) {\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init, prev);\n  }\n\n  if (!(value && value.isMongooseDocumentArray) &&\n      (!options || !options.skipDocumentArrayCast)) {\n    value = new MongooseDocumentArray(value, this.path, doc);\n    _clearListeners(prev);\n  } else if (value && value.isMongooseDocumentArray) {\n    // We need to create a new array, otherwise change tracking will\n    // update the old doc (gh-4449)\n    value = new MongooseDocumentArray(value, this.path, doc);\n  }\n\n  i = value.length;\n\n  while (i--) {\n    if (!value[i]) {\n      continue;\n    }\n\n    let Constructor = this.casterConstructor;\n    if (Constructor.discriminators &&\n        Constructor.schema &&\n        Constructor.schema.options &&\n        typeof value[i][Constructor.schema.options.discriminatorKey] === 'string') {\n      if (Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]]) {\n        Constructor = Constructor.discriminators[value[i][Constructor.schema.options.discriminatorKey]];\n      } else {\n        const constructorByValue = getDiscriminatorByValue(Constructor, value[i][Constructor.schema.options.discriminatorKey]);\n        if (constructorByValue) {\n          Constructor = constructorByValue;\n        }\n      }\n    }\n\n    // Check if the document has a different schema (re gh-3701)\n    if ((value[i].$__) &&\n        value[i].schema !== Constructor.schema) {\n      value[i] = value[i].toObject({ transform: false, virtuals: false });\n    }\n    if (!(value[i] instanceof Subdocument) && value[i]) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, true, selected, i);\n        value[i] = subdoc.init(value[i]);\n      } else {\n        if (prev && (subdoc = prev.id(value[i]._id))) {\n          subdoc = prev.id(value[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_opts), value[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(value[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          value[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(value[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            value[i] = subdoc;\n          } catch (error) {\n            // Make sure we don't leave listeners dangling because `value`\n            // won't get back up to the schema type. See gh-6723\n            _clearListeners(value);\n            const valueInErrorMessage = util.inspect(value[i]);\n            throw new CastError('embedded', valueInErrorMessage,\n              value._path, error);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * Removes listeners from parent\n */\n\nfunction _clearListeners(arr) {\n  if (arr == null || arr._parent == null) {\n    return;\n  }\n\n  for (const key in arr._handlers) {\n    arr._parent.removeListener(key, arr._handlers[key]);\n  }\n}\n\n/*!\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArray} array - the array to scope `fields` paths\n * @param {Object|undefined} fields - the root fields selected in the query\n * @param {Boolean|undefined} init - if we are being created part of a query result\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.indexOf(path) === 0) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.indexOf('$.') === 0) {\n        sub = sub.substr(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = DocumentArray;\n","'use strict';\n\nconst CastError = require('../../error/cast');\nconst castBoolean = require('../../cast/boolean');\nconst castString = require('../../cast/string');\n\n/*!\n * Casts val to an object suitable for `$text`. Throws an error if the object\n * can't be casted.\n *\n * @param {Any} val value to cast\n * @param {String} [path] path to associate with any errors that occured\n * @return {Object} casted object\n * @see https://docs.mongodb.com/manual/reference/operator/query/text/\n * @api private\n */\n\nmodule.exports = function(val, path) {\n  if (val == null || typeof val !== 'object') {\n    throw new CastError('$text', val, path);\n  }\n\n  if (val.$search != null) {\n    val.$search = castString(val.$search, path + '.$search');\n  }\n  if (val.$language != null) {\n    val.$language = castString(val.$language, path + '.$language');\n  }\n  if (val.$caseSensitive != null) {\n    val.$caseSensitive = castBoolean(val.$caseSensitive,\n      path + '.$castSensitive');\n  }\n  if (val.$diacriticSensitive != null) {\n    val.$diacriticSensitive = castBoolean(val.$diacriticSensitive,\n      path + '.$diacriticSensitive');\n  }\n\n  return val;\n};\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst ObjectExpectedError = require('../error/objectExpected');\nconst SchemaType = require('../schematype');\nconst $exists = require('./operators/exists');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst discriminator = require('../helpers/model/discriminator');\nconst geospatial = require('./operators/geospatial');\nconst get = require('lodash.get');\nconst getDiscriminatorByValue = require('../queryhelpers').getDiscriminatorByValue;\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\n\nlet Subdocument;\n\nmodule.exports = Embedded;\n\n/**\n * Sub-schema schematype constructor\n *\n * @param {Schema} schema\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Embedded(schema, path, options) {\n  this.caster = _createConstructor(schema);\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\n * ignore\n */\n\nEmbedded.prototype = Object.create(SchemaType.prototype);\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema) {\n  // lazy load\n  Subdocument || (Subdocument = require('../types/subdocument'));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    const _this = this;\n\n    this.$parent = parent;\n    Subdocument.apply(this, arguments);\n\n    this.$session(this.ownerDocument().$session());\n\n    if (parent) {\n      parent.on('save', function() {\n        _this.emit('save', _this);\n        _this.constructor.emit('save', _this);\n      });\n\n      parent.on('isNew', function(val) {\n        _this.isNew = val;\n        _this.emit('isNew', val);\n        _this.constructor.emit('isNew', val);\n      });\n    }\n  };\n  _embedded.prototype = Object.create(Subdocument.prototype);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/*!\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://docs.mongodb.org/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\nEmbedded.prototype.$conditionalHandlers.$geoWithin = function handle$geoWithin(val) {\n  return { $geometry: this.castForQuery(val.$geometry) };\n};\n\n/*!\n * ignore\n */\n\nEmbedded.prototype.$conditionalHandlers.$near =\nEmbedded.prototype.$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\nEmbedded.prototype.$conditionalHandlers.$within =\nEmbedded.prototype.$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\nEmbedded.prototype.$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\nEmbedded.prototype.$conditionalHandlers.$minDistance = castToNumber;\nEmbedded.prototype.$conditionalHandlers.$maxDistance = castToNumber;\n\nEmbedded.prototype.$conditionalHandlers.$exists = $exists;\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nEmbedded.prototype.cast = function(val, doc, init, priorVal) {\n  if (val && val.$isSingleNested) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  let Constructor = this.caster;\n  const discriminatorKey = Constructor.schema.options.discriminatorKey;\n  if (val != null &&\n      Constructor.discriminators &&\n      typeof val[discriminatorKey] === 'string') {\n    if (Constructor.discriminators[val[discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor, val[discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = get(doc, '$__.selected', {});\n  const path = this.path;\n  const selected = Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj[key.substr(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, {});\n\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc);\n    subdoc.init(val);\n  } else {\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc);\n    }\n\n    return new Constructor(val, selected, doc, undefined, { priorDoc: priorVal });\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nEmbedded.prototype.castForQuery = function($conditional, val) {\n  let handler;\n  if (arguments.length === 2) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  val = $conditional;\n  if (val == null) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val);\n  }\n\n  let Constructor = this.caster;\n  const discriminatorKey = Constructor.schema.options.discriminatorKey;\n  if (val != null &&\n      Constructor.discriminators &&\n      typeof val[discriminatorKey] === 'string') {\n    if (Constructor.discriminators[val[discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor, val[discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  try {\n    val = new Constructor(val);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nEmbedded.prototype.doValidate = function(value, fn, scope, options) {\n  let Constructor = this.caster;\n  const discriminatorKey = Constructor.schema.options.discriminatorKey;\n  if (value != null &&\n      Constructor.discriminators &&\n      typeof value[discriminatorKey] === 'string') {\n    if (Constructor.discriminators[value[discriminatorKey]]) {\n      Constructor = Constructor.discriminators[value[discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor, value[discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  if (options && options.skipSchemaValidators) {\n    if (!(value instanceof Constructor)) {\n      value = new Constructor(value, null, scope);\n    }\n\n    return value.validate(fn);\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate(fn);\n  }, scope);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nEmbedded.prototype.doValidateSync = function(value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this property\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @api public\n */\n\nEmbedded.prototype.discriminator = function(name, schema) {\n  discriminator(this.caster, name, schema);\n\n  this.caster.discriminators[name] = _createConstructor(schema);\n\n  return this.caster.discriminators[name];\n};\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst SchemaType = require('../schematype');\nconst CastError = SchemaType.CastError;\nconst Decimal128Type = require('../types/decimal128');\nconst utils = require('../utils');\nlet Document;\n\n/**\n * Decimal128 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction Decimal128(key, options) {\n  SchemaType.call(this, key, options, 'Decimal128');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nDecimal128.schemaName = 'Decimal128';\n\n/*!\n * Inherits from SchemaType.\n */\nDecimal128.prototype = Object.create(SchemaType.prototype);\nDecimal128.prototype.constructor = Decimal128;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nDecimal128.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return value instanceof Decimal128Type;\n};\n\n/**\n * Casts to Decimal128\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nDecimal128.prototype.cast = function(value, doc, init) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // lazy load\n    Document || (Document = require('./../document'));\n\n    if (value instanceof Document) {\n      value.$__.wasPopulated = true;\n      return value;\n    }\n\n    // setting a populated path\n    if (value instanceof Decimal128Type) {\n      return value;\n    } else if (Buffer.isBuffer(value) || !utils.isObject(value)) {\n      throw new CastError('Decimal128', value, this.path);\n    }\n\n    // Handle the case where user directly sets a populated\n    // path to a plain object; cast to the Model used in\n    // the population query.\n    const path = doc.$__fullPath(this.path);\n    const owner = doc.ownerDocument ? doc.ownerDocument() : doc;\n    const pop = owner.populated(path, true);\n    let ret = value;\n    if (!doc.$__.populated ||\n        !doc.$__.populated[path] ||\n        !doc.$__.populated[path].options ||\n        !doc.$__.populated[path].options.options ||\n        !doc.$__.populated[path].options.options.lean) {\n      ret = new pop.options.model(value);\n      ret.$__.wasPopulated = true;\n    }\n\n    return ret;\n  }\n\n  if (value == null) {\n    return value;\n  }\n\n  if (typeof value === 'object' && typeof value.$numberDecimal === 'string') {\n    return Decimal128Type.fromString(value.$numberDecimal);\n  }\n\n  if (value instanceof Decimal128Type) {\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    return Decimal128Type.fromString(value);\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return new Decimal128Type(value);\n  }\n\n  if (typeof value === 'number') {\n    return Decimal128Type.fromString(String(value));\n  }\n\n  if (typeof value.valueOf === 'function' && typeof value.valueOf() === 'string') {\n    return Decimal128Type.fromString(value.valueOf());\n  }\n\n  throw new CastError('Decimal128', value, this.path);\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nDecimal128.prototype.$conditionalHandlers =\n    utils.options(SchemaType.prototype.$conditionalHandlers, {\n      $gt: handleSingle,\n      $gte: handleSingle,\n      $lt: handleSingle,\n      $lte: handleSingle\n    });\n\n/*!\n * Module exports.\n */\n\nmodule.exports = Decimal128;\n","/*!\n * ignore\n */\n\n'use strict';\n\nmodule.exports = require('mongodb').Decimal128;\n","\n/*!\n * [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) ObjectId\n * @constructor NodeMongoDbObjectId\n * @see ObjectId\n */\n\n'use strict';\n\nconst ObjectId = require('mongodb').ObjectId;\n\n/*!\n * ignore\n */\n\nmodule.exports = exports = ObjectId;\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst mongodb = require('mongodb');\nconst ReadPref = mongodb.ReadPreference;\n\n/*!\n * Converts arguments to ReadPrefs the driver\n * can understand.\n *\n * @param {String|Array} pref\n * @param {Array} [tags]\n */\n\nmodule.exports = function readPref(pref, tags) {\n  if (Array.isArray(pref)) {\n    tags = pref[1];\n    pref = pref[0];\n  }\n\n  if (pref instanceof ReadPref) {\n    return pref;\n  }\n\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return new ReadPref(pref, tags);\n};\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst Readable = require('stream').Readable;\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst helpers = require('../queryhelpers');\nconst util = require('util');\nconst utils = require('../utils');\n\n/**\n * A QueryCursor is a concurrency primitive for processing query results\n * one document at a time. A QueryCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * QueryCursors execute the model's pre find hooks, but **not** the model's\n * post find hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Query#cursor()`](/docs/api.html#query_Query-cursor) instead.\n *\n * @param {Query} query\n * @param {Object} options query options passed to `.find()`\n * @inherits Readable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction QueryCursor(query, options) {\n  Readable.call(this, { objectMode: true });\n\n  this.cursor = null;\n  this.query = query;\n  const _this = this;\n  const model = query.model;\n  this._mongooseOptions = {};\n  this._transforms = [];\n  model.hooks.execPre('find', query, () => {\n    this._transforms = this._transforms.concat(query._transforms.slice());\n    if (options.transform) {\n      this._transforms.push(options.transform);\n    }\n    model.collection.find(query._conditions, options, function(err, cursor) {\n      if (_this._error) {\n        cursor.close(function() {});\n        _this.listeners('error').length > 0 && _this.emit('error', _this._error);\n      }\n      if (err) {\n        return _this.emit('error', err);\n      }\n      _this.cursor = cursor;\n      _this.emit('cursor', cursor);\n    });\n  });\n}\n\nutil.inherits(QueryCursor, Readable);\n\n/*!\n * Necessary to satisfy the Readable API\n */\n\nQueryCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n        setTimeout(function() {\n          _this.emit('close');\n        }, 0);\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * ####Example\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     var cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {QueryCursor}\n * @api public\n * @method map\n */\n\nQueryCursor.prototype.map = function(fn) {\n  this._transforms.push(fn);\n  return this;\n};\n\n/*!\n * Marks this cursor as errored\n */\n\nQueryCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see MongoDB driver cursor#close http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close\n */\n\nQueryCursor.prototype.close = function(callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    this.cursor.close(error => {\n      if (error) {\n        cb(error);\n        return this.listeners('error').length > 0 && this.emit('error', error);\n      }\n      this.emit('close');\n      cb(null);\n    });\n  });\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method next\n */\n\nQueryCursor.prototype.next = function(callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    _next(this, function(error, doc) {\n      if (error) {\n        return cb(error);\n      }\n      cb(null, doc);\n    });\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nQueryCursor.prototype.eachAsync = function(fn, opts, callback) {\n  const _this = this;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);\n};\n\n/**\n * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nQueryCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nQueryCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/*!\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn.call(ctx, doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return process.nextTick(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next(function(error, doc) {\n      if (error) {\n        return callback(error);\n      }\n      if (!doc) {\n        return callback(null, null);\n      }\n\n      const opts = ctx.query._mongooseOptions;\n      if (!opts.populate) {\n        return opts.lean ?\n          callback(null, doc) :\n          _create(ctx, doc, null, callback);\n      }\n\n      const pop = helpers.preparePopulationOptionsMQ(ctx.query,\n        ctx.query._mongooseOptions);\n      pop.__noPromise = true;\n      ctx.query.model.populate(doc, pop, function(err, doc) {\n        if (err) {\n          return callback(err);\n        }\n        return opts.lean ?\n          callback(null, doc) :\n          _create(ctx, doc, pop, callback);\n      });\n    });\n  } else {\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function() {\n    cb();\n  });\n}\n\n/*!\n * Convert a raw doc into a full mongoose doc.\n */\n\nfunction _create(ctx, doc, populatedIds, cb) {\n  const instance = helpers.createModel(ctx.query.model, doc, ctx.query._fields);\n  const opts = populatedIds ?\n    { populated: populatedIds } :\n    undefined;\n\n  instance.init(doc, opts, function(err) {\n    if (err) {\n      return cb(err);\n    }\n    cb(null, instance);\n  });\n}\n\nmodule.exports = QueryCursor;\n","'use strict';\n\nconst get = require('lodash.get');\n\n/*!\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.').\n      replace(/\\.\\$\\./i, '.0.').replace(/\\.\\$$/, '.0');\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const discriminators = schematype.schema.discriminators;\n      const discriminatorValuePath = subpath + '.' +\n        get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminators[discriminatorKey].path(rest);\n      if (schematype != null) {\n        type = discriminators[discriminatorKey]._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n","'use strict';\n\nconst helpers = require('../../queryhelpers');\n\nmodule.exports = completeMany;\n\n/*!\n * Given a model and an array of docs, hydrates all the docs to be instances\n * of the model. Used to initialize docs returned from the db from `find()`\n *\n * @param {Model} model\n * @param {Array} docs\n * @param {Object} fields the projection used, including `select` from schemas\n * @param {Object} userProvidedFields the user-specified projection\n * @param {Object} opts\n * @param {Array} [opts.populated]\n * @param {ClientSession} [opts.session]\n * @param {Function} callback\n */\n\nfunction completeMany(model, docs, fields, userProvidedFields, opts, callback) {\n  const arr = [];\n  let count = docs.length;\n  const len = count;\n  let error = null;\n\n  function init(_error) {\n    if (_error != null) {\n      error = error || _error;\n    }\n    if (error != null) {\n      --count || process.nextTick(() => callback(error));\n      return;\n    }\n    --count || process.nextTick(() => callback(error, arr));\n  }\n\n  for (let i = 0; i < len; ++i) {\n    arr[i] = helpers.createModel(model, docs[i], fields, userProvidedFields);\n    try {\n      arr[i].init(docs[i], opts, init);\n    } catch (error) {\n      init(error);\n    }\n    arr[i].$session(opts.session);\n  }\n}\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function(obj) {\n  const keys = Object.keys(obj);\n  const len = keys.length;\n  for (let i = 0; i < len; ++i) {\n    if (keys[i].charAt(0) === '$') {\n      return true;\n    }\n  }\n  return false;\n};\n","'use strict';\n\nconst isDefiningProjection = require('./isDefiningProjection');\n\n/*!\n * ignore\n */\n\nmodule.exports = function isInclusive(projection) {\n  if (projection == null) {\n    return false;\n  }\n\n  const props = Object.keys(projection);\n  const numProps = props.length;\n  if (numProps === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < numProps; ++i) {\n    const prop = props[i];\n    // Plus paths can't define the projection (see gh-7050)\n    if (prop.charAt(0) === '+') {\n      continue;\n    }\n    // If field is truthy (1, true, etc.) and not an object, then this\n    // projection must be inclusive. If object, assume its $meta, $slice, etc.\n    if (isDefiningProjection(projection[prop]) && !!projection[prop]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function selectPopulatedFields(query) {\n  const opts = query._mongooseOptions;\n\n  if (opts.populate != null) {\n    const paths = Object.keys(opts.populate);\n    let i;\n    const userProvidedFields = query._userProvidedFields || {};\n    if (query.selectedInclusively()) {\n      for (i = 0; i < paths.length; ++i) {\n        if (!isPathInFields(userProvidedFields, paths[i])) {\n          query.select(paths[i]);\n        }\n      }\n    } else if (query.selectedExclusively()) {\n      for (i = 0; i < paths.length; ++i) {\n        if (userProvidedFields[paths[i]] == null) {\n          delete query._fields[paths[i]];\n        }\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction isPathInFields(userProvidedFields, path) {\n  const pieces = path.split('.');\n  const len = pieces.length;\n  let cur = pieces[0];\n  for (let i = 1; i < len; ++i) {\n    if (userProvidedFields[cur] != null) {\n      return true;\n    }\n    cur += '.' + pieces[i];\n  }\n  return userProvidedFields[cur] != null;\n}\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Mixed = require('../schema/mixed');\nconst ValidationError = require('../error/validation');\nconst flatten = require('./common').flatten;\nconst modifiedPaths = require('./common').modifiedPaths;\nconst parallel = require('async/parallel');\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options) {\n  let _keys;\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  const modified = {};\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].charAt(0) === '$') {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      modifiedPaths(castedDoc[keys[i]], '', modified);\n      const flat = flatten(castedDoc[keys[i]]);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        let updatedPath = paths[j].replace('.$.', '.0.');\n        updatedPath = updatedPath.replace(/\\.\\$$/, '.0');\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.indexOf('$') !== -1) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    modifiedPaths(castedDoc, '', modified);\n    updatedValues = flatten(castedDoc);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = options && options.context === 'query' ? query : null;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath) {\n      // gh-4305: `_getSchema()` will report all sub-fields of a 'Mixed' path\n      // as 'Mixed', so avoid double validating them.\n      if (schemaPath instanceof Mixed && schemaPath.$fullPath !== updates[i]) {\n        return;\n      }\n\n      if (v && Array.isArray(v.$in)) {\n        v.$in.forEach((v, i) => {\n          validatorsToExecute.push(function(callback) {\n            schemaPath.doValidate(\n              v,\n              function(err) {\n                if (err) {\n                  err.path = updates[i] + '.$in.' + i;\n                  validationErrors.push(err);\n                }\n                callback(null);\n              },\n              context,\n              {updateValidator: true});\n          });\n        });\n      } else {\n        if (isPull[updates[i]] &&\n            !Array.isArray(v) &&\n            schemaPath.$isMongooseArray) {\n          v = [v];\n        }\n\n        if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n          alreadyValidated.push(updates[i]);\n          validatorsToExecute.push(function(callback) {\n            schemaPath.doValidate(v, function(err) {\n              if (err) {\n                err.path = updates[i];\n                validationErrors.push(err);\n                return callback(null);\n              }\n\n              v.validate(function(err) {\n                if (err) {\n                  if (err.errors) {\n                    for (const key of Object.keys(err.errors)) {\n                      const _err = err.errors[key];\n                      _err.path = updates[i] + '.' + key;\n                      validationErrors.push(_err);\n                    }\n                  }\n                }\n                callback(null);\n              });\n            }, context, { updateValidator: true });\n          });\n        } else {\n          validatorsToExecute.push(function(callback) {\n            for (const path of alreadyValidated) {\n              if (updates[i].startsWith(path + '.')) {\n                return callback(null);\n              }\n            }\n            schemaPath.doValidate(v, function(err) {\n              if (err) {\n                err.path = updates[i];\n                validationErrors.push(err);\n              }\n              callback(null);\n            }, context, { updateValidator: true });\n          });\n        }\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  const numArrayUpdates = arrayUpdates.length;\n  for (i = 0; i < numArrayUpdates; ++i) {\n    (function(i) {\n      let schemaPath = schema._getSchema(arrayUpdates[i]);\n      if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            arrayAtomicUpdates[arrayUpdates[i]],\n            function(err) {\n              if (err) {\n                err.path = arrayUpdates[i];\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            options && options.context === 'query' ? query : null);\n        });\n      } else {\n        schemaPath = schema._getSchema(arrayUpdates[i] + '.0');\n        for (let j = 0; j < arrayAtomicUpdates[arrayUpdates[i]].length; ++j) {\n          (function(j) {\n            validatorsToExecute.push(function(callback) {\n              schemaPath.doValidate(\n                arrayAtomicUpdates[arrayUpdates[i]][j],\n                function(err) {\n                  if (err) {\n                    err.path = arrayUpdates[i];\n                    validationErrors.push(err);\n                  }\n                  callback(null);\n                },\n                options && options.context === 'query' ? query : null,\n                { updateValidator: true });\n            });\n          })(j);\n        }\n      }\n    })(i);\n  }\n\n  return function(callback) {\n    parallel(validatorsToExecute, function() {\n      if (validationErrors.length) {\n        const err = new ValidationError(null);\n        for (let i = 0; i < validationErrors.length; ++i) {\n          err.addError(validationErrors[i].path, validationErrors[i]);\n        }\n        return callback(err);\n      }\n      callback(null);\n    });\n  };\n};\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Aggregate = require('./aggregate');\nconst ChangeStream = require('./cursor/ChangeStream');\nconst Document = require('./document');\nconst DocumentNotFoundError = require('./error').DocumentNotFoundError;\nconst DivergentArrayError = require('./error').DivergentArrayError;\nconst Error = require('./error');\nconst EventEmitter = require('events').EventEmitter;\nconst MongooseMap = require('./types/map');\nconst OverwriteModelError = require('./error').OverwriteModelError;\nconst PromiseProvider = require('./promise_provider');\nconst Query = require('./query');\nconst Schema = require('./schema');\nconst VersionError = require('./error').VersionError;\nconst ParallelSaveError = require('./error').ParallelSaveError;\nconst applyQueryMiddleware = require('./helpers/query/applyQueryMiddleware');\nconst applyHooks = require('./helpers/model/applyHooks');\nconst applyMethods = require('./helpers/model/applyMethods');\nconst applyStatics = require('./helpers/model/applyStatics');\nconst applyWriteConcern = require('./helpers/schema/applyWriteConcern');\nconst assignRawDocsToIdStructure = require('./helpers/populate/assignRawDocsToIdStructure');\nconst castBulkWrite = require('./helpers/model/castBulkWrite');\nconst discriminator = require('./helpers/model/discriminator');\nconst getDiscriminatorByValue = require('./queryhelpers').getDiscriminatorByValue;\nconst immediate = require('./helpers/immediate');\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst isPathExcluded = require('./helpers/projection/isPathExcluded');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\nconst get = require('lodash.get');\nconst getSchemaTypes = require('./helpers/populate/getSchemaTypes');\nconst getVirtual = require('./helpers/populate/getVirtual');\nconst leanPopulateMap = require('./helpers/populate/leanPopulateMap');\nconst modifiedPaths = require('./helpers/update/modifiedPaths');\nconst mpath = require('mpath');\nconst parallel = require('async/parallel');\nconst parallelLimit = require('async/parallelLimit');\nconst setParentPointers = require('./helpers/schema/setParentPointers');\nconst util = require('util');\nconst utils = require('./utils');\n\nconst VERSION_WHERE = 1;\nconst VERSION_INC = 2;\nconst VERSION_ALL = VERSION_WHERE | VERSION_INC;\n\nconst modelSymbol = Symbol.for('mongoose:Model');\nconst schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](./api.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](./api.html#mongoose_Mongoose-model) and\n * [`connection.model()`](./api.html#connection_Connection-model) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * ####Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projetion](./api.html#query_Query-select).\n * @inherits Document http://mongoosejs.com/docs/api.html#document-js\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved without passing a callback and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` must be a POJO or string, ' +\n      '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, skipId);\n}\n\n/*!\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n */\n\nModel.prototype.__proto__ = Document.prototype;\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * Collection the model uses.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/*!\n * ignore\n */\n\nModel.prototype.$__handleSave = function(options, callback) {\n  const _this = this;\n  let i;\n  let keys;\n  let len;\n  let saveOptions = {};\n\n  if ('safe' in options) {\n    _handleSafe(options);\n  }\n  applyWriteConcern(this.schema, options);\n  if ('w' in options) {\n    saveOptions.w = options.w;\n  }\n  if ('j' in options) {\n    saveOptions.j = options.j;\n  }\n  if ('wtimeout' in options) {\n    saveOptions.wtimeout = options.wtimeout;\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n\n  const session = 'session' in options ? options.session : this.$session();\n  if (session != null) {\n    saveOptions.session = session;\n    this.$session(session);\n  }\n\n  if (Object.keys(saveOptions).length === 0) {\n    saveOptions = null;\n  }\n\n  if (this.isNew) {\n    // send entire doc\n    const obj = this.toObject(internalToObjectOptions);\n\n    if ((obj || {})._id === void 0) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated my mongodb necessarily\n      // match the schema definition.\n      setTimeout(function() {\n        callback(new Error('document must have an _id before saving'));\n      }, 0);\n      return;\n    }\n\n    this.$__version(true, obj);\n    this.collection.insertOne(obj, saveOptions, function(err, ret) {\n      if (err) {\n        _this.isNew = true;\n        _this.emit('isNew', true);\n        _this.constructor.emit('isNew', true);\n\n        callback(err, null);\n        return;\n      }\n\n      callback(null, ret);\n    });\n    this.$__reset();\n    this.isNew = false;\n    this.emit('isNew', false);\n    this.constructor.emit('isNew', false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n  } else {\n    // Make sure we don't treat it as a new object on error,\n    // since it already exists\n    this.$__.inserting = false;\n\n    const delta = this.$__delta();\n\n    if (delta) {\n      if (delta instanceof Error) {\n        callback(delta);\n        return;\n      }\n\n      const where = this.$__where(delta[0]);\n      if (where instanceof Error) {\n        callback(where);\n        return;\n      }\n\n      if (this.$where) {\n        keys = Object.keys(this.$where);\n        len = keys.length;\n        for (i = 0; i < len; ++i) {\n          where[keys[i]] = this.$where[keys[i]];\n        }\n      }\n\n      this.collection.updateOne(where, delta[1], saveOptions, function(err, ret) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        ret.$where = where;\n        callback(null, ret);\n      });\n    } else {\n      this.$__reset();\n      callback();\n      return;\n    }\n\n    this.emit('isNew', false);\n    this.constructor.emit('isNew', false);\n  }\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function(options, callback) {\n  this.$__handleSave(options, (error, result) => {\n    if (error) {\n      return this.schema.s.hooks.execPost('save:error', this, [this], { error: error }, function(error) {\n        callback(error);\n      });\n    }\n\n    // store the modified paths before the document is reset\n    const modifiedPaths = this.modifiedPaths();\n\n    this.$__reset();\n\n    let numAffected = 0;\n    if (get(options, 'safe.w') !== 0 && get(options, 'w') !== 0) {\n      // Skip checking if write succeeded if writeConcern is set to\n      // unacknowledged writes, because otherwise `numAffected` will always be 0\n      if (result) {\n        if (Array.isArray(result)) {\n          numAffected = result.length;\n        } else if (result.result && result.result.n !== undefined) {\n          numAffected = result.result.n;\n        } else if (result.result && result.result.nModified !== undefined) {\n          numAffected = result.result.nModified;\n        } else {\n          numAffected = result;\n        }\n      }\n\n      // was this an update that required a version bump?\n      if (this.$__.version && !this.$__.inserting) {\n        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n        this.$__.version = undefined;\n\n        const key = this.schema.options.versionKey;\n        const version = this.getValue(key) || 0;\n\n        if (numAffected <= 0) {\n          // the update failed. pass an error back\n          const err = options.$versionError || new VersionError(this, version, modifiedPaths);\n          return callback(err);\n        }\n\n        // increment version if was successful\n        if (doIncrement) {\n          this.setValue(key, version + 1);\n        }\n      }\n\n      if (result != null && numAffected <= 0) {\n        error = new DocumentNotFoundError(result.$where);\n        return this.schema.s.hooks.execPost('save:error', this, [this], { error: error }, function(error) {\n          callback(error);\n        });\n      }\n    }\n    this.$__.saving = undefined;\n    this.emit('save', this, numAffected);\n    this.constructor.emit('save', this, numAffected);\n    callback(null, this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths) {\n  const key = doc.schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths);\n}\n\n/**\n * Saves this document.\n *\n * ####Example:\n *\n *     product.sold = Date.now();\n *     product.save(function (err, product) {\n *       if (err) ..\n *     })\n *\n * The callback will receive two parameters\n *\n * 1. `err` if an error occurred\n * 2. `product` which is the saved `product`\n *\n * As an extra measure of flow control, save will return a Promise.\n * ####Example:\n *     product.save().then(function(product) {\n *        ...\n *     });\n *\n * @param {Object} [options] options optional options\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)\n * @param {Function} [fn] optional callback\n * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.\n * @api public\n * @see middleware http://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = function(options, fn) {\n  let parallelSave;\n\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n\n  if (typeof options === 'function') {\n    fn = options;\n    options = undefined;\n  }\n\n  if (options != null) {\n    options = utils.clone(options);\n  } else {\n    options = {};\n  }\n\n  if (fn) {\n    fn = this.constructor.$wrapCallback(fn);\n  }\n\n  options.$versionError = generateVersionError(this, this.modifiedPaths());\n\n  return utils.promiseOrCallback(fn, cb => {\n    if (parallelSave) {\n      this.$__handleReject(parallelSave);\n      return cb(parallelSave);\n    }\n\n    this.$__save(options, error => {\n      this.$__.saving = undefined;\n\n      if (error) {\n        this.$__handleReject(error);\n        return cb(error);\n      }\n      cb(null, this);\n    });\n  });\n};\n\n/*!\n * Determines whether versioning should be skipped for the given path\n *\n * @param {Document} self\n * @param {String} path\n * @return {Boolean} true if versioning should be skipped for the given path\n */\nfunction shouldSkipVersioning(self, path) {\n  const skipVersioning = self.schema.options.skipVersioning;\n  if (!skipVersioning) return false;\n\n  // Remove any array indexes from the path\n  path = path.replace(/\\.\\d+\\./, '.');\n\n  return skipVersioning[path];\n}\n\n/*!\n * Apply the operation to the delta (update) clause as\n * well as track versioning for our where clause.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Mixed} val\n * @param {String} [operation]\n */\n\nfunction operand(self, where, delta, data, val, op) {\n  // delta\n  op || (op = '$set');\n  if (!delta[op]) delta[op] = {};\n  delta[op][data.path] = val;\n\n  // disabled versioning?\n  if (self.schema.options.versionKey === false) return;\n\n  // path excluded from versioning?\n  if (shouldSkipVersioning(self, data.path)) return;\n\n  // already marked for versioning?\n  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;\n\n  switch (op) {\n    case '$set':\n    case '$unset':\n    case '$pop':\n    case '$pull':\n    case '$pullAll':\n    case '$push':\n    case '$addToSet':\n      break;\n    default:\n      // nothing to do\n      return;\n  }\n\n  // ensure updates sent with positional notation are\n  // editing the correct array element.\n  // only increment the version if an array position changes.\n  // modifying elements of an array is ok if position does not change.\n  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {\n    self.$__.version = VERSION_INC;\n  } else if (/^\\$p/.test(op)) {\n    // potentially changing array positions\n    self.increment();\n  } else if (Array.isArray(val)) {\n    // $set an array\n    self.increment();\n  } else if (/\\.\\d+\\.|\\.\\d+$/.test(data.path)) {\n    // now handling $set, $unset\n    // subpath of array\n    self.$__.version = VERSION_WHERE;\n  }\n}\n\n/*!\n * Compiles an update and where clause for a `val` with _atomics.\n *\n * @param {Document} self\n * @param {Object} where\n * @param {Object} delta\n * @param {Object} data\n * @param {Array} value\n */\n\nfunction handleAtomics(self, where, delta, data, value) {\n  if (delta.$set && delta.$set[data.path]) {\n    // $set has precedence over other atomics\n    return;\n  }\n\n  if (typeof value.$__getAtomics === 'function') {\n    value.$__getAtomics().forEach(function(atomic) {\n      const op = atomic[0];\n      const val = atomic[1];\n      operand(self, where, delta, data, val, op);\n    });\n    return;\n  }\n\n  // legacy support for plugins\n\n  const atomics = value._atomics;\n  const ops = Object.keys(atomics);\n  let i = ops.length;\n  let val;\n  let op;\n\n  if (i === 0) {\n    // $set\n\n    if (utils.isMongooseObject(value)) {\n      value = value.toObject({depopulate: 1, _isNested: true});\n    } else if (value.valueOf) {\n      value = value.valueOf();\n    }\n\n    return operand(self, where, delta, data, value);\n  }\n\n  function iter(mem) {\n    return utils.isMongooseObject(mem)\n      ? mem.toObject({depopulate: 1, _isNested: true})\n      : mem;\n  }\n\n  while (i--) {\n    op = ops[i];\n    val = atomics[op];\n\n    if (utils.isMongooseObject(val)) {\n      val = val.toObject({depopulate: true, transform: false, _isNested: true});\n    } else if (Array.isArray(val)) {\n      val = val.map(iter);\n    } else if (val.valueOf) {\n      val = val.valueOf();\n    }\n\n    if (op === '$addToSet') {\n      val = {$each: val};\n    }\n\n    operand(self, where, delta, data, val, op);\n  }\n}\n\n/**\n * Produces a special query document of the modified properties used in updates.\n *\n * @api private\n * @method $__delta\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__delta = function() {\n  const dirty = this.$__dirty();\n  if (!dirty.length && VERSION_ALL !== this.$__.version) {\n    return;\n  }\n\n  const where = {};\n  const delta = {};\n  const len = dirty.length;\n  const divergent = [];\n  let d = 0;\n\n  where._id = this._doc._id;\n  // If `_id` is an object, need to depopulate, but also need to be careful\n  // because `_id` can technically be null (see gh-6406)\n  if (get(where, '_id.$__', null) != null) {\n    where._id = where._id.toObject({ transform: false, depopulate: true });\n  }\n\n  for (; d < len; ++d) {\n    const data = dirty[d];\n    let value = data.value;\n\n    const match = checkDivergentArray(this, data.path, value);\n    if (match) {\n      divergent.push(match);\n      continue;\n    }\n\n    const pop = this.populated(data.path, true);\n    if (!pop && this.$__.selected) {\n      // If any array was selected using an $elemMatch projection, we alter the path and where clause\n      // NOTE: MongoDB only supports projected $elemMatch on top level array.\n      const pathSplit = data.path.split('.');\n      const top = pathSplit[0];\n      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {\n        // If the selected array entry was modified\n        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {\n          where[top] = this.$__.selected[top];\n          pathSplit[1] = '$';\n          data.path = pathSplit.join('.');\n        }\n        // if the selected array was modified in any other way throw an error\n        else {\n          divergent.push(data.path);\n          continue;\n        }\n      }\n    }\n\n    if (divergent.length) continue;\n\n    if (value === undefined) {\n      operand(this, where, delta, data, 1, '$unset');\n    } else if (value === null) {\n      operand(this, where, delta, data, null);\n    } else if (value._path && value._atomics) {\n      // arrays and other custom types (support plugins etc)\n      handleAtomics(this, where, delta, data, value);\n    } else if (value._path && Buffer.isBuffer(value)) {\n      // MongooseBuffer\n      value = value.toObject();\n      operand(this, where, delta, data, value);\n    } else {\n      value = utils.clone(value, {\n        depopulate: true,\n        transform: false,\n        virtuals: false,\n        _isNested: true\n      });\n      operand(this, where, delta, data, value);\n    }\n  }\n\n  if (divergent.length) {\n    return new DivergentArrayError(divergent);\n  }\n\n  if (this.$__.version) {\n    this.$__version(where, delta);\n  }\n\n  return [where, delta];\n};\n\n/*!\n * Determine if array was populated with some form of filter and is now\n * being updated in a manner which could overwrite data unintentionally.\n *\n * @see https://github.com/Automattic/mongoose/issues/1334\n * @param {Document} doc\n * @param {String} path\n * @return {String|undefined}\n */\n\nfunction checkDivergentArray(doc, path, array) {\n  // see if we populated this path\n  const pop = doc.populated(path, true);\n\n  if (!pop && doc.$__.selected) {\n    // If any array was selected using an $elemMatch projection, we deny the update.\n    // NOTE: MongoDB only supports projected $elemMatch on top level array.\n    const top = path.split('.')[0];\n    if (doc.$__.selected[top + '.$']) {\n      return top;\n    }\n  }\n\n  if (!(pop && array && array.isMongooseArray)) return;\n\n  // If the array was populated using options that prevented all\n  // documents from being returned (match, skip, limit) or they\n  // deselected the _id field, $pop and $set of the array are\n  // not safe operations. If _id was deselected, we do not know\n  // how to remove elements. $pop will pop off the _id from the end\n  // of the array in the db which is not guaranteed to be the\n  // same as the last element we have here. $set of the entire array\n  // would be similarily destructive as we never received all\n  // elements of the array and potentially would overwrite data.\n  const check = pop.options.match ||\n      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted\n      pop.options.options && pop.options.options.skip || // 0 is permitted\n      pop.options.select && // deselected _id?\n      (pop.options.select._id === 0 ||\n      /\\s?-_id\\s?/.test(pop.options.select));\n\n  if (check) {\n    const atomics = array._atomics;\n    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {\n      return path;\n    }\n  }\n}\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function(where, delta) {\n  const key = this.schema.options.versionKey;\n\n  if (where === true) {\n    // this is an insert\n    if (key) this.setValue(key, delta[key] = 0);\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n  if (!this.isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.getValue(key);\n    if (value != null) where[key] = value;\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * ####Example:\n *\n *     Model.findById(id, function (err, doc) {\n *       doc.increment();\n *       doc.save(function (err) { .. })\n *     })\n *\n * @see versionKeys http://mongoosejs.com/docs/guide.html#versionKey\n * @api public\n */\n\nModel.prototype.increment = function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n};\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this._doc._id === void 0) {\n    return new Error('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Removes this document from the db.\n *\n * ####Example:\n *     product.remove(function (err, product) {\n *       if (err) return handleError(err);\n *       Product.findById(product._id, function (err, product) {\n *         console.log(product) // null\n *       })\n *     })\n *\n *\n * As an extra measure of flow control, remove will return a Promise (bound to `fn` if passed) so it could be chained, or hooked to recieve errors\n *\n * ####Example:\n *     product.remove().then(function (product) {\n *        ...\n *     }).catch(function (err) {\n *        assert.ok(err)\n *     })\n *\n * @param {function(err,product)} [fn] optional callback\n * @return {Promise} Promise\n * @api public\n */\n\nModel.prototype.remove = function remove(options, fn) {\n  if (typeof options === 'function') {\n    fn = options;\n    options = undefined;\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (fn) {\n    fn = this.constructor.$wrapCallback(fn);\n  }\n\n  return utils.promiseOrCallback(fn, cb => {\n    this.$__remove(options, cb);\n  });\n};\n\n/**\n * Alias for remove\n */\n\nModel.prototype.delete = Model.prototype.remove;\n\n/*!\n * ignore\n */\n\nModel.prototype.$__remove = function $__remove(options, cb) {\n  if (this.$__.isDeleted) {\n    return immediate(() => cb(null, this));\n  }\n\n  const where = this.$__where();\n  if (where instanceof Error) {\n    return cb(where);\n  }\n\n  this.collection.deleteOne(where, options, err => {\n    if (!err) {\n      this.$__.isDeleted = true;\n      this.emit('remove', this);\n      this.constructor.emit('remove', this);\n      return cb(null, this);\n    }\n    this.$__.isDeleted = false;\n    cb(err);\n  });\n};\n\n/**\n * Returns another Model instance.\n *\n * ####Example:\n *\n *     var doc = new Tank;\n *     doc.model('User').findById(id, callback);\n *\n * @param {String} name model name\n * @api public\n */\n\nModel.prototype.model = function model(name) {\n  return this.db.model(name);\n};\n\n/**\n * Adds a discriminator type.\n *\n * ####Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     var PersonSchema = new BaseSchema();\n *     var BossSchema = new BaseSchema({ department: String });\n *\n *     var Person = mongoose.model('Person', PersonSchema);\n *     var Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     var employeeSchema = new Schema({ boss: ObjectId });\n *     var Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {String} value the string stored in the `discriminatorKey` property\n * @api public\n */\n\nModel.discriminator = function(name, schema, value) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new Error('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  schema = discriminator(this, name, schema, value);\n  if (this.db.models[name]) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n\n  model = this.db.model(model || name, schema, this.collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  d.prototype.__proto__ = this.prototype;\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  return d;\n};\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for building [indexes](https://docs.mongodb.com/manual/indexes/),\n * unless [`autoIndex`](http://mongoosejs.com/docs/guide.html#autoIndex) is turned off.\n *\n * Mongoose calls this function automatically when a model is created using\n * [`mongoose.model()`](/docs/api.html#mongoose_Mongoose-model) or\n * * [`connection.model()`](/docs/api.html#connection_Connection-model), so you\n * don't need to call it. This function is also idempotent, so you may call it\n * to get back a promise that will resolve when your indexes are finished\n * building as an alternative to [`MyModel.on('index')`](/docs/guide.html#indexes)\n *\n * ####Example:\n *\n *     var eventSchema = new Schema({ thing: { type: 'string', unique: true }})\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     var Event = mongoose.model('Event', eventSchema);\n *\n *     Event.init().then(function(Event) {\n *       // You can also use `Event.on('index')` if you prefer event emitters\n *       // over promises.\n *       console.log('Indexes are done building!');\n *     });\n *\n * @api public\n * @param {Function} [callback]\n * @returns {Promise}\n */\n\nModel.init = function init(callback) {\n  this.schema.emit('init', this);\n\n  if (this.$init != null) {\n    if (callback) {\n      this.$init.then(() => callback(), err => callback(err));\n      return null;\n    }\n    return this.$init;\n  }\n\n  // If `dropDatabase()` is called, this model's collection will not be\n  // init-ed. It is sufficiently common to call `dropDatabase()` after\n  // `mongoose.connect()` but before creating models that we want to\n  // support this. See gh-6967\n  this.db.$internalEmitter.once('dropDatabase', () => {\n    delete this.$init;\n  });\n\n  const Promise = PromiseProvider.get();\n  const autoIndex = this.schema.options.autoIndex == null ?\n    this.db.config.autoIndex :\n    this.schema.options.autoIndex;\n  const autoCreate = this.schema.options.autoCreate == null ?\n    this.db.config.autoCreate :\n    this.schema.options.autoCreate;\n\n  const _ensureIndexes = autoIndex ?\n    cb => this.ensureIndexes({ _automatic: true }, cb) :\n    cb => cb();\n  const _createCollection = autoCreate ?\n    cb => this.createCollection({}, cb) :\n    cb => cb();\n\n  this.$init = new Promise((resolve, reject) => {\n    _createCollection(error => {\n      if (error) {\n        return reject(error);\n      }\n      _ensureIndexes(error => {\n        if (error) {\n          return reject(error);\n        }\n        resolve(this);\n      });\n    });\n  });\n\n  if (callback) {\n    this.$init.then(() => callback(), err => callback(err));\n    this.$caught = true;\n    return null;\n  } else {\n    const _catch = this.$init.catch;\n    const _this = this;\n    this.$init.catch = function() {\n      this.$caught = true;\n      return _catch.apply(_this.$init, arguments);\n    };\n  }\n\n  return this.$init;\n};\n\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://docs.mongodb.com/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * ####Example:\n *\n *     var userSchema = new Schema({ name: String })\n *     var User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](http://mongodb.github.io/node-mongodb-native/3.1/api/Db.html#createCollection)\n * @param {Function} [callback]\n * @returns {Promise}\n */\n\nModel.createCollection = function createCollection(options, callback) {\n  if (typeof options === 'string') {\n    throw new Error('You can\\'t specify a new collection name in Model.createCollection.' +\n      'This is not like Connection.createCollection. Only options are accepted here.');\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  const schemaCollation = get(this, 'schema.options.collation', null);\n  if (schemaCollation != null) {\n    options = Object.assign({ collation: schemaCollation }, options);\n  }\n\n  return utils.promiseOrCallback(callback, cb => {\n    this.db.createCollection(this.collection.collectionName, options, utils.tick((error) => {\n      if (error) {\n        return cb(error);\n      }\n      this.collection = this.db.collection(this.collection.collectionName, options);\n      cb(null, this.collection);\n    }));\n  });\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](http://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * ####Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Function} [callback] optional callback\n * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.\n * @api public\n */\n\nModel.syncIndexes = function syncIndexes(options, callback) {\n  callback = this.$wrapCallback(callback);\n\n  const dropNonSchemaIndexes = (cb) => {\n    this.listIndexes((err, indexes) => {\n      if (err != null) {\n        return cb(err);\n      }\n\n      const schemaIndexes = this.schema.indexes();\n      const toDrop = [];\n\n      for (const index of indexes) {\n        let found = false;\n        // Never try to drop `_id` index, MongoDB server doesn't allow it\n        if (index.key._id) {\n          continue;\n        }\n\n        for (const schemaIndex of schemaIndexes) {\n          const key = schemaIndex[0];\n          const options = _decorateDiscriminatorIndexOptions(this,\n            utils.clone(schemaIndex[1]));\n\n          // If these options are different, need to rebuild the index\n          const optionKeys = ['unique', 'partialFilterExpression', 'sparse', 'expireAfterSeconds'];\n          const indexCopy = Object.assign({}, index);\n          for (const key of optionKeys) {\n            if (!(key in options) && !(key in indexCopy)) {\n              continue;\n            }\n            indexCopy[key] = options[key];\n          }\n          if (utils.deepEqual(key, index.key) &&\n              utils.deepEqual(index, indexCopy)) {\n            found = true;\n            break;\n          }\n        }\n\n        if (!found) {\n          toDrop.push(index.name);\n        }\n      }\n\n      if (toDrop.length === 0) {\n        return cb(null, []);\n      }\n\n      dropIndexes(toDrop, cb);\n    });\n  };\n\n  const dropIndexes = (toDrop, cb) => {\n    let remaining = toDrop.length;\n    let error = false;\n    toDrop.forEach(indexName => {\n      this.collection.dropIndex(indexName, err => {\n        if (err != null) {\n          error = true;\n          return cb(err);\n        }\n        if (!error) {\n          --remaining || cb(null, toDrop);\n        }\n      });\n    });\n  };\n\n  return utils.promiseOrCallback(callback, cb => {\n    dropNonSchemaIndexes((err, dropped) => {\n      if (err != null) {\n        return cb(err);\n      }\n      this.createIndexes(options, err => {\n        if (err != null) {\n          return cb(err);\n        }\n        cb(null, dropped);\n      });\n    });\n  });\n};\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @param {Function} [cb] optional callback\n * @return {Promise|undefined} Returns `undefined` if callback is specified, returns a promise if no callback.\n * @api public\n */\n\nModel.listIndexes = function init(callback) {\n  callback = this.$wrapCallback(callback);\n\n  const _listIndexes = cb => {\n    this.collection.listIndexes().toArray(cb);\n  };\n\n  return utils.promiseOrCallback(callback, cb => {\n    // Buffering\n    if (this.collection.buffer) {\n      this.collection.addQueue(_listIndexes, [cb]);\n    } else {\n      _listIndexes(cb);\n    }\n  });\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * ####Example:\n *\n *     Event.ensureIndexes(function (err) {\n *       if (err) return handleError(err);\n *     });\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * ####Example:\n *\n *     var eventSchema = new Schema({ thing: { type: 'string', unique: true }})\n *     var Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     })\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @param {Function} [cb] optional callback\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = function ensureIndexes(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return utils.promiseOrCallback(callback, cb => {\n    _ensureIndexes(this, options || {}, error => {\n      if (error) {\n        return cb(error);\n      }\n      cb(null);\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @param {Function} [cb] optional callback\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = function createIndexes(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  options.createIndex = true;\n  return this.ensureIndexes(options, callback);\n};\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = model.schema.indexes();\n\n  options = options || {};\n\n  const done = function(err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err);\n    callback && callback(err);\n  };\n\n  for (const index of indexes) {\n    const keys = Object.keys(index[0]);\n    if (keys.length === 1 && keys[0] === '_id' && index[0]._id !== 'hashed') {\n      console.warn('mongoose: Cannot specify a custom index on `_id` for ' +\n        'model name \"' + model.modelName + '\", ' +\n        'MongoDB does not allow overwriting the default `_id` index. See ' +\n        'http://bit.ly/mongodb-id-index');\n    }\n  }\n\n  if (!indexes.length) {\n    immediate(function() {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  const indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  const create = function() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false ||\n          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\n        return done();\n      }\n    }\n\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n\n    const indexFields = utils.clone(index[0]);\n    const indexOptions = utils.clone(index[1]);\n\n    _decorateDiscriminatorIndexOptions(model, indexOptions);\n    if ('safe' in options) {\n      _handleSafe(options);\n    }\n    applyWriteConcern(model.schema, indexOptions);\n\n    indexSingleStart(indexFields, options);\n    let useCreateIndex = !!model.base.options.useCreateIndex;\n    if ('useCreateIndex' in model.db.config) {\n      useCreateIndex = !!model.db.config.useCreateIndex;\n    }\n    if ('createIndex' in options) {\n      useCreateIndex = !!options.createIndex;\n    }\n\n    const methodName = useCreateIndex ? 'createIndex' : 'ensureIndex';\n    model.collection[methodName](indexFields, indexOptions, utils.tick(function(err, name) {\n      indexSingleDone(err, indexFields, indexOptions, name);\n      if (err) {\n        return done(err);\n      }\n      create();\n    }));\n  };\n\n  immediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n}\n\nfunction _decorateDiscriminatorIndexOptions(model, indexOptions) {\n  // If the model is a discriminator and it has a unique index, add a\n  // partialFilterExpression by default so the unique index will only apply\n  // to that discriminator.\n  if (model.baseModelName != null && indexOptions.unique &&\n      !('partialFilterExpression' in indexOptions) &&\n      !('sparse' in indexOptions)) {\n    indexOptions.partialFilterExpression = {\n      [model.schema.options.discriminatorKey]: model.modelName\n    };\n  }\n  return indexOptions;\n}\n\nconst safeDeprecationWarning = 'Mongoose: the `safe` option for `save()` is ' +\n  'deprecated. Use the `w` option instead: http://bit.ly/mongoose-save';\n\nconst _handleSafe = util.deprecate(function _handleSafe(options) {\n  if (options.safe) {\n    if (typeof options.safe === 'boolean') {\n      options.w = options.safe;\n      delete options.safe;\n    }\n    if (typeof options.safe === 'object') {\n      options.w = options.safe.w;\n      options.j = options.safe.j;\n      options.wtimeout = options.safe.wtimeout;\n      delete options.safe;\n    }\n  }\n}, safeDeprecationWarning);\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @receiver Model\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/*!\n * Connection instance the model uses.\n *\n * @property db\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/*!\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * ####Example:\n *\n *     Character\n *       .find(Character.translateAliases({\n *         '': 'Eddard Stark' // Alias for 'name'\n *       })\n *       .exec(function(err, characters) {})\n *\n * ####Note:\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} raw fields/conditions that may contain aliased keys\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields) {\n  const aliases = this.schema.aliases;\n\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    for (const key in fields) {\n      if (aliases[key]) {\n        fields[aliases[key]] = fields[key];\n        delete fields[key];\n      }\n    }\n\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Removes all documents that match `conditions` from the collection.\n * To remove just the first document that matches `conditions`, set the `single`\n * option to true.\n *\n * ####Example:\n *\n *     Character.remove({ name: 'Eddard Stark' }, function (err) {});\n *\n * ####Note:\n *\n * This method sends a remove command directly to MongoDB, no Mongoose documents\n * are involved. Because no Mongoose documents are involved, _no middleware\n * (hooks) are executed_.\n *\n * @param {Object} conditions\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.remove = function remove(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  const mq = new this.Query({}, {}, this, this.collection);\n\n  callback = this.$wrapCallback(callback);\n\n  return mq.remove(conditions, callback);\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * Behaves like `remove()`, but deletes at most one document regardless of the\n * `single` option.\n *\n * ####Example:\n *\n *     Character.deleteOne({ name: 'Eddard Stark' }, function (err) {});\n *\n * ####Note:\n *\n * Like `Model.remove()`, this function does **not** trigger `pre('remove')` or `post('remove')` hooks.\n *\n * @param {Object} conditions\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  const mq = new this.Query(conditions, {}, this, this.collection);\n\n  callback = this.$wrapCallback(callback);\n\n  return mq.deleteOne(callback);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * Behaves like `remove()`, but deletes all documents that match `conditions`\n * regardless of the `single` option.\n *\n * ####Example:\n *\n *     Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }, function (err) {});\n *\n * ####Note:\n *\n * Like `Model.remove()`, this function does **not** trigger `pre('remove')` or `post('remove')` hooks.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    options = null;\n  }\n  else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  // get the mongodb collection object\n  const mq = new this.Query(conditions, {}, this, this.collection);\n  mq.setOptions(options);\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.deleteMany(callback);\n};\n\n/**\n * Finds documents\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * ####Examples:\n *\n *     // named john and at least 18\n *     MyModel.find({ name: 'john', age: { $gte: 18 }});\n *\n *     // executes immediately, passing results to callback\n *     MyModel.find({ name: 'john', age: { $gte: 18 }}, function (err, docs) {});\n *\n *     // name LIKE john and only selecting the \"name\" and \"friends\" fields, executing immediately\n *     MyModel.find({ name: /john/i }, 'name friends', function (err, docs) { })\n *\n *     // passing options\n *     MyModel.find({ name: /john/i }, null, { skip: 10 })\n *\n *     // passing options and executing immediately\n *     MyModel.find({ name: /john/i }, null, { skip: 10 }, function (err, docs) {});\n *\n *     // executing a query explicitly\n *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 })\n *     query.exec(function (err, docs) {});\n *\n *     // using the promise returned from executing a query\n *     var query = MyModel.find({ name: /john/i }, null, { skip: 10 });\n *     var promise = query.exec();\n *     promise.addBack(function (err, docs) {});\n *\n * @param {Object} conditions\n * @param {Object|String} [projection] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see promise #promise-js\n * @api public\n */\n\nModel.find = function find(conditions, projection, options, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    projection = null;\n    options = null;\n  } else if (typeof projection === 'function') {\n    callback = projection;\n    projection = null;\n    options = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  const mq = new this.Query({}, {}, this, this.collection);\n  mq.select(projection);\n\n  mq.setOptions(options);\n  if (this.schema.discriminatorMapping &&\n      this.schema.discriminatorMapping.isRoot &&\n      mq.selectedInclusively()) {\n    // Need to select discriminator key because original schema doesn't have it\n    mq.select(this.schema.options.discriminatorKey);\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.find(conditions, callback);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is almost*\n * equivalent to `findOne({ _id: id })`. If you want to query by a document's\n * `_id`, use `findById()` instead of `findOne()`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * \\* Except for how it treats `undefined`. If you use `findOne()`, you'll see\n * that `findOne(undefined)` and `findOne({ _id: undefined })` are equivalent\n * to `findOne({})` and return arbitrary documents. However, mongoose\n * translates `findById(undefined)` into `findOne({ _id: null })`.\n *\n * ####Example:\n *\n *     // find adventure by id and execute immediately\n *     Adventure.findById(id, function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findById(id).exec(callback);\n *\n *     // select only the adventures name and length\n *     Adventure.findById(id, 'name length', function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findById(id, 'name length').exec(callback);\n *\n *     // include all properties except for `length`\n *     Adventure.findById(id, '-length').exec(function (err, adventure) {});\n *\n *     // passing options (in this case return the raw js objects, not mongoose documents by passing `lean`\n *     Adventure.findById(id, 'name', { lean: true }, function (err, doc) {});\n *\n *     // same as above\n *     Adventure.findById(id, 'name').lean().exec(function (err, doc) {});\n *\n * @param {Object|String|Number} id value of `_id` to query by\n * @param {Object|String} [projection] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see lean queries #query_Query-lean\n * @api public\n */\n\nModel.findById = function findById(id, projection, options, callback) {\n  if (typeof id === 'undefined') {\n    id = null;\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return this.findOne({_id: id}, projection, options, callback);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * ####Example:\n *\n *     // find one iphone adventures - iphone adventures??\n *     Adventure.findOne({ type: 'iphone' }, function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }).exec(function (err, adventure) {});\n *\n *     // select only the adventures name\n *     Adventure.findOne({ type: 'iphone' }, 'name', function (err, adventure) {});\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }, 'name').exec(function (err, adventure) {});\n *\n *     // specify options, in this case lean\n *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }, callback);\n *\n *     // same as above\n *     Adventure.findOne({ type: 'iphone' }, 'name', { lean: true }).exec(callback);\n *\n *     // chaining findOne queries (same as above)\n *     Adventure.findOne({ type: 'iphone' }).select('name').lean().exec(callback);\n *\n * @param {Object} [conditions]\n * @param {Object|String} [projection] optional fields to return, see [`Query.prototype.select()`](#query_Query-select)\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @see field selection #query_Query-select\n * @see lean queries #query_Query-lean\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  } else if (typeof projection === 'function') {\n    callback = projection;\n    projection = null;\n    options = null;\n  } else if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n    projection = null;\n    options = null;\n  }\n\n  // get the mongodb collection object\n  const mq = new this.Query({}, {}, this, this.collection);\n  mq.select(projection);\n\n  mq.setOptions(options);\n  if (this.schema.discriminatorMapping &&\n      this.schema.discriminatorMapping.isRoot &&\n      mq.selectedInclusively()) {\n    mq.select(this.schema.options.discriminatorKey);\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.findOne(conditions, callback);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * ####Example:\n *\n *     const numAdventures = Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options, callback) {\n  // get the mongodb collection object\n  const mq = new this.Query({}, {}, this, this.collection);\n\n  callback = this.$wrapCallback(callback);\n\n  return mq.estimatedDocumentCount(options, callback);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * ####Example:\n *\n *     Adventure.countDocuments({ type: 'jungle' }, function (err, count) {\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](/docs/api.html#model_Model.estimatedDocumentCount)\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://docs.mongodb.com/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://docs.mongodb.com/manual/reference/operator/query/geoWithin/) with [`$center`](https://docs.mongodb.com/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://docs.mongodb.com/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://docs.mongodb.com/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  const mq = new this.Query({}, {}, this, this.collection);\n\n  callback = this.$wrapCallback(callback);\n\n  return mq.countDocuments(conditions, callback);\n};\n\n/**\n * Counts number of documents that match `filter` in a database collection.\n *\n * This method is deprecated. If you want to count the number of documents in\n * a collection, e.g. `count({})`, use the [`estimatedDocumentCount()` function](/docs/api.html#model_Model.estimatedDocumentCount)\n * instead. Otherwise, use the [`countDocuments()`](/docs/api.html#model_Model.countDocuments) function instead.\n *\n * ####Example:\n *\n *     Adventure.count({ type: 'jungle' }, function (err, count) {\n *       if (err) ..\n *       console.log('there are %d jungle adventures', count);\n *     });\n *\n * @deprecated\n * @param {Object} filter\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.count = function count(conditions, callback) {\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n\n  // get the mongodb collection object\n  const mq = new this.Query({}, {}, this, this.collection);\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.count(conditions, callback);\n};\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * Passing a `callback` immediately executes the query.\n *\n * ####Example\n *\n *     Link.distinct('url', { clicks: {$gt: 100}}, function (err, result) {\n *       if (err) return handleError(err);\n *\n *       assert(Array.isArray(result));\n *       console.log('unique urls with more than 100 clicks', result);\n *     })\n *\n *     var query = Link.distinct('url');\n *     query.exec(callback);\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions, callback) {\n  // get the mongodb collection object\n  const mq = new this.Query({}, {}, this, this.collection);\n\n  if (typeof conditions === 'function') {\n    callback = conditions;\n    conditions = {};\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return mq.distinct(field, conditions, callback);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({age: {$gte: 21, $lte: 65}}, callback);\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec(callback);\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  void val; // eslint\n  // get the mongodb collection object\n  const mq = new this.Query({}, {}, this, this.collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where #query_Query-%24where\n * @api public\n */\n\nModel.$where = function $where() {\n  const mq = new this.Query({}, {}, this, this.collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findAndModify update command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.\n *\n * ####Options:\n *\n * - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n * - `rawResult`: if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n * ####Examples:\n *\n *     A.findOneAndUpdate(conditions, update, options, callback) // executes\n *     A.findOneAndUpdate(conditions, update, options)  // returns Query\n *     A.findOneAndUpdate(conditions, update, callback) // executes\n *     A.findOneAndUpdate(conditions, update)           // returns Query\n *     A.findOneAndUpdate()                             // returns Query\n *\n * ####Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     var query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options, callback)\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options, callback)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.\n *\n * ####Note:\n *\n * Values are cast to their appropriate types when using the findAndModify helpers.\n * However, the below are not executed by default.\n *\n * - defaults. Use the `setDefaultsOnInsert` option to override.\n *\n * `findAndModify` helpers support limited validation. You can\n * enable these by setting the `runValidators` options,\n * respectively.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     Model.findById(id, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason bourne';\n *       doc.save(callback);\n *     });\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](http://mongoosejs.com/docs/api.html#query_Query-lean).\n * @param {Function} [callback]\n * @return {Query}\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  } else if (arguments.length === 1) {\n    if (typeof conditions === 'function') {\n      const msg = 'Model.findOneAndUpdate(): First argument must not be a function.\\n\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options, callback)\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update, options)\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate(conditions, update)\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate(update)\\n'\n          + '  ' + this.modelName + '.findOneAndUpdate()\\n';\n      throw new TypeError(msg);\n    }\n    update = conditions;\n    conditions = undefined;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n\n  const retainKeyOrder = get(options, 'retainKeyOrder') ||\n    get(this, 'schema.options.retainKeyOrder') ||\n    false;\n  update = utils.clone(update, {\n    depopulate: true,\n    _isNested: true,\n    retainKeyOrder: retainKeyOrder\n  });\n\n  _decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n\n  const mq = new this.Query({}, {}, this, this.collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options, callback);\n};\n\n/*!\n * Decorate the update with a version key, if necessary\n */\n\nfunction _decorateUpdateWithVersionKey(update, options, versionKey) {\n  if (!versionKey || !get(options, 'upsert', false)) {\n    return;\n  }\n\n  const updatedPaths = modifiedPaths(update);\n  if (!updatedPaths[versionKey]) {\n    if (options.overwrite) {\n      update[versionKey] = 0;\n    } else {\n      if (!update.$setOnInsert) {\n        update.$setOnInsert = {};\n      }\n      update.$setOnInsert[versionKey] = 0;\n    }\n  }\n}\n\n/**\n * Issues a mongodb findAndModify update command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any) to the\n * callback. The query executes immediately if `callback` is passed else a\n * Query object is returned.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * ####Options:\n *\n * - `new`: bool - true to return the modified document rather than the original. defaults to false\n * - `upsert`: bool - creates the object if it doesn't exist. defaults to false.\n * - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n * - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `select`: sets the document fields to return\n * - `rawResult`: if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n * ####Examples:\n *\n *     A.findByIdAndUpdate(id, update, options, callback) // executes\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update, callback) // executes\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * ####Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options, callback)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options, callback)\n *\n * This helps prevent accidentally overwriting your document with `{ name: 'jason bourne' }`.\n *\n * ####Note:\n *\n * Values are cast to their appropriate types when using the findAndModify helpers.\n * However, the below are not executed by default.\n *\n * - defaults. Use the `setDefaultsOnInsert` option to override.\n *\n * `findAndModify` helpers support limited validation. You can\n * enable these by setting the `runValidators` options,\n * respectively.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     Model.findById(id, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason bourne';\n *       doc.save(callback);\n *     });\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](http://mongoosejs.com/docs/api.html#query_Query-lean).\n * @param {Function} [callback]\n * @return {Query}\n * @see Model.findOneAndUpdate #model_Model.findOneAndUpdate\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options, callback) {\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n  if (arguments.length === 1) {\n    if (typeof id === 'function') {\n      const msg = 'Model.findByIdAndUpdate(): First argument must not be a function.\\n\\n'\n          + '  ' + this.modelName + '.findByIdAndUpdate(id, callback)\\n'\n          + '  ' + this.modelName + '.findByIdAndUpdate(id)\\n'\n          + '  ' + this.modelName + '.findByIdAndUpdate()\\n';\n      throw new TypeError(msg);\n    }\n    return this.findOneAndUpdate({_id: id}, undefined);\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._id;\n  }\n\n  return this.findOneAndUpdate.call(this, {_id: id}, update, options, callback);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and passes the found document\n * (if any) to the callback.\n *\n * Executes immediately if `callback` is passed else a Query object is returned.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * This function differs slightly from `Model.findOneAndRemove()` in that\n * `findOneAndRemove()` becomes a [MongoDB `findAndModify()` command](https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/),\n * as opposed to a `findOneAndDelete()` command. For most mongoose use cases,\n * this distinction is purely pedantic. You should use `findOneAndDelete()`\n * unless you have a good reason not to.\n *\n * ####Options:\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `select`: sets the document fields to return\n * - `projection`: like select, it determines which fields to return, ex. `{ projection: { _id: 0 } }`\n * - `rawResult`: if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n * ####Examples:\n *\n *     A.findOneAndDelete(conditions, options, callback) // executes\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions, callback) // executes\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * Values are cast to their appropriate types when using the findAndModify helpers.\n * However, the below are not executed by default.\n *\n * - defaults. Use the `setDefaultsOnInsert` option to override.\n *\n * `findAndModify` helpers support limited validation. You can\n * enable these by setting the `runValidators` options,\n * respectively.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     Model.findById(id, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason bourne';\n *       doc.save(callback);\n *     });\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function(conditions, options, callback) {\n  if (arguments.length === 1 && typeof conditions === 'function') {\n    const msg = 'Model.findOneAndDelete(): First argument must not be a function.\\n\\n'\n        + '  ' + this.modelName + '.findOneAndDelete(conditions, callback)\\n'\n        + '  ' + this.modelName + '.findOneAndDelete(conditions)\\n'\n        + '  ' + this.modelName + '.findOneAndDelete()\\n';\n    throw new TypeError(msg);\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.collection);\n  mq.select(fields);\n\n  return mq.findOneAndDelete(conditions, options, callback);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @see Model.findOneAndRemove #model_Model.findOneAndRemove\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n */\n\nModel.findByIdAndDelete = function(id, options, callback) {\n  if (arguments.length === 1 && typeof id === 'function') {\n    const msg = 'Model.findByIdAndDelete(): First argument must not be a function.\\n\\n'\n        + '  ' + this.modelName + '.findByIdAndDelete(id, callback)\\n'\n        + '  ' + this.modelName + '.findByIdAndDelete(id)\\n'\n        + '  ' + this.modelName + '.findByIdAndDelete()\\n';\n    throw new TypeError(msg);\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return this.findOneAndDelete({_id: id}, options, callback);\n};\n\n/**\n * Issue a mongodb findAndModify remove command.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback.\n *\n * Executes immediately if `callback` is passed else a Query object is returned.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * ####Options:\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `maxTimeMS`: puts a time limit on the query - requires mongodb >= 2.6.0\n * - `select`: sets the document fields to return\n * - `projection`: like select, it determines which fields to return, ex. `{ projection: { _id: 0 } }`\n * - `rawResult`: if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n * ####Examples:\n *\n *     A.findOneAndRemove(conditions, options, callback) // executes\n *     A.findOneAndRemove(conditions, options)  // return Query\n *     A.findOneAndRemove(conditions, callback) // executes\n *     A.findOneAndRemove(conditions) // returns Query\n *     A.findOneAndRemove()           // returns Query\n *\n * Values are cast to their appropriate types when using the findAndModify helpers.\n * However, the below are not executed by default.\n *\n * - defaults. Use the `setDefaultsOnInsert` option to override.\n *\n * `findAndModify` helpers support limited validation. You can\n * enable these by setting the `runValidators` options,\n * respectively.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     Model.findById(id, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason bourne';\n *       doc.save(callback);\n *     });\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n * @api public\n */\n\nModel.findOneAndRemove = function(conditions, options, callback) {\n  if (arguments.length === 1 && typeof conditions === 'function') {\n    const msg = 'Model.findOneAndRemove(): First argument must not be a function.\\n\\n'\n        + '  ' + this.modelName + '.findOneAndRemove(conditions, callback)\\n'\n        + '  ' + this.modelName + '.findOneAndRemove(conditions)\\n'\n        + '  ' + this.modelName + '.findOneAndRemove()\\n';\n    throw new TypeError(msg);\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.collection);\n  mq.select(fields);\n\n  return mq.findOneAndRemove(conditions, options, callback);\n};\n\n/**\n * Issue a mongodb findAndModify remove command by a document's _id field. `findByIdAndRemove(id, ...)` is equivalent to `findOneAndRemove({ _id: id }, ...)`.\n *\n * Finds a matching document, removes it, passing the found document (if any) to the callback.\n *\n * Executes immediately if `callback` is passed, else a `Query` object is returned.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndRemove()`\n *\n * ####Options:\n *\n * - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update\n * - `select`: sets the document fields to return\n * - `rawResult`: if true, returns the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)\n * - `strict`: overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict) for this update\n *\n * ####Examples:\n *\n *     A.findByIdAndRemove(id, options, callback) // executes\n *     A.findByIdAndRemove(id, options)  // return Query\n *     A.findByIdAndRemove(id, callback) // executes\n *     A.findByIdAndRemove(id) // returns Query\n *     A.findByIdAndRemove()           // returns Query\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @see Model.findOneAndRemove #model_Model.findOneAndRemove\n * @see mongodb http://www.mongodb.org/display/DOCS/findAndModify+Command\n */\n\nModel.findByIdAndRemove = function(id, options, callback) {\n  if (arguments.length === 1 && typeof id === 'function') {\n    const msg = 'Model.findByIdAndRemove(): First argument must not be a function.\\n\\n'\n        + '  ' + this.modelName + '.findByIdAndRemove(id, callback)\\n'\n        + '  ' + this.modelName + '.findByIdAndRemove(id)\\n'\n        + '  ' + this.modelName + '.findByIdAndRemove()\\n';\n    throw new TypeError(msg);\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return this.findOneAndRemove({_id: id}, options, callback);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * ####Example:\n *\n *     // pass a spread of docs and a callback\n *     Candy.create({ type: 'jelly bean' }, { type: 'snickers' }, function (err, jellybean, snickers) {\n *       if (err) // ...\n *     });\n *\n *     // pass an array of docs\n *     var array = [{ type: 'jelly bean' }, { type: 'snickers' }];\n *     Candy.create(array, function (err, candies) {\n *       if (err) // ...\n *\n *       var jellybean = candies[0];\n *       var snickers = candies[1];\n *       // ...\n *     });\n *\n *     // callback is optional; use the returned promise if you like:\n *     var promise = Candy.create({ type: 'jawbreaker' });\n *     promise.then(function (jawbreaker) {\n *       // ...\n *     })\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread.\n * @param {Function} [callback] callback\n * @return {Promise}\n * @api public\n */\n\nModel.create = function create(doc, options, callback) {\n  let args;\n  let cb;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    cb = typeof options === 'function' ? options : callback;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    // Handle falsy callbacks re: #5061\n    if (typeof last === 'function' || !last) {\n      cb = last;\n      args = utils.args(arguments, 0, arguments.length - 1);\n    } else {\n      args = utils.args(arguments);\n    }\n  }\n\n  if (cb) {\n    cb = this.$wrapCallback(cb);\n  }\n\n  return utils.promiseOrCallback(cb, cb => {\n    if (args.length === 0) {\n      return cb(null);\n    }\n\n    const toExecute = [];\n    let firstError;\n    args.forEach(doc => {\n      toExecute.push(callback => {\n        const Model = this.discriminators && doc[discriminatorKey] != null ?\n          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this, doc[discriminatorKey]) :\n          this;\n        if (Model == null) {\n          throw new Error(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n        }\n        let toSave = doc;\n        const callbackWrapper = (error, doc) => {\n          if (error) {\n            if (!firstError) {\n              firstError = error;\n            }\n            return callback(null, { error: error });\n          }\n          callback(null, { doc: doc });\n        };\n\n        if (!(toSave instanceof Model)) {\n          try {\n            toSave = new Model(toSave);\n          } catch (error) {\n            return callbackWrapper(error);\n          }\n        }\n\n        toSave.save(options, callbackWrapper);\n      });\n    });\n\n    parallel(toExecute, (error, res) => {\n      const savedDocs = [];\n      const len = res.length;\n      for (let i = 0; i < len; ++i) {\n        if (res[i].doc) {\n          savedDocs.push(res[i].doc);\n        }\n      }\n\n      if (firstError) {\n        return cb(firstError, savedDocs);\n      }\n\n      if (doc instanceof Array) {\n        cb(null, savedDocs);\n      } else {\n        cb.apply(this, [null].concat(savedDocs));\n      }\n    });\n  });\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://docs.mongodb.com/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * ####Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.remove();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/3.0/api/Collection.html#watch)\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function(pipeline, options) {\n  return new ChangeStream(this, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://docs.mongodb.com/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/),\n * and [transactions](http://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * ####Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.remove();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/3.0/api/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @param {Function} [callback]\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function() {\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://docs.mongodb.com/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * ####Example:\n *\n *     var arr = [{ name: 'Star Wars' }, { name: 'The Empire Strikes Back' }];\n *     Movies.insertMany(arr, function(error, docs) {});\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#insertMany)\n * @param {Boolean} [options.ordered = true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult = false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#~insertWriteOpCallback) with a `mongoose` property that contains `validationErrors` if this is an unordered `insertMany`.\n * @param {Function} [callback] callback\n * @return {Promise}\n * @api public\n */\n\nModel.insertMany = function(arr, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  return utils.promiseOrCallback(callback, cb => {\n    this.$__insertMany(arr, options, cb);\n  });\n};\n\n/*!\n * ignore\n */\n\nModel.$__insertMany = function(arr, options, callback) {\n  const _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n  callback = callback || utils.noop;\n  options = options || {};\n  const limit = get(options, 'limit', 1000);\n  const rawResult = get(options, 'rawResult', false);\n  const ordered = get(options, 'ordered', true);\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  const toExecute = [];\n  const validationErrors = [];\n  arr.forEach(function(doc) {\n    toExecute.push(function(callback) {\n      if (!(doc instanceof _this)) {\n        doc = new _this(doc);\n      }\n      doc.validate({ __noPromise: true }, function(error) {\n        if (error) {\n          // Option `ordered` signals that insert should be continued after reaching\n          // a failing insert. Therefore we delegate \"null\", meaning the validation\n          // failed. It's up to the next function to filter out all failed models\n          if (ordered === false) {\n            validationErrors.push(error);\n            return callback(null, null);\n          }\n          return callback(error);\n        }\n        callback(null, doc);\n      });\n    });\n  });\n\n  parallelLimit(toExecute, limit, function(error, docs) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n    // We filter all failed pre-validations by removing nulls\n    const docAttributes = docs.filter(function(doc) {\n      return doc != null;\n    });\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length < 1) {\n      callback(null, []);\n      return;\n    }\n    const docObjects = docAttributes.map(function(doc) {\n      if (doc.schema.options.versionKey) {\n        doc[doc.schema.options.versionKey] = 0;\n      }\n      if (doc.initializeTimestamps) {\n        return doc.initializeTimestamps().toObject(internalToObjectOptions);\n      }\n      return doc.toObject(internalToObjectOptions);\n    });\n\n    _this.collection.insertMany(docObjects, options, function(error, res) {\n      if (error) {\n        callback(error, null);\n        return;\n      }\n      for (let i = 0; i < docAttributes.length; ++i) {\n        docAttributes[i].isNew = false;\n        docAttributes[i].emit('isNew', false);\n        docAttributes[i].constructor.emit('isNew', false);\n      }\n      if (rawResult) {\n        if (ordered === false) {\n          // Decorate with mongoose validation errors in case of unordered,\n          // because then still do `insertMany()`\n          res.mongoose = {\n            validationErrors: validationErrors\n          };\n        }\n        return callback(null, res);\n      }\n      callback(null, docAttributes);\n    });\n  });\n};\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (like)\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n *\n * This function does **not** trigger any middleware, not `save()` nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](http://mongoosejs.com/docs/api.html#model_Model.create) instead.\n *\n * ####Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           {\n *             filter: { name: 'Eddard Stark' }\n *           }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n * @param {Array} ops\n * @param {Object} [options]\n * @param {Function} [callback] callback `function(error, bulkWriteOpResult) {}`\n * @return {Promise} resolves to a [`BulkWriteOpResult`](http://mongodb.github.io/node-mongodb-native/3.1/api/Collection.html#~BulkWriteOpResult) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = function(ops, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n  options = options || {};\n\n  const validations = ops.map(op => castBulkWrite(this, op));\n\n  return utils.promiseOrCallback(callback, cb => {\n    parallel(validations, error => {\n      if (error) {\n        return cb(error);\n      }\n\n      this.collection.bulkWrite(ops, options, (error, res) => {\n        if (error) {\n          return cb(error);\n        }\n\n        cb(null, res);\n      });\n    });\n  });\n};\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * ####Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     var mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @return {Model} document instance\n * @api public\n */\n\nModel.hydrate = function(obj) {\n  const model = require('./queryhelpers').createModel(this, obj);\n  model.init(obj);\n  return model;\n};\n\n/**\n * Updates one document in the database without returning it.\n *\n * This function triggers the following middleware.\n *\n * - `update()`\n *\n * ####Examples:\n *\n *     MyModel.update({ age: { $gt: 18 } }, { oldEnough: true }, fn);\n *     MyModel.update({ name: 'Tobi' }, { ferret: true }, { multi: true }, function (err, raw) {\n *       if (err) return handleError(err);\n *       console.log('The raw response from Mongo was ', raw);\n *     });\n *\n * ####Valid options:\n *\n *  - `safe` (boolean) safe mode (defaults to value set in schema (true))\n *  - `upsert` (boolean) whether to create the doc if it doesn't match (false)\n *  - `multi` (boolean) whether multiple documents should be updated (false)\n *  - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema.\n *  - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created. This option only works on MongoDB >= 2.4 because it relies on [MongoDB's `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).\n *  - `strict` (boolean) overrides the `strict` option for this update\n *  - `overwrite` (boolean) disables update-only mode, allowing you to overwrite the doc (false)\n *\n * All `update` values are cast to their appropriate SchemaTypes before being sent.\n *\n * The `callback` function receives `(err, rawResponse)`.\n *\n * - `err` is the error if any occurred\n * - `rawResponse` is the full response from Mongo\n *\n * ####Note:\n *\n * All top level keys which are not `atomic` operation names are treated as set operations:\n *\n * ####Example:\n *\n *     var query = { name: 'borne' };\n *     Model.update(query, { name: 'jason bourne' }, options, callback)\n *\n *     // is sent as\n *     Model.update(query, { $set: { name: 'jason bourne' }}, options, callback)\n *     // if overwrite option is false. If overwrite is true, sent without the $set wrapper.\n *\n * This helps prevent accidentally overwriting all documents in your collection with `{ name: 'jason bourne' }`.\n *\n * ####Note:\n *\n * Be careful to not use an existing model instance for the update clause (this won't work and can cause weird behavior like infinite loops). Also, ensure that the update clause does not have an _id property, which causes Mongo to return a \"Mod on _id not allowed\" error.\n *\n * ####Note:\n *\n * Although values are casted to their appropriate types when using update, the following are *not* applied:\n *\n * - defaults\n * - setters\n * - validators\n * - middleware\n *\n * If you need those features, use the traditional approach of first retrieving the document.\n *\n *     Model.findOne({ name: 'borne' }, function (err, doc) {\n *       if (err) ..\n *       doc.name = 'jason bourne';\n *       doc.save(callback);\n *     })\n *\n * @see strict http://mongoosejs.com/docs/guide.html#strict\n * @see response http://docs.mongodb.org/v2.6/reference/command/update/#output\n * @param {Object} conditions\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.update = function update(conditions, doc, options, callback) {\n  return _update(this, 'update', conditions, doc, options, callback);\n};\n\n/**\n * Same as `update()`, except MongoDB will update _all_ documents that match\n * `criteria` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} conditions\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, doc, options, callback) {\n  return _update(this, 'updateMany', conditions, doc, options, callback);\n};\n\n/**\n * Same as `update()`, except it does not support the `multi` or `overwrite`\n * options.\n *\n * - MongoDB will update _only_ the first document that matches `criteria` regardless of the value of the `multi` option.\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} conditions\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options, callback) {\n  return _update(this, 'updateOne', conditions, doc, options, callback);\n};\n\n/**\n * Same as `update()`, except MongoDB replace the existing document with the\n * given document (no atomic operators like `$set`).\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} conditions\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)\n * @param {Function} [callback]\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options, callback) {\n  const versionKey = get(this, 'schema.options.versionKey', null);\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options, callback);\n};\n\n/*!\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n */\n\nfunction _update(model, op, conditions, doc, options, callback) {\n  const mq = new model.Query({}, {}, model, model.collection);\n  if (callback) {\n    callback = model.$wrapCallback(callback);\n  }\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = utils.clone(conditions);\n  }\n  options = typeof options === 'function' ? options : utils.clone(options);\n\n  const versionKey = get(model, 'schema.options.versionKey', null);\n  _decorateUpdateWithVersionKey(doc, options, versionKey);\n\n  return mq[op](conditions, doc, options, callback);\n}\n\n/**\n * Executes a mapReduce command.\n *\n * `o` is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver implementation. See [node-mongodb-native mapReduce() documentation](http://mongodb.github.io/node-mongodb-native/api-generated/collection.html#mapreduce) for more detail about options.\n *\n * This function does not trigger any middleware.\n *\n * ####Example:\n *\n *     var o = {};\n *     // `map()` and `reduce()` are run on the MongoDB server, not Node.js,\n *     // these functions are converted to strings\n *     o.map = function () { emit(this.name, 1) };\n *     o.reduce = function (k, vals) { return vals.length };\n *     User.mapReduce(o, function (err, results) {\n *       console.log(results)\n *     })\n *\n * ####Other options:\n *\n * - `query` {Object} query filter object.\n * - `sort` {Object} sort input objects using this key\n * - `limit` {Number} max number of documents\n * - `keeptemp` {Boolean, default:false} keep temporary data\n * - `finalize` {Function} finalize function\n * - `scope` {Object} scope variables exposed to map/reduce/finalize during execution\n * - `jsMode` {Boolean, default:false} it is possible to make the execution stay in JS. Provided in MongoDB > 2.0.X\n * - `verbose` {Boolean, default:false} provide statistics on job execution time.\n * - `readPreference` {String}\n * - `out*` {Object, default: {inline:1}} sets the output target for the map reduce job.\n *\n * ####* out options:\n *\n * - `{inline:1}` the results are returned in an array\n * - `{replace: 'collectionName'}` add the results to collectionName: the results replace the collection\n * - `{reduce: 'collectionName'}` add the results to collectionName: if dups are detected, uses the reducer / finalize functions\n * - `{merge: 'collectionName'}` add the results to collectionName: if dups exist the new docs overwrite the old\n *\n * If `options.out` is set to `replace`, `merge`, or `reduce`, a Model instance is returned that can be used for further querying. Queries run against this model are all executed with the `lean` option; meaning only the js object is returned and no Mongoose magic is applied (getters, setters, etc).\n *\n * ####Example:\n *\n *     var o = {};\n *     // You can also define `map()` and `reduce()` as strings if your\n *     // linter complains about `emit()` not being defined\n *     o.map = 'function () { emit(this.name, 1) }';\n *     o.reduce = 'function (k, vals) { return vals.length }';\n *     o.out = { replace: 'createdCollectionNameForResults' }\n *     o.verbose = true;\n *\n *     User.mapReduce(o, function (err, model, stats) {\n *       console.log('map reduce took %d ms', stats.processtime)\n *       model.find().where('value').gt(10).exec(function (err, docs) {\n *         console.log(docs);\n *       });\n *     })\n *\n *     // `mapReduce()` returns a promise. However, ES6 promises can only\n *     // resolve to exactly one value,\n *     o.resolveToObject = true;\n *     var promise = User.mapReduce(o);\n *     promise.then(function (res) {\n *       var model = res.model;\n *       var stats = res.stats;\n *       console.log('map reduce took %d ms', stats.processtime)\n *       return model.find().where('value').gt(10).exec();\n *     }).then(function (docs) {\n *        console.log(docs);\n *     }).then(null, handleError).end()\n *\n * @param {Object} o an object specifying map-reduce options\n * @param {Function} [callback] optional callback\n * @see http://www.mongodb.org/display/DOCS/MapReduce\n * @return {Promise}\n * @api public\n */\n\nModel.mapReduce = function mapReduce(o, callback) {\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n  return utils.promiseOrCallback(callback, cb => {\n    if (!Model.mapReduce.schema) {\n      const opts = {noId: true, noVirtualId: true, strict: false};\n      Model.mapReduce.schema = new Schema({}, opts);\n    }\n\n    if (!o.out) o.out = {inline: 1};\n    if (o.verbose !== false) o.verbose = true;\n\n    o.map = String(o.map);\n    o.reduce = String(o.reduce);\n\n    if (o.query) {\n      let q = new this.Query(o.query);\n      q.cast(this);\n      o.query = q._conditions;\n      q = undefined;\n    }\n\n    this.collection.mapReduce(null, null, o, (err, res) => {\n      if (err) {\n        return cb(err);\n      }\n      if (res.collection) {\n        // returned a collection, convert to Model\n        const model = Model.compile('_mapreduce_' + res.collection.collectionName,\n          Model.mapReduce.schema, res.collection.collectionName, this.db,\n          this.base);\n\n        model._mapreduce = true;\n        res.model = model;\n\n        return cb(null, res);\n      }\n\n      cb(null, res);\n    });\n  });\n};\n\n/**\n * Performs [aggregations](http://docs.mongodb.org/manual/applications/aggregation/) on the models collection.\n *\n * If a `callback` is passed, the `aggregate` is executed and a `Promise` is returned. If a callback is not passed, the `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * ####Example:\n *\n *     // Find the max balance of all accounts\n *     Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]).\n *     then(function (res) {\n *       console.log(res); // [ { maxBalance: 98000 } ]\n *     });\n *\n *     // Or use the aggregation pipeline builder.\n *     Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec(function (err, res) {\n *         if (err) return handleError(err);\n *         console.log(res); // [ { maxBalance: 98 } ]\n *       });\n *\n * ####NOTE:\n *\n * - Arguments are not cast to the model's schema because `$project` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n * - Requires MongoDB >= 2.1\n *\n * @see Aggregate #aggregate_Aggregate\n * @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Function} [callback]\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, callback) {\n  if (arguments.length > 2 || get(pipeline, 'constructor.name') === 'Object') {\n    throw new Error('Mongoose 5.x disallows passing a spread of operators ' +\n      'to `Model.aggregate()`. Instead of ' +\n      '`Model.aggregate({ $match }, { $skip })`, do ' +\n      '`Model.aggregate([{ $match }, { $skip }])`');\n  }\n\n  if (typeof pipeline === 'function') {\n    callback = pipeline;\n    pipeline = [];\n  }\n\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n\n  if (typeof callback === 'undefined') {\n    return aggregate;\n  }\n\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  aggregate.exec(callback);\n  return aggregate;\n};\n\n/**\n * Implements `$geoSearch` functionality for Mongoose\n *\n * This function does not trigger any middleware\n *\n * ####Example:\n *\n *     var options = { near: [10, 10], maxDistance: 5 };\n *     Locations.geoSearch({ type : \"house\" }, options, function(err, res) {\n *       console.log(res);\n *     });\n *\n * ####Options:\n * - `near` {Array} x,y point to search for\n * - `maxDistance` {Number} the maximum distance from the point near that a result can be\n * - `limit` {Number} The maximum number of results to return\n * - `lean` {Boolean} return the raw object instead of the Mongoose Model\n *\n * @param {Object} conditions an object that specifies the match condition (required)\n * @param {Object} options for the geoSearch, some (near, maxDistance) are required\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](http://mongoosejs.com/docs/api.html#query_Query-lean).\n * @param {Function} [callback] optional callback\n * @return {Promise}\n * @see http://docs.mongodb.org/manual/reference/command/geoSearch/\n * @see http://docs.mongodb.org/manual/core/geohaystack/\n * @api public\n */\n\nModel.geoSearch = function(conditions, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  return utils.promiseOrCallback(callback, cb => {\n    let error;\n    if (conditions === undefined || !utils.isObject(conditions)) {\n      error = new Error('Must pass conditions to geoSearch');\n    } else if (!options.near) {\n      error = new Error('Must specify the near option in geoSearch');\n    } else if (!Array.isArray(options.near)) {\n      error = new Error('near option must be an array [x, y]');\n    }\n\n    if (error) {\n      return cb(error);\n    }\n\n    // send the conditions in the options object\n    options.search = conditions;\n\n    this.collection.geoHaystackSearch(options.near[0], options.near[1], options, (err, res) => {\n      if (err) {\n        return cb(err);\n      }\n\n      let count = res.results.length;\n      if (options.lean || count === 0) {\n        return cb(null, res.results);\n      }\n\n      const errSeen = false;\n\n      function init(err) {\n        if (err && !errSeen) {\n          return cb(err);\n        }\n\n        if (!--count && !errSeen) {\n          cb(null, res.results);\n        }\n      }\n\n      for (let i = 0; i < res.results.length; ++i) {\n        const temp = res.results[i];\n        res.results[i] = new this();\n        res.results[i].init(temp, {}, init);\n      }\n    });\n  });\n};\n\n/**\n * Populates document references.\n *\n * ####Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to an array. Inferred from schema by default.\n *\n * ####Examples:\n *\n *     // populates a single object\n *     User.findById(id, function (err, user) {\n *       var opts = [\n *           { path: 'company', match: { x: 1 }, select: 'name' }\n *         , { path: 'notes', options: { limit: 10 }, model: 'override' }\n *       ]\n *\n *       User.populate(user, opts, function (err, user) {\n *         console.log(user);\n *       });\n *     });\n *\n *     // populates an array of objects\n *     User.find(match, function (err, users) {\n *       var opts = [{ path: 'company', match: { x: 1 }, select: 'name' }]\n *\n *       var promise = User.populate(users, opts);\n *       promise.then(console.log).end();\n *     })\n *\n *     // imagine a Weapon model exists with two saved documents:\n *     //   { _id: 389, name: 'whip' }\n *     //   { _id: 8921, name: 'boomerang' }\n *     // and this schema:\n *     // new Schema({\n *     //   name: String,\n *     //   weapon: { type: ObjectId, ref: 'Weapon' }\n *     // });\n *\n *     var user = { name: 'Indiana Jones', weapon: 389 }\n *     Weapon.populate(user, { path: 'weapon', model: 'Weapon' }, function (err, user) {\n *       console.log(user.weapon.name) // whip\n *     })\n *\n *     // populate many plain objects\n *     var users = [{ name: 'Indiana Jones', weapon: 389 }]\n *     users.push({ name: 'Batman', weapon: 8921 })\n *     Weapon.populate(users, { path: 'weapon' }, function (err, users) {\n *       users.forEach(function (user) {\n *         console.log('%s uses a %s', users.name, user.weapon.name)\n *         // Indiana Jones uses a whip\n *         // Batman uses a boomerang\n *       });\n *     });\n *     // Note that we didn't need to specify the Weapon model because\n *     // it is in the schema's ref\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} options A hash of key/val (path, options) used for population.\n * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](/docs/schematypes.html#schematype-options).\n * @param {Function} [callback(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = function(docs, paths, callback) {\n  const _this = this;\n  if (callback) {\n    callback = this.$wrapCallback(callback);\n  }\n\n  // normalized paths\n  paths = utils.populate(paths);\n\n  // data that should persist across subPopulate calls\n  const cache = {};\n\n  return utils.promiseOrCallback(callback, cb => {\n    _populate(_this, docs, paths, cache, cb);\n  });\n};\n\n/*!\n * Populate helper\n *\n * @param {Model} model the model to use\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object} paths\n * @param {Function} [cb(err,doc)] Optional callback, executed upon completion. Receives `err` and the `doc(s)`.\n * @return {Function}\n * @api private\n */\n\nfunction _populate(model, docs, paths, cache, callback) {\n  let pending = paths.length;\n\n  if (pending === 0) {\n    return callback(null, docs);\n  }\n\n  // each path has its own query options and must be executed separately\n  let i = pending;\n  let path;\n  while (i--) {\n    path = paths[i];\n    populate(model, docs, path, next);\n  }\n\n  function next(err) {\n    if (err) {\n      return callback(err, null);\n    }\n    if (--pending) {\n      return;\n    }\n    callback(null, docs);\n  }\n}\n\n/*!\n * Populates `docs`\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nfunction populate(model, docs, options, callback) {\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return callback();\n  }\n\n  const modelsMap = getModelsMapForPopulate(model, docs, options);\n\n  if (modelsMap instanceof Error) {\n    return immediate(function() {\n      callback(modelsMap);\n    });\n  }\n\n  const len = modelsMap.length;\n  let mod;\n  let match;\n  let select;\n  let vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  let _remaining = len;\n  let hasOne = false;\n  for (let i = 0; i < len; ++i) {\n    mod = modelsMap[i];\n    select = mod.options.select;\n\n    if (mod.options.match) {\n      match = utils.object.shallowCopy(mod.options.match);\n    } else if (get(mod, 'options.options.match')) {\n      match = utils.object.shallowCopy(mod.options.options.match);\n      delete mod.options.options.match;\n    } else {\n      match = {};\n    }\n\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      --_remaining;\n      continue;\n    }\n\n    hasOne = true;\n    if (mod.foreignField.size === 1) {\n      const foreignField = Array.from(mod.foreignField)[0];\n      if (foreignField !== '_id' || !match['_id']) {\n        match[foreignField] = { $in: ids };\n      }\n    } else {\n      match.$or = [];\n      for (const foreignField of mod.foreignField) {\n        if (foreignField !== '_id' || !match['_id']) {\n          match.$or.push({ [foreignField]: { $in: ids } });\n        }\n      }\n    }\n\n    const assignmentOpts = {};\n    assignmentOpts.sort = get(mod, 'options.options.sort', void 0);\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else {\n        // preserve original select conditions by copying\n        select = utils.object.shallowCopy(select);\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options && mod.options.options.limit) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n      mod.options.options.limit = mod.options.options.limit * ids.length;\n    }\n\n    const subPopulate = utils.clone(mod.options.populate);\n    const query = mod.model.find(match, select, mod.options.options);\n\n    // If we're doing virtual populate and projection is inclusive and foreign\n    // field is not selected, automatically select it because mongoose needs it.\n    // If projection is exclusive and client explicitly unselected the foreign\n    // field, that's the client's fault.\n    for (const foreignField of mod.foreignField) {\n      if (foreignField !== '_id' && query.selectedInclusively() &&\n          !isPathSelectedInclusive(query._fields, foreignField)) {\n        query.select(foreignField);\n      }\n    }\n\n    // If we need to sub-populate, call populate recursively\n    if (subPopulate) {\n      query.populate(subPopulate);\n    }\n\n    query.exec(next.bind(this, mod, assignmentOpts));\n  }\n\n  if (!hasOne) {\n    return callback();\n  }\n\n  function next(options, assignmentOpts, err, valsFromDb) {\n    if (mod.options.options && mod.options.options.limit) {\n      mod.options.options.limit = assignmentOpts.originalLimit;\n    }\n\n    if (err) return callback(err, null);\n    vals = vals.concat(valsFromDb);\n    _assign(null, vals, options, assignmentOpts);\n    if (--_remaining === 0) {\n      callback();\n    }\n  }\n\n  function _assign(err, vals, mod, assignmentOpts) {\n    if (err) {\n      return callback(err, null);\n    }\n\n    const options = mod.options;\n    const isVirtual = mod.isVirtual;\n    const justOne = mod.justOne;\n    let _val;\n    const lean = options.options && options.options.lean;\n    const len = vals.length;\n    const rawOrder = {};\n    const rawDocs = {};\n    let key;\n    let val;\n\n    // Clone because `assignRawDocsToIdStructure` will mutate the array\n    const allIds = utils.clone(mod.allIds);\n\n    // optimization:\n    // record the document positions as returned by\n    // the query result.\n    for (let i = 0; i < len; i++) {\n      val = vals[i];\n      if (val == null) {\n        continue;\n      }\n      for (const foreignField of mod.foreignField) {\n        _val = utils.getValue(foreignField, val);\n        if (Array.isArray(_val)) {\n          const _valLength = _val.length;\n          for (let j = 0; j < _valLength; ++j) {\n            let __val = _val[j];\n            if (__val instanceof Document) {\n              __val = __val._id;\n            }\n            key = String(__val);\n            if (rawDocs[key]) {\n              if (Array.isArray(rawDocs[key])) {\n                rawDocs[key].push(val);\n                rawOrder[key].push(i);\n              } else {\n                rawDocs[key] = [rawDocs[key], val];\n                rawOrder[key] = [rawOrder[key], i];\n              }\n            } else {\n              if (isVirtual && !justOne) {\n                rawDocs[key] = [val];\n                rawOrder[key] = [i];\n              } else {\n                rawDocs[key] = val;\n                rawOrder[key] = i;\n              }\n            }\n          }\n        } else {\n          if (_val instanceof Document) {\n            _val = _val._id;\n          }\n          key = String(_val);\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            rawDocs[key] = val;\n            rawOrder[key] = i;\n          }\n        }\n        // flag each as result of population\n        if (lean) {\n          leanPopulateMap.set(val, mod.model);\n        } else {\n          val.$__.wasPopulated = true;\n        }\n      }\n    }\n\n    assignVals({\n      originalModel: model,\n      // If virtual, make sure to not mutate original field\n      rawIds: mod.isVirtual ? allIds : mod.allIds,\n      allIds: allIds,\n      foreignField: mod.foreignField,\n      rawDocs: rawDocs,\n      rawOrder: rawOrder,\n      docs: mod.docs,\n      path: options.path,\n      options: assignmentOpts,\n      justOne: mod.justOne,\n      isVirtual: mod.isVirtual,\n      allOptions: mod,\n      lean: lean,\n      virtual: mod.virtual\n    });\n  }\n}\n\n/*!\n * Assigns documents returned from a population query back\n * to the original document path.\n */\n\nfunction assignVals(o) {\n  // Glob all options together because `populateOptions` is confusing\n  const retainNullValues = get(o, 'allOptions.options.options.retainNullValues', false);\n  const populateOptions = Object.assign({}, o.options, {\n    justOne: o.justOne,\n    retainNullValues: retainNullValues\n  });\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n\n  function setValue(val) {\n    return valueFilter(val, options, populateOptions);\n  }\n\n  for (let i = 0; i < docs.length; ++i) {\n    const existingVal = utils.getValue(o.path, docs[i]);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, o.path)) {\n      continue;\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    let isMap = isModel(docs[i]) ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(o.path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      rawIds[i] = rawIds[i].reduce((cur, v, i) => {\n        // Avoid casting because that causes infinite recursion\n        cur.$init(_keys[i], v);\n        return cur;\n      }, new MongooseMap({}, docs[i]));\n    }\n\n    if (o.isVirtual && docs[i] instanceof Model) {\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      mpath.set(o.path, rawIds[i], docs[i], setValue);\n      continue;\n    }\n\n    const parts = o.path.split('.');\n    let cur = docs[i];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      if (cur[parts[j]] == null) {\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n    }\n    if (docs[i].$__) {\n      docs[i].populated(o.path, o.allIds[i], o.allOptions);\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    utils.setValue(o.path, rawIds[i], docs[i], function(v) {\n      if (o.justOne === true && Array.isArray(v)) {\n        return setValue(v[0]);\n      } else if (o.justOne === false && !Array.isArray(v)) {\n        return setValue([v]);\n      }\n      return setValue(v);\n    }, false);\n  }\n}\n\n/*!\n * Check if obj is a document\n */\n\nfunction isModel(obj) {\n  return get(obj, '$__') != null;\n}\n\nfunction getModelsMapForPopulate(model, docs, options) {\n  let i;\n  let doc;\n  const len = docs.length;\n  const available = {};\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let Model;\n  let currentOptions;\n  let modelNames;\n  let modelName;\n  let discriminatorKey;\n  let modelForFindSchema;\n\n  const originalModel = options.model;\n  let isVirtual = false;\n  const modelSchema = model.schema;\n\n  for (i = 0; i < len; i++) {\n    doc = docs[i];\n\n    schema = getSchemaTypes(modelSchema, doc, options.path);\n    const isUnderneathDocArray = schema && schema.$isUnderneathDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new Error('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    if (Array.isArray(schema)) {\n      for (let j = 0; j < schema.length; ++j) {\n        let _modelNames;\n        try {\n          const res = _getModelNames(doc, schema[j]);\n          _modelNames = res.modelNames;\n          isRefPath = res.isRefPath;\n        } catch (error) {\n          return error;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (let x = 0; x < _modelNames.length; ++x) {\n          if (modelNames.indexOf(_modelNames[x]) === -1) {\n            modelNames.push(_modelNames[x]);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const virtual = getVirtual(model.schema, options.path);\n    let localField;\n    if (virtual && virtual.options) {\n      const virtualPrefix = virtual.$nestedSchemaPath ?\n        virtual.$nestedSchemaPath + '.' : '';\n      if (typeof virtual.options.localField === 'function') {\n        localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n      } else {\n        localField = virtualPrefix + virtual.options.localField;\n      }\n    } else {\n      localField = options.path;\n    }\n    let foreignField = virtual && virtual.options ?\n      virtual.options.foreignField :\n      '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options) {\n      justOne = options.justOne;\n    } else if (virtual && virtual.options && virtual.options.ref) {\n      let normalizedRef;\n      if (typeof virtual.options.ref === 'function') {\n        normalizedRef = virtual.options.ref.call(doc, doc);\n      } else {\n        normalizedRef = virtual.options.ref;\n      }\n      justOne = !!virtual.options.justOne;\n      isVirtual = true;\n      if (!modelNames) {\n        modelNames = [].concat(normalizedRef);\n      }\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      justOne = !schema.$isMongooseArray;\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    if (virtual && (!localField || !foreignField)) {\n      return new Error('If you are populating a virtual, you must set the ' +\n        'localField and foreignField options');\n    }\n\n    options.isVirtual = isVirtual;\n    options.virtual = virtual;\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc);\n    }\n\n    const localFieldPath = modelSchema.paths[localField];\n    const localFieldGetters = localFieldPath ? localFieldPath.getters : [];\n    let ret;\n\n    const _populateOptions = get(options, 'options', {});\n\n    const getters = 'getters' in _populateOptions ?\n      _populateOptions.getters :\n      options.isVirtual && get(virtual, 'options.getters', false);\n    if (localFieldGetters.length > 0 && getters) {\n      const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n      ret = localFieldPath.applyGetters(doc[localField], hydratedDoc);\n    } else {\n      ret = convertTo_id(utils.getValue(localField, doc));\n    }\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let k = modelNames.length;\n    while (k--) {\n      modelName = modelNames[k];\n      if (modelName == null) {\n        continue;\n      }\n\n      try {\n        Model = originalModel && originalModel[modelSymbol] ?\n          originalModel :\n          modelName[modelSymbol] ? modelName : model.db.model(modelName);\n      } catch (error) {\n        return error;\n      }\n\n      let ids = ret;\n      const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n      if (isRefPath && Array.isArray(ret) && flat.length === modelNames.length) {\n        ids = flat.filter((val, i) => modelNames[i] === modelName);\n      }\n\n      if (!available[modelName]) {\n        currentOptions = {\n          model: Model\n        };\n\n        if (isVirtual && virtual.options && virtual.options.options) {\n          currentOptions.options = utils.clone(virtual.options.options);\n        }\n        utils.merge(currentOptions, options);\n        if (schema && !discriminatorKey) {\n          currentOptions.model = Model;\n        }\n        options.model = Model;\n\n        available[modelName] = {\n          model: Model,\n          options: currentOptions,\n          docs: [doc],\n          ids: [ids],\n          allIds: [ret],\n          localField: new Set([localField]),\n          foreignField: new Set([foreignField]),\n          justOne: justOne,\n          isVirtual: isVirtual,\n          virtual: virtual\n        };\n        map.push(available[modelName]);\n      } else {\n        available[modelName].localField.add(localField);\n        available[modelName].foreignField.add(foreignField);\n        available[modelName].docs.push(doc);\n        available[modelName].ids.push(ids);\n        available[modelName].allIds.push(ret);\n      }\n    }\n  }\n\n  function _getModelNames(doc, schema) {\n    let modelNames;\n    let discriminatorKey;\n    let isRefPath = false;\n\n    if (schema && schema.caster) {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    if (!schema && model.discriminators) {\n      discriminatorKey = model.schema.discriminatorMapping.key;\n    }\n\n    refPath = schema && schema.options && schema.options.refPath;\n\n    let normalizedRefPath;\n\n    if (refPath && typeof refPath === 'function') {\n      normalizedRefPath = refPath.call(doc, doc, options.path);\n    } else {\n      normalizedRefPath = refPath;\n    }\n\n    if (normalizedRefPath) {\n      if (options._queryProjection != null && isPathExcluded(options._queryProjection, normalizedRefPath)) {\n        throw new Error('refPath `' + normalizedRefPath +\n          '` must not be excluded in projection, got ' +\n          util.inspect(options._queryProjection));\n      }\n      modelNames = utils.getValue(normalizedRefPath, doc);\n      if (Array.isArray(modelNames)) {\n        modelNames = utils.array.flatten(modelNames);\n      }\n      isRefPath = true;\n    } else {\n      if (!modelNameFromQuery) {\n        let modelForCurrentDoc = model;\n        let schemaForCurrentDoc;\n\n        if (!schema && discriminatorKey) {\n          modelForFindSchema = utils.getValue(discriminatorKey, doc);\n\n          if (modelForFindSchema) {\n            try {\n              modelForCurrentDoc = model.db.model(modelForFindSchema);\n            } catch (error) {\n              return error;\n            }\n\n            schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n            if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n              schemaForCurrentDoc = schemaForCurrentDoc.caster;\n            }\n          }\n        } else {\n          schemaForCurrentDoc = schema;\n        }\n        const virtual = getVirtual(modelForCurrentDoc.schema, options.path);\n\n        let ref;\n        if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n          modelNames = [ref];\n        } else if ((ref = get(virtual, 'options.ref')) != null) {\n          if (typeof ref === 'function') {\n            ref = ref.call(doc, doc);\n          }\n\n          // When referencing nested arrays, the ref should be an Array\n          // of modelNames.\n          if (Array.isArray(ref)) {\n            modelNames = ref;\n          } else {\n            modelNames = [ref];\n          }\n\n          isVirtual = true;\n        } else {\n          // We may have a discriminator, in which case we don't want to\n          // populate using the base model by default\n          modelNames = discriminatorKey ? null : [model.modelName];\n        }\n      } else {\n        modelNames = [modelNameFromQuery]; // query options\n      }\n    }\n\n    if (!modelNames) {\n      return { modelNames: modelNames, isRefPath: isRefPath };\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, isRefPath: isRefPath };\n  }\n\n  return map;\n}\n\n/*!\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @return {Array|Document|Any}\n */\n\nfunction convertTo_id(val) {\n  if (val instanceof Model) return val._id;\n\n  if (Array.isArray(val)) {\n    for (let i = 0; i < val.length; ++i) {\n      if (val[i] instanceof Model) {\n        val[i] = val[i]._id;\n      }\n    }\n    if (val.isMongooseArray && val._schema) {\n      return val._schema.cast(val, val._parent);\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (val != null && val.constructor.name === 'Object') {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map').execPopulate()`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions) {\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      const subdoc = val[i];\n      if (!isDoc(subdoc) && (!populateOptions.retainNullValues || subdoc != null)) {\n        continue;\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > ret.length) {\n      Array.prototype.pop.apply(val, []);\n    }\n    for (let i = 0; i < ret.length; ++i) {\n      val[i] = ret[i];\n    }\n    return val;\n  }\n\n  // findOne\n  if (isDoc(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return val;\n  }\n\n  if (populateOptions.justOne === true) {\n    return (val == null ? val : null);\n  }\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n  return val;\n}\n\n/*!\n * Remove _id from `subdoc` if user specified \"lean\" query option\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (assignmentOpts.excludeId) {\n    if (typeof subdoc.setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/*!\n * Determine if `doc` is a document returned\n * by a populate query.\n */\n\nfunction isDoc(doc) {\n  if (doc == null) {\n    return false;\n  }\n\n  const type = typeof doc;\n  if (type === 'string') {\n    return false;\n  }\n\n  if (type === 'number') {\n    return false;\n  }\n\n  if (Buffer.isBuffer(doc)) {\n    return false;\n  }\n\n  if (doc.constructor.name === 'ObjectID') {\n    return false;\n  }\n\n  // only docs\n  return true;\n}\n\n/*!\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n\n  setParentPointers(schema);\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n  if (!(model.prototype instanceof Model)) {\n    model.__proto__ = Model;\n    model.prototype.__proto__ = Model.prototype;\n  }\n  model.model = Model.prototype.model;\n  model.db = model.prototype.db = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n\n  model.prototype.$__setSchema(schema);\n\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n\n  // `bufferCommands` is true by default...\n  let bufferCommands = true;\n  // First, take the global option\n  if (connection.base.get('bufferCommands') != null) {\n    bufferCommands = connection.base.get('bufferCommands');\n  }\n  // Connection-specific overrides the global option\n  if (connection.config.bufferCommands != null) {\n    bufferCommands = connection.config.bufferCommands;\n  }\n  // And schema options override global and connection\n  if (_userProvidedOptions.bufferCommands != null) {\n    bufferCommands = _userProvidedOptions.bufferCommands;\n  }\n\n  const collectionOptions = {\n    bufferCommands: bufferCommands,\n    capped: schema.options.capped\n  };\n\n  model.prototype.collection = connection.collection(\n    collectionName,\n    collectionOptions\n  );\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n\n  model.schema = model.prototype.schema;\n  model.collection = model.prototype.collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n  };\n  model.Query.prototype = Object.create(Query.prototype);\n  model.Query.base = Query.base;\n  applyQueryMiddleware(model.Query, model);\n  applyQueryMethods(model, schema.query);\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1\n  };\n  model.$__insertMany = model.hooks.createWrapper('insertMany',\n    model.$__insertMany, model, kareemOptions);\n\n  return model;\n};\n\n/*!\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/*!\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Model.__proto__ = _this;\n  Model.prototype.__proto__ = _this.prototype;\n  Model.db = Model.prototype.db = conn;\n\n  const s = schema && typeof schema !== 'string'\n    ? schema\n    : _this.prototype.schema;\n\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n\n  if (!collection) {\n    collection = _this.prototype.schema.get('collection') ||\n      utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n\n  let bufferCommands = true;\n  if (s) {\n    if (conn.config.bufferCommands != null) {\n      bufferCommands = conn.config.bufferCommands;\n    }\n    if (_userProvidedOptions.bufferCommands != null) {\n      bufferCommands = _userProvidedOptions.bufferCommands;\n    }\n  }\n  const collectionOptions = {\n    bufferCommands: bufferCommands,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.collection = Model.prototype.collection;\n  // Errors handled internally, so ignore\n  Model.init(() => {});\n  return Model;\n};\n\nModel.$wrapCallback = function(callback) {\n  if (callback == null) {\n    return callback;\n  }\n  if (typeof callback !== 'function') {\n    throw new Error('Callback must be a function, got ' + callback);\n  }\n  const _this = this;\n  return function() {\n    try {\n      callback.apply(null, arguments);\n    } catch (error) {\n      _this.emit('error', error);\n    }\n  };\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst Readable = require('stream').Readable;\nconst eachAsync = require('../helpers/cursor/eachAsync');\nconst util = require('util');\nconst utils = require('../utils');\n\n/**\n * An AggregationCursor is a concurrency primitive for processing aggregation\n * results one document at a time. It is analogous to QueryCursor.\n *\n * An AggregationCursor fulfills the Node.js streams3 API,\n * in addition to several other mechanisms for loading documents from MongoDB\n * one at a time.\n *\n * Creating an AggregationCursor executes the model's pre aggregate hooks,\n * but **not** the model's post aggregate hooks.\n *\n * Unless you're an advanced user, do **not** instantiate this class directly.\n * Use [`Aggregate#cursor()`](/docs/api.html#aggregate_Aggregate-cursor) instead.\n *\n * @param {Aggregate} agg\n * @param {Object} options\n * @inherits Readable\n * @event `cursor`: Emitted when the cursor is created\n * @event `error`: Emitted when an error occurred\n * @event `data`: Emitted when the stream is flowing and the next doc is ready\n * @event `end`: Emitted when the stream is exhausted\n * @api public\n */\n\nfunction AggregationCursor(agg) {\n  Readable.call(this, { objectMode: true });\n\n  this.cursor = null;\n  this.agg = agg;\n  this._transforms = [];\n  const model = agg._model;\n  delete agg.options.cursor.useMongooseAggCursor;\n  this._mongooseOptions = {};\n\n  _init(model, this, agg);\n}\n\nutil.inherits(AggregationCursor, Readable);\n\n/*!\n * ignore\n */\n\nfunction _init(model, c, agg) {\n  if (!model.collection.buffer) {\n    model.hooks.execPre('aggregate', agg, function() {\n      c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n      c.emit('cursor', c.cursor);\n    });\n  } else {\n    model.collection.emitter.once('queue', function() {\n      model.hooks.execPre('aggregate', agg, function() {\n        c.cursor = model.collection.aggregate(agg._pipeline, agg.options || {});\n        c.emit('cursor', c.cursor);\n      });\n    });\n  }\n}\n\n/*!\n * Necessary to satisfy the Readable API\n */\n\nAggregationCursor.prototype._read = function() {\n  const _this = this;\n  _next(this, function(error, doc) {\n    if (error) {\n      return _this.emit('error', error);\n    }\n    if (!doc) {\n      _this.push(null);\n      _this.cursor.close(function(error) {\n        if (error) {\n          return _this.emit('error', error);\n        }\n        setTimeout(function() {\n          _this.emit('close');\n        }, 0);\n      });\n      return;\n    }\n    _this.push(doc);\n  });\n};\n\n/**\n * Registers a transform function which subsequently maps documents retrieved\n * via the streams interface or `.next()`\n *\n * ####Example\n *\n *     // Map documents returned by `data` events\n *     Thing.\n *       find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *        doc.foo = \"bar\";\n *        return doc;\n *       })\n *       on('data', function(doc) { console.log(doc.foo); });\n *\n *     // Or map documents returned by `.next()`\n *     var cursor = Thing.find({ name: /^hello/ }).\n *       cursor().\n *       map(function (doc) {\n *         doc.foo = \"bar\";\n *         return doc;\n *       });\n *     cursor.next(function(error, doc) {\n *       console.log(doc.foo);\n *     });\n *\n * @param {Function} fn\n * @return {AggregationCursor}\n * @api public\n * @method map\n */\n\nAggregationCursor.prototype.map = function(fn) {\n  this._transforms.push(fn);\n  return this;\n};\n\n/*!\n * Marks this cursor as errored\n */\n\nAggregationCursor.prototype._markError = function(error) {\n  this._error = error;\n  return this;\n};\n\n/**\n * Marks this cursor as closed. Will stop streaming and subsequent calls to\n * `next()` will error.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method close\n * @emits close\n * @see MongoDB driver cursor#close http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#close\n */\n\nAggregationCursor.prototype.close = function(callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    this.cursor.close(error => {\n      if (error) {\n        cb(error);\n        return this.listeners('error').length > 0 && this.emit('error', error);\n      }\n      this.emit('close');\n      cb(null);\n    });\n  });\n};\n\n/**\n * Get the next document from this cursor. Will return `null` when there are\n * no documents left.\n *\n * @param {Function} callback\n * @return {Promise}\n * @api public\n * @method next\n */\n\nAggregationCursor.prototype.next = function(callback) {\n  return utils.promiseOrCallback(callback, cb => {\n    _next(this, cb);\n  });\n};\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} fn\n * @param {Object} [options]\n * @param {Number} [options.parallel] the number of promises to execute in parallel. Defaults to 1.\n * @param {Function} [callback] executed when all docs have been processed\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nAggregationCursor.prototype.eachAsync = function(fn, opts, callback) {\n  const _this = this;\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts || {};\n\n  return eachAsync(function(cb) { return _next(_this, cb); }, fn, opts, callback);\n};\n\n/*!\n * ignore\n */\n\nAggregationCursor.prototype.transformNull = function(val) {\n  if (arguments.length === 0) {\n    val = true;\n  }\n  this._mongooseOptions.transformNull = val;\n  return this;\n};\n\n/**\n * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.2/api/Cursor.html#addCursorFlag).\n * Useful for setting the `noCursorTimeout` and `tailable` flags.\n *\n * @param {String} flag\n * @param {Boolean} value\n * @return {AggregationCursor} this\n * @api public\n * @method addCursorFlag\n */\n\nAggregationCursor.prototype.addCursorFlag = function(flag, value) {\n  const _this = this;\n  _waitForCursor(this, function() {\n    _this.cursor.addCursorFlag(flag, value);\n  });\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _waitForCursor(ctx, cb) {\n  if (ctx.cursor) {\n    return cb();\n  }\n  ctx.once('cursor', function() {\n    cb();\n  });\n}\n\n/*!\n * Get the next doc from the underlying cursor and mongooseify it\n * (populate, etc.)\n */\n\nfunction _next(ctx, cb) {\n  let callback = cb;\n  if (ctx._transforms.length) {\n    callback = function(err, doc) {\n      if (err || (doc === null && !ctx._mongooseOptions.transformNull)) {\n        return cb(err, doc);\n      }\n      cb(err, ctx._transforms.reduce(function(doc, fn) {\n        return fn(doc);\n      }, doc));\n    };\n  }\n\n  if (ctx._error) {\n    return process.nextTick(function() {\n      callback(ctx._error);\n    });\n  }\n\n  if (ctx.cursor) {\n    return ctx.cursor.next(function(error, doc) {\n      if (error) {\n        return callback(error);\n      }\n      if (!doc) {\n        return callback(null, null);\n      }\n\n      callback(null, doc);\n    });\n  } else {\n    ctx.once('cursor', function() {\n      _next(ctx, cb);\n    });\n  }\n}\n\nmodule.exports = AggregationCursor;\n","'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EventEmitter = require('events').EventEmitter;\n\n/*!\n * ignore\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(model, pipeline, options) {\n    super();\n\n    this.driverChangeStream = null;\n    this.closed = false;\n    // This wrapper is necessary because of buffering.\n    if (model.collection.buffer) {\n      model.collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        this.driverChangeStream = model.collection.watch(pipeline, options);\n        this._bindEvents();\n        this.emit('ready');\n      });\n    } else {\n      this.driverChangeStream = model.collection.watch(pipeline, options);\n      this._bindEvents();\n      this.emit('ready');\n    }\n  }\n\n  _bindEvents() {\n    ['close', 'change', 'end', 'error'].forEach(ev => {\n      this.driverChangeStream.on(ev, data => this.emit(ev, data));\n    });\n  }\n\n  _queue(cb) {\n    this.once('ready', () => cb());\n  }\n\n  close() {\n    this.closed = true;\n    if (this.driverChangeStream) {\n      this.driverChangeStream.close();\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = ChangeStream;\n","'use strict';\n\nconst get = require('lodash.get');\n\n/*!\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n    if (schema.reserved[method] &&\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      console.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\n        'what you\\'re doing, you can suppress this error by using ' +\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (let i = 0; i < schema.childSchemas.length; ++i) {\n    if (schema.childSchemas[i].model.$appliedMethods) {\n      continue;\n    }\n    applyMethods(schema.childSchemas[i].model, schema.childSchemas[i].schema);\n  }\n};\n","'use strict';\n\n/*!\n * Register statics for this model\n * @param {Model} model\n * @param {Schema} schema\n */\nmodule.exports = function applyStatics(model, schema) {\n  for (const i in schema.statics) {\n    model[i] = schema.statics[i];\n  }\n};\n","'use strict';\n\nmodule.exports = assignRawDocsToIdStructure;\n\n/*!\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} vals\n * @param {Boolean} sort\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order\n  const newOrder = [];\n  const sorting = options.sort && rawIds.length > 1;\n  let doc;\n  let sid;\n  let id;\n\n  for (let i = 0; i < rawIds.length; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && !sorting) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n\n    if (recursed) {\n      // apply find behavior\n\n      // assign matching documents in original order unless sorting\n      doc = resultDocs[sid];\n      if (doc) {\n        if (sorting) {\n          newOrder[resultOrder[sid]] = doc;\n        } else {\n          newOrder.push(doc);\n        }\n      } else {\n        newOrder.push(id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc = resultDocs[sid] || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}","'use strict';\n\nconst applyTimestampsToChildren = require('../update/applyTimestampsToChildren');\nconst applyTimestampsToUpdate = require('../update/applyTimestampsToUpdate');\nconst cast = require('../../cast');\nconst castUpdate = require('../query/castUpdate');\nconst setDefaultsOnInsert = require('../setDefaultsOnInsert');\n\n/*!\n * Given a model and a bulkWrite op, return a thunk that handles casting and\n * validating the individual op.\n */\n\nmodule.exports = function castBulkWrite(model, op) {\n  const now = model.base.now();\n\n  if (op['insertOne']) {\n    return (callback) => {\n      const doc = new model(op['insertOne']['document']);\n      if (model.schema.options.timestamps != null) {\n        doc.initializeTimestamps();\n      }\n\n      op['insertOne']['document'] = doc;\n      op['insertOne']['document'].validate({ __noPromise: true }, function(error) {\n        if (error) {\n          return callback(error, null);\n        }\n        callback(null);\n      });\n    };\n  } else if (op['updateOne']) {\n    op = op['updateOne'];\n    return (callback) => {\n      try {\n        op['filter'] = cast(model.schema, op['filter']);\n        op['update'] = castUpdate(model.schema, op['update'], {\n          strict: model.schema.options.strict,\n          overwrite: false\n        });\n        if (op.setDefaultsOnInsert) {\n          setDefaultsOnInsert(op['filter'], model.schema, op['update'], {\n            setDefaultsOnInsert: true,\n            upsert: op.upsert\n          });\n        }\n        if (model.schema.$timestamps != null) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, op['update'], {});\n        }\n        applyTimestampsToChildren(now, op['update'], model.schema);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['updateMany']) {\n    op = op['updateMany'];\n    return (callback) => {\n      try {\n        op['filter'] = cast(model.schema, op['filter']);\n        op['update'] = castUpdate(model.schema, op['update'], {\n          strict: model.schema.options.strict,\n          overwrite: false\n        });\n        if (op.setDefaultsOnInsert) {\n          setDefaultsOnInsert(op['filter'], model.schema, op['update'], {\n            setDefaultsOnInsert: true,\n            upsert: op.upsert\n          });\n        }\n        if (model.schema.$timestamps != null) {\n          const createdAt = model.schema.$timestamps.createdAt;\n          const updatedAt = model.schema.$timestamps.updatedAt;\n          applyTimestampsToUpdate(now, createdAt, updatedAt, op['update'], {});\n        }\n        applyTimestampsToChildren(now, op['update'], model.schema);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['replaceOne']) {\n    return (callback) => {\n      try {\n        op['replaceOne']['filter'] = cast(model.schema,\n          op['replaceOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      // set `skipId`, otherwise we get \"_id field cannot be changed\"\n      const doc = new model(op['replaceOne']['replacement'], null, true);\n      if (model.schema.options.timestamps != null) {\n        doc.initializeTimestamps();\n      }\n      op['replaceOne']['replacement'] = doc;\n\n      op['replaceOne']['replacement'].validate({ __noPromise: true }, function(error) {\n        if (error) {\n          return callback(error, null);\n        }\n        callback(null);\n      });\n    };\n  } else if (op['deleteOne']) {\n    return (callback) => {\n      try {\n        op['deleteOne']['filter'] = cast(model.schema,\n          op['deleteOne']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else if (op['deleteMany']) {\n    return (callback) => {\n      try {\n        op['deleteMany']['filter'] = cast(model.schema,\n          op['deleteMany']['filter']);\n      } catch (error) {\n        return callback(error, null);\n      }\n\n      callback(null);\n    };\n  } else {\n    return (callback) => {\n      callback(new Error('Invalid op passed to `bulkWrite()`'), null);\n    };\n  }\n};","'use strict';\n\nconst isDefiningProjection = require('./isDefiningProjection');\n\n/*!\n * Determines if `path` is excluded by `projection`\n *\n * @param {Object} projection\n * @param {string} path\n * @return {Boolean}\n */\n\nmodule.exports = function isPathExcluded(projection, path) {\n  if (path === '_id') {\n    return projection._id === 0;\n  }\n\n  const paths = Object.keys(projection);\n  let type = null;\n\n  for (const _path of paths) {\n    if (isDefiningProjection(projection[_path])) {\n      type = projection[path] === 1 ? 'inclusive' : 'exclusive';\n      break;\n    }\n  }\n\n  if (type === 'inclusive') {\n    return projection[path] !== 1;\n  }\n  if (type === 'exclusive') {\n    return projection[path] === 0;\n  }\n  return false;\n};\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function isPathSelectedInclusive(fields, path) {\n  const chunks = path.split('.');\n  let cur = '';\n  let j;\n  let keys;\n  let numKeys;\n  for (let i = 0; i < chunks.length; ++i) {\n    cur += cur.length ? '.' : '' + chunks[i];\n    if (fields[cur]) {\n      keys = Object.keys(fields);\n      numKeys = keys.length;\n      for (j = 0; j < numKeys; ++j) {\n        if (keys[i].indexOf(cur + '.') === 0 && keys[i].indexOf(path) !== 0) {\n          continue;\n        }\n      }\n      return true;\n    }\n  }\n\n  return false;\n};\n","'use strict';\n\n/*!\n * ignore\n */\n\nconst Mixed = require('../../schema/mixed');\nconst get = require('lodash.get');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\n\n/*!\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n */\n\nmodule.exports = function getSchemaTypes(schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n\n  if (pathschema) {\n    return pathschema;\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (doc != null && foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              if (keys.indexOf(discriminator) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (let i = 0; i < schemas.length; ++i) {\n              const _ret = search(\n                parts.slice(p),\n                schemas[i],\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$isUnderneathDocArray = _ret.$isUnderneathDocArray ||\n                  !foundschema.schema.$isSingleNested;\n                if (_ret.$isUnderneathDocArray) {\n                  ret.$isUnderneathDocArray = true;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n                !foundschema.schema.$isSingleNested;\n            }\n\n            return ret;\n          }\n        }\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc.$__ && topLevelDoc.populated(fullPath) && p < parts.length) {\n        const schema = get(doc.$__.populated[fullPath], 'options.model.schema');\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n              !schema.$isSingleNested;\n          }\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret) {\n            ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||\n              !schema.$isSingleNested;\n          }\n\n          return ret;\n        }\n      }\n\n      return foundschema;\n    }\n  }\n\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n","'use strict';\n\nmodule.exports = getVirtual;\n\n/*!\n * ignore\n */\n\nfunction getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return schema.virtuals[name];\n  }\n  const parts = name.split('.');\n  let cur = '';\n  let nestedSchemaPath = '';\n  for (let i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        schema.virtuals[cur].$nestedSchemaPath = nestedSchemaPath;\n        return schema.virtuals[cur];\n      }\n      continue;\n    }\n\n    if (schema.nested[cur]) {\n      continue;\n    }\n\n    if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      const rest = parts.slice(i + 1).join('.');\n\n      if (schema.virtuals[rest]) {\n        if (i === parts.length - 2) {\n          schema.virtuals[rest].$nestedSchemaPath =\n            [nestedSchemaPath, cur].filter(v => !!v).join('.');\n          return schema.virtuals[rest];\n        }\n        continue;\n      }\n\n      if (i + 1 < parts.length && schema.discriminators) {\n        for (const key of Object.keys(schema.discriminators)) {\n          const _virtual = getVirtual(schema.discriminators[key], rest);\n          if (_virtual != null) {\n            _virtual.$nestedSchemaPath = [nestedSchemaPath, cur].\n              filter(v => !!v).join('.');\n            return _virtual;\n          }\n        }\n      }\n\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n      continue;\n    }\n\n    return null;\n  }\n}\n","'use strict';\n\n/*!\n * Set `$parentSchema` on all schema types, and `$schemaType` on single\n * nested docs.\n *\n * This is a slow path function, should only run when model is compiled\n */\n\nmodule.exports = function setParentPointers(schema, skipRecursion) {\n  for (const path of Object.keys(schema.paths)) {\n    const schemaType = schema.paths[path];\n    if (schemaType.schema != null) {\n      Object.defineProperty(schemaType.schema, '$schemaType', {\n        configurable: true,\n        writable: false,\n        enumerable: false,\n        value: schemaType\n      });\n    }\n    Object.defineProperty(schemaType, '$parentSchema', {\n      configurable: true,\n      writable: false,\n      enumerable: false,\n      value: schema\n    });\n  }\n\n  // `childSchemas` contains all descendant schemas, so no need to recurse\n  // further.\n  if (skipRecursion) {\n    return;\n  }\n\n  for (const obj of schema.childSchemas) {\n    setParentPointers(obj.schema, true);\n  }\n};","module.exports = pluralize;\n\n/**\n * Pluralization rules.\n *\n * These rules are applied while processing the argument to `toCollectionName`.\n *\n * @deprecated remove in 4.x gh-1350\n */\n\nexports.pluralization = [\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nvar rules = exports.pluralization;\n\n/**\n * Uncountable words.\n *\n * These words are applied while processing the argument to `toCollectionName`.\n * @api public\n */\n\nexports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nvar uncountables = exports.uncountables;\n\n/*!\n * Pluralize function.\n *\n * @author TJ Holowaychuk (extracted from _ext.js_)\n * @param {String} string to pluralize\n * @api private\n */\n\nfunction pluralize(str) {\n  var found;\n  str = str.toLowerCase();\n  if (!~uncountables.indexOf(str)) {\n    found = rules.filter(function(rule) {\n      return str.match(rule[0]);\n    });\n    if (found[0]) {\n      return str.replace(found[0][0], found[0][1]);\n    }\n  }\n  return str;\n}\n","'use strict';\n\nconst each = require('async/each');\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schema) {\n  const unshift = true;\n  schema.s.hooks.pre('remove', false, function(next) {\n    if (this.ownerDocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$__getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.$__remove(function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.schema.s.hooks.execPost('remove:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n};\n","'use strict';\n\nconst each = require('async/each');\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schema) {\n  const unshift = true;\n  schema.s.hooks.pre('save', false, function(next) {\n    if (this.ownerDocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$__getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.schema.s.hooks.execPre('save', subdoc, function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n\n  schema.s.hooks.post('save', function(doc, next) {\n    if (this.ownerDocument) {\n      next();\n      return;\n    }\n\n    const _this = this;\n    const subdocs = this.$__getAllSubdocs();\n\n    if (!subdocs.length) {\n      next();\n      return;\n    }\n\n    each(subdocs, function(subdoc, cb) {\n      subdoc.schema.s.hooks.execPost('save', subdoc, [subdoc], function(err) {\n        cb(err);\n      });\n    }, function(error) {\n      if (error) {\n        return _this.schema.s.hooks.execPost('save:error', _this, [_this], { error: error }, function(error) {\n          next(error);\n        });\n      }\n      next();\n    });\n  }, null, unshift);\n};\n","'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schema) {\n  const unshift = true;\n  schema.pre('save', false, function(next, options) {\n    const _this = this;\n    // Nested docs have their own presave\n    if (this.ownerDocument) {\n      return next();\n    }\n\n    const hasValidateBeforeSaveOption = options &&\n        (typeof options === 'object') &&\n        ('validateBeforeSave' in options);\n\n    let shouldValidate;\n    if (hasValidateBeforeSaveOption) {\n      shouldValidate = !!options.validateBeforeSave;\n    } else {\n      shouldValidate = this.schema.options.validateBeforeSave;\n    }\n\n    // Validate\n    if (shouldValidate) {\n      this.validate(function(error) {\n        return _this.schema.s.hooks.execPost('save:error', _this, [ _this], { error: error }, function(error) {\n          next(error);\n        });\n      });\n    } else {\n      next();\n    }\n  }, null, unshift);\n};\n","'use strict';\n\nconst utils = require('../utils');\n\n/*!\n * ignore\n */\n\nmodule.exports = function shardingPlugin(schema) {\n  schema.post('init', function() {\n    storeShard.call(this);\n    return this;\n  });\n  schema.pre('save', function(next) {\n    applyWhere.call(this);\n    next();\n  });\n  schema.post('save', function() {\n    storeShard.call(this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction applyWhere() {\n  let paths;\n  let len;\n\n  if (this.$__.shardval) {\n    paths = Object.keys(this.$__.shardval);\n    len = paths.length;\n\n    this.$where = this.$where || {};\n    for (let i = 0; i < len; ++i) {\n      this.$where[paths[i]] = this.$__.shardval[paths[i]];\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports.storeShard = storeShard;\n\n/*!\n * ignore\n */\n\nfunction storeShard() {\n  // backwards compat\n  const key = this.schema.options.shardKey || this.schema.options.shardkey;\n  if (!(key && utils.getFunctionName(key.constructor) === 'Object')) {\n    return;\n  }\n\n  const orig = this.$__.shardval = {};\n  const paths = Object.keys(key);\n  const len = paths.length;\n  let val;\n\n  for (let i = 0; i < len; ++i) {\n    val = this.getValue(paths[i]);\n    if (utils.isMongooseObject(val)) {\n      orig[paths[i]] = val.toObject({depopulate: true, _isNested: true});\n    } else if (val !== null && val !== undefined && val.valueOf &&\n    // Explicitly don't take value of dates\n        (!val.constructor || utils.getFunctionName(val.constructor) !== 'Date')) {\n      orig[paths[i]] = val.valueOf();\n    } else {\n      orig[paths[i]] = val;\n    }\n  }\n}\n","/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst STATES = require('../../connectionstate');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nNativeConnection.prototype.__proto__ = MongooseConnection.prototype;\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db.\n *\n * @param {String} name The database name\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  if (options && options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    newConn.db = _this.client.db(name);\n    newConn.onOpen();\n    // setup the events appropriately\n    listen(newConn);\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  this.otherDbs.push(newConn);\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/*!\n * Register listeners for important events and bubble appropriately.\n */\n\nfunction listen(conn) {\n  if (conn.db._listening) {\n    return;\n  }\n  conn.db._listening = true;\n\n  conn.db.on('close', function(force) {\n    if (conn._closeCalled) return;\n\n    // the driver never emits an `open` event. auto_reconnect still\n    // emits a `close` event but since we never get another\n    // `open` we can't emit close\n    if (conn.db.serverConfig.autoReconnect) {\n      conn.readyState = STATES.disconnected;\n      conn.emit('close');\n      return;\n    }\n    conn.onClose(force);\n  });\n  conn.db.on('error', function(err) {\n    conn.emit('error', err);\n  });\n  conn.db.on('reconnect', function() {\n    conn.readyState = STATES.connected;\n    conn.emit('reconnect');\n    conn.emit('reconnected');\n    conn.onOpen();\n  });\n  conn.db.on('timeout', function(err) {\n    conn.emit('timeout', err);\n  });\n  conn.db.on('open', function(err, db) {\n    if (STATES.disconnected === conn.readyState && db && db.databaseName) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n    }\n  });\n  conn.db.on('parseError', function(err) {\n    conn.emit('parseError', err);\n  });\n}\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @param {Function} [fn]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = function(force, fn) {\n  this.client.close(force, (err, res) => {\n    // Defer because the driver will wait at least 1ms before finishing closing\n    // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n    // If there's queued operations, you may still get some background work\n    // after the callback is called.\n    setTimeout(() => fn(err, res), 1);\n  });\n  return this;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n"],"mappings":"AACA;;;ACKA;;;;AA8IA;;;;;;;;;;;;;AAtHA;;;;;;;;;;;AAwBA;;;;;;;;;;;;;AA0HA;;;;;;;AAqFA;;;;;;;;AA9BA;;;;;;AAyFA;;;;;;;;AAYA;;;;;;;;AA4CA;;;;;;;;AA4CA;;;;;;;;AAeA;;;;;AASA;;;;;;;;;;;AAaA;;;;;;;;;AA0BA;;;;;;;;;;AA8CA;;;;AAyBA;;;;;;;AAqGA;;;;;;;;AAYA;;;;;;;;AAYA;;;;AAiBA;;;;;;;AASA;;;;;;AAWA;;;;AAQA;;;;;;;;;;;AAaA;;;;;;;;;;;;AA4BA;;;;;;;AAiCA;;;;AAgHA;;;ACt4BA;;;ACFA;;;;AAsNA;;;AA5HA;;;;AAsvEA;;;AAnsEA;;;;AA4FA;;;;AAw8CA;;;;AAdA;;;;;;;;;;;;AAy+BA;;;;AA5vEA;;;;AAsCA;;;;;;;;;AA0BA;;;;;;;AAupEA;;;;AA8JA;;;;AAyTA;;;AC9jGA;;;;AAqkCA;;;AAQA;;;;AAl+BA;;;;;;AA8nBA;;;;AAuLA;;;;AA6MA;;;;AAcA;;;;;;AAsCA;;;;AAmBA;;;ACprCA;;;AAqCA;;;;AAOA;;;;AAWA;;;;;;ACnDA;;;ACJA;;;;;;;AAwEA;;;;;;AAiNA;;;;;;;;;;;AA7QA;;;;;;;;;AAsBA;;;;;;;;;;;AAqEA;;;;AA+BA;;;ACtIA;;;;;;ACQA;;;ACIA;;;ACZA;;;ACAA;;;;AA2CA;;;;AAmCA;;;AC9EA;;;;AAcA;;;AAiGA;;;;AAIA;;;;AAqOA;;;;;;AChVA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACLA;;;ACHA;;;;AAyEA;;;;AA/DA;;;AANA;;;ACJA;;;ACEA;;;AA6CA;;;;AAeA;;;;AA6CA;;;;AAgFA;;;;;;;;AAnBA;;;;AAwFA;;;;AA0DA;;;;AA2HA;;;ACpbA;;;;;ACeA;;;;;ACTA;;;;;;ACCA;;;;;ACDA;;;;;;;ACEA;;;ACRA;;;ACDA;;;;AAwCA;;;ACtBA;;;AClBA;;;;;;;AAuKA;;;;AAQA;;;;AA+RA;;;;AAodA;;;AAndA;;;;AAi0BA;;;;AA6ZA;;;AA9XA;;;;AAgPA;;;;AAiFA;;;;AA2GA;;;AC3tDA;;;;;;;AAeA;;;;;;;ACXA;;;;;;ACIA;;;;;;ACAA;;;;;;AC6hBA;;;;;;;AA8tBA;;;;AAUA;;;;AAwoCA;;;;AAytBA;;;;AAwDA;;;ACtqGA;;;;;;;AAoFA;;;AAhDA;;;;AAeA;;;;AASA;;;AAOA;;;;AAQA;;;ACzEA;;;;;;;;;;ACOA;;;ACTA;;;AA4BA;;;;ACqBA;;;;AAuFA;;;;AC7HA;;;AAwBA;;;;AA/BA;;;;;;;;;;ACkBA;;;;AAdA;;;ACPA;;;ACDA;;;;AAsNA;;;;AArLA;;;;AAyOA;;;AC1QA;;;;AA+HA;;;;AAkGA;;;;AAyKA;;;AC1YA;;;;AAgKA;;;;AAgBA;;;AA7IA;;;;AAKA;;;;ACrCA;;;;;AAqJA;;;ACxJA;;;ACAA;;;;AA2zBA;;;;AAvBA;;;AA5uBA;;;;AAIA;;;;AClDA;;;ACVA;;;AAkGA;;;;AA25CA;;;;;;;;;;;;AA6/BA;;;AA+BA;;;;AA2WA;;;;;;;;;;;AAsNA;;;;;;;;;;;AAsDA;;;;;;;;;;;AAkZA;;;;;AAsQA;;;;AA9rEA;;;;AAuCA;;;;AA0tBA;;;;AA4DA;;;;AA4DA;;;;;;;AA6LA;;;;;;;;AAgLA;;;;;;;;AAuCA;;;;;AAo6BA;;;;;AAlqBA;;;;;;;;AAmHA;;;;;;;;AAWA;;;;;;;;AAWA;;;;;;;;AAwfA;;;;;;;;;;AAyfA;;;;;AA6JA;;;;AA0JA;;;;;ACniJA;;;;;ACAA;;;;;;ACCA;;;;;;;ACCA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACDA;;;;;ACFA;;;;;ACCA;;;;;;ACCA;;;;;;AC2GA;;;;;AC5GA;;;;;ACLA;;;ACFA;;;AAyBA;;;;AA6EA;;;AAMA;;;;AAqHA;;;;AAoGA;;;ACrUA;;;;AA8PA;;;AC9PA;;;;AAyDA;;;ACzDA;;;ACAA;;;AA2BA;;;AC3BA;;;AA4BA;;;AC5BA;;;ACCA;;;;AAoBA;;;;ACjBA;;;;ACFA;;;ACFA;;;;AAQA;;;;;;;;;;ACqBA;;;;AAvBA;;;ACNA;;;;AA6bA;;;;AA3ZA;;;;AAkdA;;;;;;;;;;AC3eA;;;;;;;;;;ACAA;;;ACTA;;;;;;;AAuBA;;;ACvBA;;;;AA4BA;;;;AAmGA;;;AC/HA;;;;;;AA+PA;;;;AAhOA;;;;AAuQA;;;ACtSA;;;;AA8KA;;;;AA5IA;;;;AAsLA;;;ACxNA;;;AAmFA;;;;AAqFA;;;;AAgIA;;;ACxSA;;;;AAOA;;;ACPA;;;;AAOA;;;;ACgGA;;;;AAmBA;;;;AA6CA;;;;;;;;AA+CA;;;;AAdA;;;ACxMA;;;;;;;;;;;;;;;;AC2GA;;;AAmLA;;;;;;;;;;;;;;;;AA/QA;;;;;;;;;;;;;;AA0UA;;;ACzVA;;;;AAkgCA;;;;;;;AAoBA;;;AA78BA;;;;AAyPA;;;AClUA;;;ACAA;;;;;;;AA8UA;;;;AAoQA;;;;AA0VA;;;;;;;ACp6BA;;;;;ACDA;;;;;ACDA;;;;;ACCA;;;;;;ACCA;;;;;;ACAA;;;;;;ACAA;;;;;ACiEA;;;;;;AClDA;;;;;;ACnBA;;;;;ACEA;;;;;ACAA;;;;;;ACEA;;;;;;ACAA;;;;;;;ACCA;;;;;ACFA;;;;;;ACCA;;;;;;;ACCA;;;;;;;ACAA;;;;;ACFA;;;;;;ACCA;;;;;ACDA;;;;;;;ACEA;;;;;;ACDA;;;;;;;ACCA;;;;;;ACDA;;;;;;ACAA;;;;;;ACAA;;;;;ACFA;;;;;;;ACGA;;;;;;;;ACNA;;;;;;;;ACAA;;;ACHA;;;;AA4kBA;;;AAqBA;;;;;;AAwSA;;;ACz4BA;;;ACCA;;;;ACiSA;;;AClSA;;;ACCA;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;AAwCA;;;;AAYA;;;;;;;;AAoBA;;;;;;;;;AAiBA;;;;;;;;;;;;;;AAkCA;;;;;;;;;;;;;;;AAoBA;;;AC1KA;;;;;;AASA;;;AA2BA;;;;AAOA;;;AC3CA;;;AAqCA;;;;;AAQA;;;;AAUA;;;;AAmBA;;;;AAQA;;;AClFA;;;AAsBA;;;;AAOA;;;AC7BA;;;AAmBA;;;;AAOA;;;ACzBA;;;;;AAQA;;;AAcA;;;;AAOA;;;AC7BA;;;;;AAQA;;;AAgBA;;;;AAOA;;;AC/BA;;;;;AAQA;;;AAwBA;;;;AAQA;;;;ACtCA;;;;;;;ACYA;;;ACbA;;;ACFA;;;AAkEA;;;;AAOA;;;;AAeA;;;;;ACpFA;;;;;;;AA+FA;;;ACnGA;;;;AA+DA;;;;;;;AA6SA;;;;;;;;AAmBA;;;AA5UA;;;;AAKA;;;;;;;;;;;AC7CA;;;ACXA;;;;;;;AA4CA;;;;;;;;AA9BA;;;;AAkGA;;;AChHA;;;;AAuIA;;;;AAzGA;;;;AAyHA;;;ACvJA;;;;;ACGA;;;AAMA;;;ACTA;;;;;;;;AAWA;;;ACXA;;;;;AA8OA;;;;;;;AAuEA;;;;AAvPA;;;;AAgEA;;;;AAmGA;;;;AC9NA;;;;;;;;;;;;;;ACWA;;;ACdA;;;ACEA;;;;;;;ACyBA;;;AC3BA;;;ACAA;;;;;;;;;;;;;;;;;;AA4cA;;;;;;;;AAtBA;;;;;;;;;AAgFA;;;;;;;;;;AAqKA;;;;AA7gBA;;;;AAuHA;;;;AAmEA;;;;AA0gBA;;;;AA8GA;;;;AAyWA;;;;AAw0BA;;;;;AA87BA;;;;;;;;AAznDA;;;;;;;;AAUA;;;;AAgxCA;;;;;;;;;;;AA0uBA;;;AAfA;;;;;;AAyDA;;;;;AAiOA;;;;;;;;;;;;;;;;;;AAmBA;;;AAAA;;;;AAkEA;;;;AA+aA;;;;;;;;;AAoCA;;;;;;;AAwGA;;;;;;;;AAnBA;;;;AAuGA;;;ACz7IA;;;;AAgDA;;;AATA;;;;;AAqNA;;;;AAxHA;;;;AA2EA;;;;AAwBA;;;ACvOA;;;;;;;AAmDA;;;;;;AC9CA;;;;;ACJA;;;;;;;;;;;;;;;;;;;;ACiBA;;;;;ACXA;;;;;;;ACDA;;;ACNA;;;ACAA;;;;;;AAWA;;;;ACTA;;;;;;ACCA;;;;;;;;ACyEA;;;AC1EA;;;ACAA;;;ACFA;;;;;;;AC6CA;;;;AAzBA;;;AAZA;;;ACRA;;;;AA0BA;;;;AAiFA;;;;AAmEA","sourceRoot":""}